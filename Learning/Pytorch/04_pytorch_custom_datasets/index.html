<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=prev href=../03_pytorch_computer_vision.pdf><link rel=next href=../05_pytorch_going_modular.pdf><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.7"><title>4 Custom datasets (pdf) - My Documentation</title><link rel=stylesheet href=../../../assets/stylesheets/main.8608ea7d.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Merriweather";--md-code-font:"JetBrains Mono"}</style><link rel=stylesheet href=../../../assets/extra.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script> <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#04-pytorch-custom-datasets class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title="My Documentation" class="md-header__button md-logo" aria-label="My Documentation" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> My Documentation </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 4 Custom datasets (pdf) </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../home/ class=md-tabs__link> Home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../../AI_Model/lenet/lenet5/ class=md-tabs__link> Kiến thức lập trình </a> </li> <li class=md-tabs__item> <a href=../../../Subject/XSTK/Exercise2/homework/ class=md-tabs__link> Môn học </a> </li> <li class=md-tabs__item> <a href=../../../Problem/general/ class=md-tabs__link> CP-Problem </a> </li> <li class=md-tabs__item> <a href=../../../other/other/ class=md-tabs__link> Other </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title="My Documentation" class="md-nav__button md-logo" aria-label="My Documentation" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> My Documentation </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1> <div class="md-nav__link md-nav__container"> <a href=../../../home/ class="md-nav__link "> <span class=md-ellipsis> Home </span> </a> <label class="md-nav__link " for=__nav_1 id=__nav_1_label tabindex=0> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> Home </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../home/about/ class=md-nav__link> <span class=md-ellipsis> About </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> Kiến thức lập trình </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Kiến thức lập trình </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_1> <label class=md-nav__link for=__nav_2_1 id=__nav_2_1_label tabindex=0> <span class=md-ellipsis> Các kiến trúc, mô hình AI và các kĩ thuật </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_1_label aria-expanded=false> <label class=md-nav__title for=__nav_2_1> <span class="md-nav__icon md-icon"></span> Các kiến trúc, mô hình AI và các kĩ thuật </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_1_1> <label class=md-nav__link for=__nav_2_1_1 id=__nav_2_1_1_label tabindex=0> <span class=md-ellipsis> Lenet-5 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_2_1_1_label aria-expanded=false> <label class=md-nav__title for=__nav_2_1_1> <span class="md-nav__icon md-icon"></span> Lenet-5 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../AI_Model/lenet/lenet5/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/lenet/lenetpart1/ class=md-nav__link> <span class=md-ellipsis> Tutorial part 1 </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/lenet/lenetpart2/ class=md-nav__link> <span class=md-ellipsis> Tutorial part 2 </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/lenet/Lenet5_MNIST/ class=md-nav__link> <span class=md-ellipsis> Lenet-5 (Final Project 1) </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_1_2> <label class=md-nav__link for=__nav_2_1_2 id=__nav_2_1_2_label tabindex=0> <span class=md-ellipsis> UNet </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_2_1_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2_1_2> <span class="md-nav__icon md-icon"></span> UNet </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../AI_Model/unet/unet/ class=md-nav__link> <span class=md-ellipsis> Unet tutorial </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/unet/unet_model/ class=md-nav__link> <span class=md-ellipsis> UNet (Final Project 2) </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../AI_Model/essential/essential/ class=md-nav__link> <span class=md-ellipsis> Các kiến thức cần thiết </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_2> <label class=md-nav__link for=__nav_2_2 id=__nav_2_2_label tabindex=0> <span class=md-ellipsis> Python </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2_2> <span class="md-nav__icon md-icon"></span> Python </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Python/Numpy_1/ class=md-nav__link> <span class=md-ellipsis> Numpy 1 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Numpy_2/ class=md-nav__link> <span class=md-ellipsis> Numpy 2 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Pandas/ class=md-nav__link> <span class=md-ellipsis> Pandas </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Python_Pandas_exercise1/ class=md-nav__link> <span class=md-ellipsis> Pandas exercise 1 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Pandas2/ class=md-nav__link> <span class=md-ellipsis> Pandas 2 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Python_Pandas_exercise2/ class=md-nav__link> <span class=md-ellipsis> Pandas exercise 2 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Pandas_Join_Combine/ class=md-nav__link> <span class=md-ellipsis> Pandas Join Combine </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_3 checked> <label class=md-nav__link for=__nav_2_3 id=__nav_2_3_label tabindex=0> <span class=md-ellipsis> PyTorch </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_3_label aria-expanded=true> <label class=md-nav__title for=__nav_2_3> <span class="md-nav__icon md-icon"></span> PyTorch </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../00_pytorch_fundamentals/ class=md-nav__link> <span class=md-ellipsis> 0 Pytorch Fundamentals (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../00_pytorch_and_deep_learning_fundamentals.pdf class=md-nav__link> <span class=md-ellipsis> 0 Deep learning fundamentals (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../01_pytorch_workflow/ class=md-nav__link> <span class=md-ellipsis> 1 Pytorch workflow (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../01_pytorch_workflow.pdf class=md-nav__link> <span class=md-ellipsis> 1 Pytorch workflow (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../02_pytorch_classification/ class=md-nav__link> <span class=md-ellipsis> 2 classification (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../03_pytorch_computer_vision/ class=md-nav__link> <span class=md-ellipsis> 3 Computer vision (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../03_pytorch_computer_vision.pdf class=md-nav__link> <span class=md-ellipsis> 3 Compupter vision (pdf) </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 4 Custom datasets (pdf) </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 4 Custom datasets (pdf) </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#what-is-a-custom-dataset class=md-nav__link> <span class=md-ellipsis> What is a custom dataset? </span> </a> </li> <li class=md-nav__item> <a href=#what-were-going-to-cover class=md-nav__link> <span class=md-ellipsis> What we're going to cover </span> </a> </li> <li class=md-nav__item> <a href=#where-can-can-you-get-help class=md-nav__link> <span class=md-ellipsis> Where can can you get help? </span> </a> </li> <li class=md-nav__item> <a href=#0-importing-pytorch-and-setting-up-device-agnostic-code class=md-nav__link> <span class=md-ellipsis> 0. Importing PyTorch and setting up device-agnostic code </span> </a> </li> <li class=md-nav__item> <a href=#1-get-data class=md-nav__link> <span class=md-ellipsis> 1. Get data </span> </a> </li> <li class=md-nav__item> <a href=#2-become-one-with-the-data-data-preparation class=md-nav__link> <span class=md-ellipsis> 2. Become one with the data (data preparation) </span> </a> <nav class=md-nav aria-label="2. Become one with the data (data preparation)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-visualize-an-image class=md-nav__link> <span class=md-ellipsis> 2.1 Visualize an image </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3-transforming-data class=md-nav__link> <span class=md-ellipsis> 3. Transforming data </span> </a> <nav class=md-nav aria-label="3. Transforming data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-transforming-data-with-torchvisiontransforms class=md-nav__link> <span class=md-ellipsis> 3.1 Transforming data with torchvision.transforms </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-option-1-loading-image-data-using-imagefolder class=md-nav__link> <span class=md-ellipsis> 4. Option 1: Loading Image Data Using ImageFolder </span> </a> <nav class=md-nav aria-label="4. Option 1: Loading Image Data Using ImageFolder"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#41-turn-loaded-images-into-dataloaders class=md-nav__link> <span class=md-ellipsis> 4.1 Turn loaded images into DataLoader's </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5-option-2-loading-image-data-with-a-custom-dataset class=md-nav__link> <span class=md-ellipsis> 5. Option 2: Loading Image Data with a Custom Dataset </span> </a> <nav class=md-nav aria-label="5. Option 2: Loading Image Data with a Custom Dataset"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-creating-a-helper-function-to-get-class-names class=md-nav__link> <span class=md-ellipsis> 5.1 Creating a helper function to get class names </span> </a> </li> <li class=md-nav__item> <a href=#52-create-a-custom-dataset-to-replicate-imagefolder class=md-nav__link> <span class=md-ellipsis> 5.2 Create a custom Dataset to replicate ImageFolder </span> </a> </li> <li class=md-nav__item> <a href=#53-create-a-function-to-display-random-images class=md-nav__link> <span class=md-ellipsis> 5.3 Create a function to display random images </span> </a> </li> <li class=md-nav__item> <a href=#54-turn-custom-loaded-images-into-dataloaders class=md-nav__link> <span class=md-ellipsis> 5.4 Turn custom loaded images into DataLoader's </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6-other-forms-of-transforms-data-augmentation class=md-nav__link> <span class=md-ellipsis> 6. Other forms of transforms (data augmentation) </span> </a> </li> <li class=md-nav__item> <a href=#7-model-0-tinyvgg-without-data-augmentation class=md-nav__link> <span class=md-ellipsis> 7. Model 0: TinyVGG without data augmentation </span> </a> <nav class=md-nav aria-label="7. Model 0: TinyVGG without data augmentation"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#71-creating-transforms-and-loading-data-for-model-0 class=md-nav__link> <span class=md-ellipsis> 7.1 Creating transforms and loading data for Model 0 </span> </a> </li> <li class=md-nav__item> <a href=#72-create-tinyvgg-model-class class=md-nav__link> <span class=md-ellipsis> 7.2 Create TinyVGG model class </span> </a> </li> <li class=md-nav__item> <a href=#73-try-a-forward-pass-on-a-single-image-to-test-the-model class=md-nav__link> <span class=md-ellipsis> 7.3 Try a forward pass on a single image (to test the model) </span> </a> </li> <li class=md-nav__item> <a href=#74-use-torchinfo-to-get-an-idea-of-the-shapes-going-through-our-model class=md-nav__link> <span class=md-ellipsis> 7.4 Use torchinfo to get an idea of the shapes going through our model </span> </a> </li> <li class=md-nav__item> <a href=#75-create-train-test-loop-functions class=md-nav__link> <span class=md-ellipsis> 7.5 Create train &amp; test loop functions </span> </a> </li> <li class=md-nav__item> <a href=#76-creating-a-train-function-to-combine-train_step-and-test_step class=md-nav__link> <span class=md-ellipsis> 7.6 Creating a train() function to combine train_step() and test_step() </span> </a> </li> <li class=md-nav__item> <a href=#77-train-and-evaluate-model-0 class=md-nav__link> <span class=md-ellipsis> 7.7 Train and Evaluate Model 0 </span> </a> </li> <li class=md-nav__item> <a href=#78-plot-the-loss-curves-of-model-0 class=md-nav__link> <span class=md-ellipsis> 7.8 Plot the loss curves of Model 0 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#8-what-should-an-ideal-loss-curve-look-like class=md-nav__link> <span class=md-ellipsis> 8. What should an ideal loss curve look like? </span> </a> <nav class=md-nav aria-label="8. What should an ideal loss curve look like?"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#81-how-to-deal-with-overfitting class=md-nav__link> <span class=md-ellipsis> 8.1 How to deal with overfitting </span> </a> </li> <li class=md-nav__item> <a href=#82-how-to-deal-with-underfitting class=md-nav__link> <span class=md-ellipsis> 8.2 How to deal with underfitting </span> </a> </li> <li class=md-nav__item> <a href=#83-the-balance-between-overfitting-and-underfitting class=md-nav__link> <span class=md-ellipsis> 8.3 The balance between overfitting and underfitting </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#9-model-1-tinyvgg-with-data-augmentation class=md-nav__link> <span class=md-ellipsis> 9. Model 1: TinyVGG with Data Augmentation </span> </a> <nav class=md-nav aria-label="9. Model 1: TinyVGG with Data Augmentation"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#91-create-transform-with-data-augmentation class=md-nav__link> <span class=md-ellipsis> 9.1 Create transform with data augmentation </span> </a> </li> <li class=md-nav__item> <a href=#92-create-train-and-test-datasets-and-dataloaders class=md-nav__link> <span class=md-ellipsis> 9.2 Create train and test Dataset's and DataLoader's </span> </a> </li> <li class=md-nav__item> <a href=#93-construct-and-train-model-1 class=md-nav__link> <span class=md-ellipsis> 9.3 Construct and train Model 1 </span> </a> </li> <li class=md-nav__item> <a href=#94-plot-the-loss-curves-of-model-1 class=md-nav__link> <span class=md-ellipsis> 9.4 Plot the loss curves of Model 1 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#10-compare-model-results class=md-nav__link> <span class=md-ellipsis> 10. Compare model results </span> </a> </li> <li class=md-nav__item> <a href=#11-make-a-prediction-on-a-custom-image class=md-nav__link> <span class=md-ellipsis> 11. Make a prediction on a custom image </span> </a> <nav class=md-nav aria-label="11. Make a prediction on a custom image"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#111-loading-in-a-custom-image-with-pytorch class=md-nav__link> <span class=md-ellipsis> 11.1 Loading in a custom image with PyTorch </span> </a> </li> <li class=md-nav__item> <a href=#112-predicting-on-custom-images-with-a-trained-pytorch-model class=md-nav__link> <span class=md-ellipsis> 11.2 Predicting on custom images with a trained PyTorch model </span> </a> </li> <li class=md-nav__item> <a href=#113-putting-custom-image-prediction-together-building-a-function class=md-nav__link> <span class=md-ellipsis> 11.3 Putting custom image prediction together: building a function </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#main-takeaways class=md-nav__link> <span class=md-ellipsis> Main takeaways </span> </a> </li> <li class=md-nav__item> <a href=#exercises class=md-nav__link> <span class=md-ellipsis> Exercises </span> </a> </li> <li class=md-nav__item> <a href=#extra-curriculum class=md-nav__link> <span class=md-ellipsis> Extra-curriculum </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../05_pytorch_going_modular.pdf class=md-nav__link> <span class=md-ellipsis> 5 Going moduler (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../06_pytorch_transfer_learning/ class=md-nav__link> <span class=md-ellipsis> 6 Transfer learning (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../06_pytorch_transfer_learning.pdf class=md-nav__link> <span class=md-ellipsis> 6 Transfer learning (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../07_pytorch_experiment_tracking/ class=md-nav__link> <span class=md-ellipsis> 7 Experiment tracking (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../07_pytorch_experiment_tracking.pdf class=md-nav__link> <span class=md-ellipsis> 7 Experiment tracking (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../08_pytorch_paper_replicating/ class=md-nav__link> <span class=md-ellipsis> 8 Paper replicating (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../08_pytorch_paper_replicating.pdf class=md-nav__link> <span class=md-ellipsis> 8 Paper replicating (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../09_pytorch_model_deployment.pdf class=md-nav__link> <span class=md-ellipsis> 9 Model deployment(pdf) </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_4> <label class=md-nav__link for=__nav_2_4 id=__nav_2_4_label tabindex=0> <span class=md-ellipsis> Tensorflow </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_4_label aria-expanded=false> <label class=md-nav__title for=__nav_2_4> <span class="md-nav__icon md-icon"></span> Tensorflow </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Tensorflow/00_tensorflow_fundamentals/ class=md-nav__link> <span class=md-ellipsis> 0 Tensorflow fundamentals </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/01_neural_network_regression_in_tensorflow/ class=md-nav__link> <span class=md-ellipsis> 1 Neural network regression </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/02_neural_network_classification_in_tensorflow/ class=md-nav__link> <span class=md-ellipsis> 2 Neural network classification </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/04_transfer_learning_in_tensorflow_part_1_feature_extraction/ class=md-nav__link> <span class=md-ellipsis> 4 Transfer learning </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/10_time_series_forecasting_in_tensorflow/ class=md-nav__link> <span class=md-ellipsis> 10 Time series forecasting </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../OOP_Practice/ class=md-nav__link> <span class=md-ellipsis> OOP Practice </span> </a> </li> <li class=md-nav__item> <a href=../../Visualization/ class=md-nav__link> <span class=md-ellipsis> Visualization </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Môn học </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Môn học </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_1> <label class=md-nav__link for=__nav_3_1 id=__nav_3_1_label tabindex=0> <span class=md-ellipsis> Xác suất thống kê </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_3_1_label aria-expanded=false> <label class=md-nav__title for=__nav_3_1> <span class="md-nav__icon md-icon"></span> Xác suất thống kê </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Subject/XSTK/Exercise2/homework/ class=md-nav__link> <span class=md-ellipsis> Bài tập về nhà buổi 2 </span> </a> </li> <li class=md-nav__item> <a href=../../../Subject/XSTK/Exercise3/homework/ class=md-nav__link> <span class=md-ellipsis> Bài tập về nhà buổi 3 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> CP-Problem </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> CP-Problem </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/general/ class=md-nav__link> <span class=md-ellipsis> General </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2> <label class=md-nav__link for=__nav_4_2 id=__nav_4_2_label tabindex=0> <span class=md-ellipsis> COCI 2006 2007 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_2_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2> <span class="md-nav__icon md-icon"></span> COCI 2006 2007 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Overview/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_2> <label class=md-nav__link for=__nav_4_2_2 id=__nav_4_2_2_label tabindex=0> <span class=md-ellipsis> Contest 1 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_2_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_2> <span class="md-nav__icon md-icon"></span> Contest 1 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P1_MODULO/ class=md-nav__link> <span class=md-ellipsis> MODULO </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P2_HERMAN/ class=md-nav__link> <span class=md-ellipsis> HERMAN </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P3_OKVIRI/ class=md-nav__link> <span class=md-ellipsis> OKVIRI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P4_SLIKAR/ class=md-nav__link> <span class=md-ellipsis> SLIKAR </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P5_BOND/ class=md-nav__link> <span class=md-ellipsis> BOND </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P6_DEBUG/ class=md-nav__link> <span class=md-ellipsis> DEBUG </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_3> <label class=md-nav__link for=__nav_4_2_3 id=__nav_4_2_3_label tabindex=0> <span class=md-ellipsis> Contest 2 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_3> <span class="md-nav__icon md-icon"></span> Contest 2 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P1_R2/ class=md-nav__link> <span class=md-ellipsis> R2 </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P2_ABC/ class=md-nav__link> <span class=md-ellipsis> ABC </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P3_KOLONE/ class=md-nav__link> <span class=md-ellipsis> KOLONE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P4_SJECISTA/ class=md-nav__link> <span class=md-ellipsis> SJECISTA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P5_STOL/ class=md-nav__link> <span class=md-ellipsis> STOL </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P6_STRAZA/ class=md-nav__link> <span class=md-ellipsis> STRAZA </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_4> <label class=md-nav__link for=__nav_4_2_4 id=__nav_4_2_4_label tabindex=0> <span class=md-ellipsis> Contest 3 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_4> <span class="md-nav__icon md-icon"></span> Contest 3 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P1_PATULJCI/ class=md-nav__link> <span class=md-ellipsis> PATULJCI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P2_NPUZZLE/ class=md-nav__link> <span class=md-ellipsis> NPUZZLE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P3_TROJKE/ class=md-nav__link> <span class=md-ellipsis> TROJKE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P4_TENKICI/ class=md-nav__link> <span class=md-ellipsis> TENKICI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P5_BICIKLI/ class=md-nav__link> <span class=md-ellipsis> BICIKLI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P6_LISTA/ class=md-nav__link> <span class=md-ellipsis> LISTA </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_5> <label class=md-nav__link for=__nav_4_2_5 id=__nav_4_2_5_label tabindex=0> <span class=md-ellipsis> Contest 4 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_5_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_5> <span class="md-nav__icon md-icon"></span> Contest 4 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P1_Sibice/ class=md-nav__link> <span class=md-ellipsis> SIBICE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P2_Skener/ class=md-nav__link> <span class=md-ellipsis> SKENER </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P3_Prsteni/ class=md-nav__link> <span class=md-ellipsis> PRSTENI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P4_Zbrka/ class=md-nav__link> <span class=md-ellipsis> ZBRKA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P5_Jogurt/ class=md-nav__link> <span class=md-ellipsis> JOGURT </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P6_Ispiti/ class=md-nav__link> <span class=md-ellipsis> ISPITI </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_6> <label class=md-nav__link for=__nav_4_2_6 id=__nav_4_2_6_label tabindex=0> <span class=md-ellipsis> Contest 5 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_6_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_6> <span class="md-nav__icon md-icon"></span> Contest 5 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P1_Trik/ class=md-nav__link> <span class=md-ellipsis> TRIK </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P2_Natrij/ class=md-nav__link> <span class=md-ellipsis> NATRIJ </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P3_Tenis/ class=md-nav__link> <span class=md-ellipsis> TENIS </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P4_Liga/ class=md-nav__link> <span class=md-ellipsis> LIGA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P5_Ivana/ class=md-nav__link> <span class=md-ellipsis> IVANA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P6_Dvaput/ class=md-nav__link> <span class=md-ellipsis> DVAPUT </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_7> <label class=md-nav__link for=__nav_4_2_7 id=__nav_4_2_7_label tabindex=0> <span class=md-ellipsis> Contest 6 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_7_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_7> <span class="md-nav__icon md-icon"></span> Contest 6 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P1_PRASE/ class=md-nav__link> <span class=md-ellipsis> PRASE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P2_MAGIJA/ class=md-nav__link> <span class=md-ellipsis> MAGIJA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P3_MARATON/ class=md-nav__link> <span class=md-ellipsis> MARATON </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P4_KAMEN/ class=md-nav__link> <span class=md-ellipsis> KAMEN </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P5_V/ class=md-nav__link> <span class=md-ellipsis> V </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P6_PROSTOR/ class=md-nav__link> <span class=md-ellipsis> PROSTOR </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_8> <label class=md-nav__link for=__nav_4_2_8 id=__nav_4_2_8_label tabindex=0> <span class=md-ellipsis> Regional </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_8_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_8> <span class="md-nav__icon md-icon"></span> Regional </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Regional/P1_BARD/ class=md-nav__link> <span class=md-ellipsis> BARD </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Regional/P2_TETRIS/ class=md-nav__link> <span class=md-ellipsis> TETRIS </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Regional/P4_CIRCLE/ class=md-nav__link> <span class=md-ellipsis> CIRCLE </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_9> <label class=md-nav__link for=__nav_4_2_9 id=__nav_4_2_9_label tabindex=0> <span class=md-ellipsis> Croatian Olympiad </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_9_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_9> <span class="md-nav__icon md-icon"></span> Croatian Olympiad </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Olympiad/P1_PATRIK/ class=md-nav__link> <span class=md-ellipsis> PATRIK </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Olympiad/P2_POLICIJA/ class=md-nav__link> <span class=md-ellipsis> POLICIJA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Olympiad/P3_SABOR/ class=md-nav__link> <span class=md-ellipsis> SABOR </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3> <label class=md-nav__link for=__nav_4_3 id=__nav_4_3_label tabindex=0> <span class=md-ellipsis> COCI 2007 2008 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3> <span class="md-nav__icon md-icon"></span> COCI 2007 2008 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Overview/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3_2> <label class=md-nav__link for=__nav_4_3_2 id=__nav_4_3_2_label tabindex=0> <span class=md-ellipsis> Contest 1 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_3_2_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3_2> <span class="md-nav__icon md-icon"></span> Contest 1 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P1_CETVRTA/ class=md-nav__link> <span class=md-ellipsis> CETVRTA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P2_PEG/ class=md-nav__link> <span class=md-ellipsis> PEG </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P3_PRINOVA/ class=md-nav__link> <span class=md-ellipsis> PRINOVA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P4_ZAPIS/ class=md-nav__link> <span class=md-ellipsis> ZAPIS </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P5_SREDNJI/ class=md-nav__link> <span class=md-ellipsis> SREDNJI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P6_STAZA/ class=md-nav__link> <span class=md-ellipsis> STAZA </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3_3> <label class=md-nav__link for=__nav_4_3_3 id=__nav_4_3_3_label tabindex=0> <span class=md-ellipsis> Contest 4 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_3_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3_3> <span class="md-nav__icon md-icon"></span> Contest 4 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P1_CIRCLE/ class=md-nav__link> <span class=md-ellipsis> CIRCLE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P2_VECI/ class=md-nav__link> <span class=md-ellipsis> VECI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P3_LEKTIRA/ class=md-nav__link> <span class=md-ellipsis> LEKTIRA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P4_MUZICARI/ class=md-nav__link> <span class=md-ellipsis> MUZICARI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P5_POKLON/ class=md-nav__link> <span class=md-ellipsis> POKLON </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P6_KOCKE/ class=md-nav__link> <span class=md-ellipsis> KOCKE </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3_4> <label class=md-nav__link for=__nav_4_3_4 id=__nav_4_3_4_label tabindex=0> <span class=md-ellipsis> Contest 6 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_3_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3_4> <span class="md-nav__icon md-icon"></span> Contest 6 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P1_PARKING/ class=md-nav__link> <span class=md-ellipsis> PARKING </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P2_SEMAFORI/ class=md-nav__link> <span class=md-ellipsis> SEMAFORI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P3_GRANICA/ class=md-nav__link> <span class=md-ellipsis> GRANICA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P4_GEORGE/ class=md-nav__link> <span class=md-ellipsis> GEORGE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P5_PRINCEZA/ class=md-nav__link> <span class=md-ellipsis> PRINCEZA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P6_CESTARINE/ class=md-nav__link> <span class=md-ellipsis> CESTARINE </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../../other/other/ class=md-nav__link> <span class=md-ellipsis> Other </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#what-is-a-custom-dataset class=md-nav__link> <span class=md-ellipsis> What is a custom dataset? </span> </a> </li> <li class=md-nav__item> <a href=#what-were-going-to-cover class=md-nav__link> <span class=md-ellipsis> What we're going to cover </span> </a> </li> <li class=md-nav__item> <a href=#where-can-can-you-get-help class=md-nav__link> <span class=md-ellipsis> Where can can you get help? </span> </a> </li> <li class=md-nav__item> <a href=#0-importing-pytorch-and-setting-up-device-agnostic-code class=md-nav__link> <span class=md-ellipsis> 0. Importing PyTorch and setting up device-agnostic code </span> </a> </li> <li class=md-nav__item> <a href=#1-get-data class=md-nav__link> <span class=md-ellipsis> 1. Get data </span> </a> </li> <li class=md-nav__item> <a href=#2-become-one-with-the-data-data-preparation class=md-nav__link> <span class=md-ellipsis> 2. Become one with the data (data preparation) </span> </a> <nav class=md-nav aria-label="2. Become one with the data (data preparation)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-visualize-an-image class=md-nav__link> <span class=md-ellipsis> 2.1 Visualize an image </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3-transforming-data class=md-nav__link> <span class=md-ellipsis> 3. Transforming data </span> </a> <nav class=md-nav aria-label="3. Transforming data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-transforming-data-with-torchvisiontransforms class=md-nav__link> <span class=md-ellipsis> 3.1 Transforming data with torchvision.transforms </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-option-1-loading-image-data-using-imagefolder class=md-nav__link> <span class=md-ellipsis> 4. Option 1: Loading Image Data Using ImageFolder </span> </a> <nav class=md-nav aria-label="4. Option 1: Loading Image Data Using ImageFolder"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#41-turn-loaded-images-into-dataloaders class=md-nav__link> <span class=md-ellipsis> 4.1 Turn loaded images into DataLoader's </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5-option-2-loading-image-data-with-a-custom-dataset class=md-nav__link> <span class=md-ellipsis> 5. Option 2: Loading Image Data with a Custom Dataset </span> </a> <nav class=md-nav aria-label="5. Option 2: Loading Image Data with a Custom Dataset"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-creating-a-helper-function-to-get-class-names class=md-nav__link> <span class=md-ellipsis> 5.1 Creating a helper function to get class names </span> </a> </li> <li class=md-nav__item> <a href=#52-create-a-custom-dataset-to-replicate-imagefolder class=md-nav__link> <span class=md-ellipsis> 5.2 Create a custom Dataset to replicate ImageFolder </span> </a> </li> <li class=md-nav__item> <a href=#53-create-a-function-to-display-random-images class=md-nav__link> <span class=md-ellipsis> 5.3 Create a function to display random images </span> </a> </li> <li class=md-nav__item> <a href=#54-turn-custom-loaded-images-into-dataloaders class=md-nav__link> <span class=md-ellipsis> 5.4 Turn custom loaded images into DataLoader's </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6-other-forms-of-transforms-data-augmentation class=md-nav__link> <span class=md-ellipsis> 6. Other forms of transforms (data augmentation) </span> </a> </li> <li class=md-nav__item> <a href=#7-model-0-tinyvgg-without-data-augmentation class=md-nav__link> <span class=md-ellipsis> 7. Model 0: TinyVGG without data augmentation </span> </a> <nav class=md-nav aria-label="7. Model 0: TinyVGG without data augmentation"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#71-creating-transforms-and-loading-data-for-model-0 class=md-nav__link> <span class=md-ellipsis> 7.1 Creating transforms and loading data for Model 0 </span> </a> </li> <li class=md-nav__item> <a href=#72-create-tinyvgg-model-class class=md-nav__link> <span class=md-ellipsis> 7.2 Create TinyVGG model class </span> </a> </li> <li class=md-nav__item> <a href=#73-try-a-forward-pass-on-a-single-image-to-test-the-model class=md-nav__link> <span class=md-ellipsis> 7.3 Try a forward pass on a single image (to test the model) </span> </a> </li> <li class=md-nav__item> <a href=#74-use-torchinfo-to-get-an-idea-of-the-shapes-going-through-our-model class=md-nav__link> <span class=md-ellipsis> 7.4 Use torchinfo to get an idea of the shapes going through our model </span> </a> </li> <li class=md-nav__item> <a href=#75-create-train-test-loop-functions class=md-nav__link> <span class=md-ellipsis> 7.5 Create train &amp; test loop functions </span> </a> </li> <li class=md-nav__item> <a href=#76-creating-a-train-function-to-combine-train_step-and-test_step class=md-nav__link> <span class=md-ellipsis> 7.6 Creating a train() function to combine train_step() and test_step() </span> </a> </li> <li class=md-nav__item> <a href=#77-train-and-evaluate-model-0 class=md-nav__link> <span class=md-ellipsis> 7.7 Train and Evaluate Model 0 </span> </a> </li> <li class=md-nav__item> <a href=#78-plot-the-loss-curves-of-model-0 class=md-nav__link> <span class=md-ellipsis> 7.8 Plot the loss curves of Model 0 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#8-what-should-an-ideal-loss-curve-look-like class=md-nav__link> <span class=md-ellipsis> 8. What should an ideal loss curve look like? </span> </a> <nav class=md-nav aria-label="8. What should an ideal loss curve look like?"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#81-how-to-deal-with-overfitting class=md-nav__link> <span class=md-ellipsis> 8.1 How to deal with overfitting </span> </a> </li> <li class=md-nav__item> <a href=#82-how-to-deal-with-underfitting class=md-nav__link> <span class=md-ellipsis> 8.2 How to deal with underfitting </span> </a> </li> <li class=md-nav__item> <a href=#83-the-balance-between-overfitting-and-underfitting class=md-nav__link> <span class=md-ellipsis> 8.3 The balance between overfitting and underfitting </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#9-model-1-tinyvgg-with-data-augmentation class=md-nav__link> <span class=md-ellipsis> 9. Model 1: TinyVGG with Data Augmentation </span> </a> <nav class=md-nav aria-label="9. Model 1: TinyVGG with Data Augmentation"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#91-create-transform-with-data-augmentation class=md-nav__link> <span class=md-ellipsis> 9.1 Create transform with data augmentation </span> </a> </li> <li class=md-nav__item> <a href=#92-create-train-and-test-datasets-and-dataloaders class=md-nav__link> <span class=md-ellipsis> 9.2 Create train and test Dataset's and DataLoader's </span> </a> </li> <li class=md-nav__item> <a href=#93-construct-and-train-model-1 class=md-nav__link> <span class=md-ellipsis> 9.3 Construct and train Model 1 </span> </a> </li> <li class=md-nav__item> <a href=#94-plot-the-loss-curves-of-model-1 class=md-nav__link> <span class=md-ellipsis> 9.4 Plot the loss curves of Model 1 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#10-compare-model-results class=md-nav__link> <span class=md-ellipsis> 10. Compare model results </span> </a> </li> <li class=md-nav__item> <a href=#11-make-a-prediction-on-a-custom-image class=md-nav__link> <span class=md-ellipsis> 11. Make a prediction on a custom image </span> </a> <nav class=md-nav aria-label="11. Make a prediction on a custom image"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#111-loading-in-a-custom-image-with-pytorch class=md-nav__link> <span class=md-ellipsis> 11.1 Loading in a custom image with PyTorch </span> </a> </li> <li class=md-nav__item> <a href=#112-predicting-on-custom-images-with-a-trained-pytorch-model class=md-nav__link> <span class=md-ellipsis> 11.2 Predicting on custom images with a trained PyTorch model </span> </a> </li> <li class=md-nav__item> <a href=#113-putting-custom-image-prediction-together-building-a-function class=md-nav__link> <span class=md-ellipsis> 11.3 Putting custom image prediction together: building a function </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#main-takeaways class=md-nav__link> <span class=md-ellipsis> Main takeaways </span> </a> </li> <li class=md-nav__item> <a href=#exercises class=md-nav__link> <span class=md-ellipsis> Exercises </span> </a> </li> <li class=md-nav__item> <a href=#extra-curriculum class=md-nav__link> <span class=md-ellipsis> Extra-curriculum </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p><a href=https://colab.research.google.com/github/mrdbourke/pytorch-deep-learning/blob/main/04_pytorch_custom_datasets.ipynb target=_parent><img src=https://colab.research.google.com/assets/colab-badge.svg alt="Open In Colab"></a></p> <p><a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/04_pytorch_custom_datasets.ipynb>View Source Code</a> | <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/slides/04_pytorch_custom_datasets.pdf>View Slides</a> | <a href="https://youtu.be/Z_ikDlimN6A?t=71010">Watch Video Walkthrough</a> </p> <h1 id=04-pytorch-custom-datasets>04. PyTorch Custom Datasets</h1> <p>In the last notebook, <a href=https://www.learnpytorch.io/03_pytorch_computer_vision/ >notebook 03</a>, we looked at how to build computer vision models on an in-built dataset in PyTorch (FashionMNIST).</p> <p>The steps we took are similar across many different problems in machine learning.</p> <p>Find a dataset, turn the dataset into numbers, build a model (or find an existing model) to find patterns in those numbers that can be used for prediction.</p> <p>PyTorch has many built-in datasets used for a wide number of machine learning benchmarks, however, you'll often want to use your own <strong>custom dataset</strong>.</p> <h2 id=what-is-a-custom-dataset>What is a custom dataset?</h2> <p>A <strong>custom dataset</strong> is a collection of data relating to a specific problem you're working on.</p> <p>In essence, a <strong>custom dataset</strong> can be comprised of almost anything.</p> <p>For example, if we were building a food image classification app like <a href=https://nutrify.app>Nutrify</a>, our custom dataset might be images of food.</p> <p>Or if we were trying to build a model to classify whether or not a text-based review on a website was positive or negative, our custom dataset might be examples of existing customer reviews and their ratings.</p> <p>Or if we were trying to build a sound classification app, our custom dataset might be sound samples alongside their sample labels.</p> <p>Or if we were trying to build a recommendation system for customers purchasing things on our website, our custom dataset might be examples of products other people have bought.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pytorch-domain-libraries.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pytorch-domain-libraries.png width=1000/ alt="different pytorch domain libraries can be used for specific PyTorch problems"></a></p> <p><em>PyTorch includes many existing functions to load in various custom datasets in the <a href=https://pytorch.org/vision/stable/index.html><code>TorchVision</code></a>, <a href=https://pytorch.org/text/stable/index.html><code>TorchText</code></a>, <a href=https://pytorch.org/audio/stable/index.html><code>TorchAudio</code></a> and <a href=https://pytorch.org/torchrec/ ><code>TorchRec</code></a> domain libraries.</em></p> <p>But sometimes these existing functions may not be enough.</p> <p>In that case, we can always subclass <code>torch.utils.data.Dataset</code> and customize it to our liking.</p> <h2 id=what-were-going-to-cover>What we're going to cover</h2> <p>We're going to be applying the PyTorch Workflow we covered in <a href=https://www.learnpytorch.io/01_pytorch_workflow/ >notebook 01</a> and <a href=https://www.learnpytorch.io/02_pytorch_classification/ >notebook 02</a> to a computer vision problem.</p> <p>But instead of using an in-built PyTorch dataset, we're going to be using our own dataset of pizza, steak and sushi images.</p> <p>The goal will be to load these images and then build a model to train and predict on them.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pytorch-food-vision-layout.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pytorch-food-vision-layout.png alt="building a pipeline to load in food images and then building a pytorch model to classify those food images" width=800></a></p> <p><em>What we're going to build. We'll use <code>torchvision.datasets</code> as well as our own custom <code>Dataset</code> class to load in images of food and then we'll build a PyTorch computer vision model to hopefully be able to classify them.</em></p> <p>Specifically, we're going to cover:</p> <table> <thead> <tr> <th><strong>Topic</strong></th> <th><strong>Contents</strong></th> </tr> </thead> <tbody> <tr> <td><strong>0. Importing PyTorch and setting up device-agnostic code</strong></td> <td>Let's get PyTorch loaded and then follow best practice to setup our code to be device-agnostic.</td> </tr> <tr> <td><strong>1. Get data</strong></td> <td>We're going to be using our own <strong>custom dataset</strong> of pizza, steak and sushi images.</td> </tr> <tr> <td><strong>2. Become one with the data (data preparation)</strong></td> <td>At the beginning of any new machine learning problem, it's paramount to understand the data you're working with. Here we'll take some steps to figure out what data we have.</td> </tr> <tr> <td><strong>3. Transforming data</strong></td> <td>Often, the data you get won't be 100% ready to use with a machine learning model, here we'll look at some steps we can take to <em>transform</em> our images so they're ready to be used with a model.</td> </tr> <tr> <td><strong>4. Loading data with <code>ImageFolder</code> (option 1)</strong></td> <td>PyTorch has many in-built data loading functions for common types of data. <code>ImageFolder</code> is helpful if our images are in standard image classification format.</td> </tr> <tr> <td><strong>5. Loading image data with a custom <code>Dataset</code></strong></td> <td>What if PyTorch didn't have an in-built function to load data with? This is where we can build our own custom subclass of <code>torch.utils.data.Dataset</code>.</td> </tr> <tr> <td><strong>6. Other forms of transforms (data augmentation)</strong></td> <td>Data augmentation is a common technique for expanding the diversity of your training data. Here we'll explore some of <code>torchvision</code>'s in-built data augmentation functions.</td> </tr> <tr> <td><strong>7. Model 0: TinyVGG without data augmentation</strong></td> <td>By this stage, we'll have our data ready, let's build a model capable of fitting it. We'll also create some training and testing functions for training and evaluating our model.</td> </tr> <tr> <td><strong>8. Exploring loss curves</strong></td> <td>Loss curves are a great way to see how your model is training/improving over time. They're also a good way to see if your model is <strong>underfitting</strong> or <strong>overfitting</strong>.</td> </tr> <tr> <td><strong>9. Model 1: TinyVGG with data augmentation</strong></td> <td>By now, we've tried a model <em>without</em>, how about we try one <em>with</em> data augmentation?</td> </tr> <tr> <td><strong>10. Compare model results</strong></td> <td>Let's compare our different models' loss curves and see which performed better and discuss some options for improving performance.</td> </tr> <tr> <td><strong>11. Making a prediction on a custom image</strong></td> <td>Our model is trained to on a dataset of pizza, steak and sushi images. In this section we'll cover how to use our trained model to predict on an image <em>outside</em> of our existing dataset.</td> </tr> </tbody> </table> <h2 id=where-can-can-you-get-help>Where can can you get help?</h2> <p>All of the materials for this course <a href=https://github.com/mrdbourke/pytorch-deep-learning>live on GitHub</a>.</p> <p>If you run into trouble, you can ask a question on the course <a href=https://github.com/mrdbourke/pytorch-deep-learning/discussions>GitHub Discussions page</a> there too.</p> <p>And of course, there's the <a href=https://pytorch.org/docs/stable/index.html>PyTorch documentation</a> and <a href=https://discuss.pytorch.org/ >PyTorch developer forums</a>, a very helpful place for all things PyTorch. </p> <h2 id=0-importing-pytorch-and-setting-up-device-agnostic-code>0. Importing PyTorch and setting up device-agnostic code</h2> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>torch</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch</span><span class=w> </span><span class=kn>import</span> <span class=n>nn</span>

<span class=c1># Note: this notebook requires torch &gt;= 1.10.0</span>
<span class=n>torch</span><span class=o>.</span><span class=n>__version__</span>
</code></pre></div> <div class=highlight><pre><span></span><code>&#39;2.2.2&#39;
</code></pre></div> <p>And now let's follow best practice and setup device-agnostic code.</p> <blockquote> <p><strong>Note:</strong> If you're using Google Colab, and you don't have a GPU turned on yet, it's now time to turn one on via <code>Runtime -&gt; Change runtime type -&gt; Hardware accelerator -&gt; GPU</code>. If you do this, your runtime will likely reset and you'll have to run all of the cells above by going <code>Runtime -&gt; Run before</code>.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># Setup device-agnostic code</span>
<span class=n>device</span> <span class=o>=</span> <span class=s2>&quot;cuda&quot;</span> <span class=k>if</span> <span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>is_available</span><span class=p>()</span> <span class=k>else</span> <span class=s2>&quot;cpu&quot;</span>
<span class=n>device</span>
</code></pre></div> <div class=highlight><pre><span></span><code>&#39;cuda&#39;
</code></pre></div> <h2 id=1-get-data>1. Get data</h2> <p>First thing's first we need some data.</p> <p>And like any good cooking show, some data has already been prepared for us.</p> <p>We're going to start small.</p> <p>Because we're not looking to train the biggest model or use the biggest dataset yet.</p> <p>Machine learning is an iterative process, start small, get something working and increase when necessary.</p> <p>The data we're going to be using is a subset of the <a href=https://data.vision.ee.ethz.ch/cvl/datasets_extra/food-101/ >Food101 dataset</a>.</p> <p>Food101 is popular computer vision benchmark as it contains 1000 images of 101 different kinds of foods, totaling 101,000 images (75,750 train and 25,250 test).</p> <p>Can you think of 101 different foods?</p> <p>Can you think of a computer program to classify 101 foods?</p> <p>I can.</p> <p>A machine learning model! </p> <p>Specifically, a PyTorch computer vision model like we covered in <a href=https://www.learnpytorch.io/03_pytorch_computer_vision/ >notebook 03</a>.</p> <p>Instead of 101 food classes though, we're going to start with 3: pizza, steak and sushi.</p> <p>And instead of 1,000 images per class, we're going to start with a random 10% (start small, increase when necessary).</p> <p>If you'd like to see where the data came from you see the following resources: * Original <a href=https://data.vision.ee.ethz.ch/cvl/datasets_extra/food-101/ >Food101 dataset and paper website</a>. * <a href=https://pytorch.org/vision/main/generated/torchvision.datasets.Food101.html><code>torchvision.datasets.Food101</code></a> - the version of the data I downloaded for this notebook. * <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/04_custom_data_creation.ipynb><code>extras/04_custom_data_creation.ipynb</code></a> - a notebook I used to format the Food101 dataset to use for this notebook. * <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/data/pizza_steak_sushi.zip><code>data/pizza_steak_sushi.zip</code></a> - the zip archive of pizza, steak and sushi images from Food101, created with the notebook linked above.</p> <p>Let's write some code to download the formatted data from GitHub.</p> <blockquote> <p><strong>Note:</strong> The dataset we're about to use has been pre-formatted for what we'd like to use it for. However, you'll often have to format your own datasets for whatever problem you're working on. This is a regular practice in the machine learning world.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>requests</span>
<span class=kn>import</span><span class=w> </span><span class=nn>zipfile</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pathlib</span><span class=w> </span><span class=kn>import</span> <span class=n>Path</span>

<span class=c1># Setup path to data folder</span>
<span class=n>data_path</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&quot;data/&quot;</span><span class=p>)</span>
<span class=n>image_path</span> <span class=o>=</span> <span class=n>data_path</span> <span class=o>/</span> <span class=s2>&quot;pizza_steak_sushi&quot;</span>

<span class=c1># If the image folder doesn&#39;t exist, download it and prepare it... </span>
<span class=k>if</span> <span class=n>image_path</span><span class=o>.</span><span class=n>is_dir</span><span class=p>():</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;</span><span class=si>{</span><span class=n>image_path</span><span class=si>}</span><span class=s2> directory exists.&quot;</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Did not find </span><span class=si>{</span><span class=n>image_path</span><span class=si>}</span><span class=s2> directory, creating one...&quot;</span><span class=p>)</span>
    <span class=n>image_path</span><span class=o>.</span><span class=n>mkdir</span><span class=p>(</span><span class=n>parents</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>exist_ok</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=c1># Download pizza, steak, sushi data</span>
    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>data_path</span> <span class=o>/</span> <span class=s2>&quot;pizza_steak_sushi.zip&quot;</span><span class=p>,</span> <span class=s2>&quot;wb&quot;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
        <span class=n>request</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;https://github.com/mrdbourke/pytorch-deep-learning/raw/main/data/pizza_steak_sushi.zip&quot;</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&quot;Downloading pizza, steak, sushi data...&quot;</span><span class=p>)</span>
        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>request</span><span class=o>.</span><span class=n>content</span><span class=p>)</span>

    <span class=c1># Unzip pizza, steak, sushi data</span>
    <span class=k>with</span> <span class=n>zipfile</span><span class=o>.</span><span class=n>ZipFile</span><span class=p>(</span><span class=n>data_path</span> <span class=o>/</span> <span class=s2>&quot;pizza_steak_sushi.zip&quot;</span><span class=p>,</span> <span class=s2>&quot;r&quot;</span><span class=p>)</span> <span class=k>as</span> <span class=n>zip_ref</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&quot;Unzipping pizza, steak, sushi data...&quot;</span><span class=p>)</span> 
        <span class=n>zip_ref</span><span class=o>.</span><span class=n>extractall</span><span class=p>(</span><span class=n>image_path</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Did not find data/pizza_steak_sushi directory, creating one...
Downloading pizza, steak, sushi data...
Unzipping pizza, steak, sushi data...
</code></pre></div> <h2 id=2-become-one-with-the-data-data-preparation>2. Become one with the data (data preparation)</h2> <p>Dataset downloaded!</p> <p>Time to become one with it.</p> <p>This is another important step before building a model.</p> <p>As Abraham Lossfunction said...</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-abraham-lossfunction.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-abraham-lossfunction.png width=800/ alt="tweet by mrdbourke, if I had eight hours to build a machine learning model, I'd spend the first 6 hours preparing my dataset"></a></p> <p><em>Data preparation is paramount. Before building a model, become one with the data. Ask: What am I trying to do here? Source: <a href=https://twitter.com/mrdbourke>@mrdbourke Twitter</a>.</em></p> <p>What's inspecting the data and becoming one with it? </p> <p>Before starting a project or building any kind of model, it's important to know what data you're working with.</p> <p>In our case, we have images of pizza, steak and sushi in standard image classification format.</p> <p>Image classification format contains separate classes of images in seperate directories titled with a particular class name.</p> <p>For example, all images of <code>pizza</code> are contained in the <code>pizza/</code> directory.</p> <p>This format is popular across many different image classification benchmarks, including <a href=https://www.image-net.org/ >ImageNet</a> (of the most popular computer vision benchmark datasets).</p> <p>You can see an example of the storage format below, the images numbers are arbitrary.</p> <div class=highlight><pre><span></span><code>pizza_steak_sushi/ &lt;- overall dataset folder
    train/ &lt;- training images
        pizza/ &lt;- class name as folder name
            image01.jpeg
            image02.jpeg
            ...
        steak/
            image24.jpeg
            image25.jpeg
            ...
        sushi/
            image37.jpeg
            ...
    test/ &lt;- testing images
        pizza/
            image101.jpeg
            image102.jpeg
            ...
        steak/
            image154.jpeg
            image155.jpeg
            ...
        sushi/
            image167.jpeg
            ...
</code></pre></div> <p>The goal will be to <strong>take this data storage structure and turn it into a dataset usable with PyTorch</strong>.</p> <blockquote> <p><strong>Note:</strong> The structure of the data you work with will vary depending on the problem you're working on. But the premise still remains: become one with the data, then find a way to best turn it into a dataset compatible with PyTorch.</p> </blockquote> <p>We can inspect what's in our data directory by writing a small helper function to walk through each of the subdirectories and count the files present.</p> <p>To do so, we'll use Python's in-built <a href=https://docs.python.org/3/library/os.html#os.walk><code>os.walk()</code></a>. </p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>os</span>
<span class=k>def</span><span class=w> </span><span class=nf>walk_through_dir</span><span class=p>(</span><span class=n>dir_path</span><span class=p>):</span>
<span class=w>  </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>  Walks through dir_path returning its contents.</span>
<span class=sd>  Args:</span>
<span class=sd>    dir_path (str or pathlib.Path): target directory</span>

<span class=sd>  Returns:</span>
<span class=sd>    A print out of:</span>
<span class=sd>      number of subdiretories in dir_path</span>
<span class=sd>      number of images (files) in each subdirectory</span>
<span class=sd>      name of each subdirectory</span>
<span class=sd>  &quot;&quot;&quot;</span>
  <span class=k>for</span> <span class=n>dirpath</span><span class=p>,</span> <span class=n>dirnames</span><span class=p>,</span> <span class=n>filenames</span> <span class=ow>in</span> <span class=n>os</span><span class=o>.</span><span class=n>walk</span><span class=p>(</span><span class=n>dir_path</span><span class=p>):</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;There are </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>dirnames</span><span class=p>)</span><span class=si>}</span><span class=s2> directories and </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>filenames</span><span class=p>)</span><span class=si>}</span><span class=s2> images in &#39;</span><span class=si>{</span><span class=n>dirpath</span><span class=si>}</span><span class=s2>&#39;.&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>walk_through_dir</span><span class=p>(</span><span class=n>image_path</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>There are 2 directories and 0 images in &#39;data/pizza_steak_sushi&#39;.
There are 3 directories and 0 images in &#39;data/pizza_steak_sushi/test&#39;.
There are 0 directories and 19 images in &#39;data/pizza_steak_sushi/test/steak&#39;.
There are 0 directories and 25 images in &#39;data/pizza_steak_sushi/test/pizza&#39;.
There are 0 directories and 31 images in &#39;data/pizza_steak_sushi/test/sushi&#39;.
There are 3 directories and 0 images in &#39;data/pizza_steak_sushi/train&#39;.
There are 0 directories and 75 images in &#39;data/pizza_steak_sushi/train/steak&#39;.
There are 0 directories and 78 images in &#39;data/pizza_steak_sushi/train/pizza&#39;.
There are 0 directories and 72 images in &#39;data/pizza_steak_sushi/train/sushi&#39;.
</code></pre></div> <p>Excellent!</p> <p>It looks like we've got about 75 images per training class and 25 images per testing class.</p> <p>That should be enough to get started.</p> <p>Remember, these images are subsets of the original Food101 dataset.</p> <p>You can see how they were created in the <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/04_custom_data_creation.ipynb>data creation notebook</a>.</p> <p>While we're at it, let's setup our training and testing paths.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup train and testing paths</span>
<span class=n>train_dir</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;train&quot;</span>
<span class=n>test_dir</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;test&quot;</span>

<span class=n>train_dir</span><span class=p>,</span> <span class=n>test_dir</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(PosixPath(&#39;data/pizza_steak_sushi/train&#39;),
 PosixPath(&#39;data/pizza_steak_sushi/test&#39;))
</code></pre></div> <h3 id=21-visualize-an-image>2.1 Visualize an image</h3> <p>Okay, we've seen how our directory structure is formatted.</p> <p>Now in the spirit of the data explorer, it's time to <em>visualize, visualize, visualize!</em></p> <p>Let's write some code to: 1. Get all of the image paths using <a href=https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob><code>pathlib.Path.glob()</code></a> to find all of the files ending in <code>.jpg</code>. 2. Pick a random image path using Python's <a href=https://docs.python.org/3/library/random.html#random.choice><code>random.choice()</code></a>. 3. Get the image class name using <a href=https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parent><code>pathlib.Path.parent.stem</code></a>. 4. And since we're working with images, we'll open the random image path using <a href=https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.open><code>PIL.Image.open()</code></a> (PIL stands for Python Image Library). 5. We'll then show the image and print some metadata.</p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>random</span>
<span class=kn>from</span><span class=w> </span><span class=nn>PIL</span><span class=w> </span><span class=kn>import</span> <span class=n>Image</span>

<span class=c1># Set seed</span>
<span class=n>random</span><span class=o>.</span><span class=n>seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span> <span class=c1># &lt;- try changing this and see what happens</span>

<span class=c1># 1. Get all image paths (* means &quot;any combination&quot;)</span>
<span class=n>image_path_list</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>image_path</span><span class=o>.</span><span class=n>glob</span><span class=p>(</span><span class=s2>&quot;*/*/*.jpg&quot;</span><span class=p>))</span>

<span class=c1># 2. Get random image path</span>
<span class=n>random_image_path</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>image_path_list</span><span class=p>)</span>

<span class=c1># 3. Get image class from path name (the image class is the name of the directory where the image is stored)</span>
<span class=n>image_class</span> <span class=o>=</span> <span class=n>random_image_path</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>stem</span>

<span class=c1># 4. Open image</span>
<span class=n>img</span> <span class=o>=</span> <span class=n>Image</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=n>random_image_path</span><span class=p>)</span>

<span class=c1># 5. Print metadata</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Random image path: </span><span class=si>{</span><span class=n>random_image_path</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image class: </span><span class=si>{</span><span class=n>image_class</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image height: </span><span class=si>{</span><span class=n>img</span><span class=o>.</span><span class=n>height</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span> 
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image width: </span><span class=si>{</span><span class=n>img</span><span class=o>.</span><span class=n>width</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=n>img</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Random image path: data/pizza_steak_sushi/test/sushi/2385731.jpg
Image class: sushi
Image height: 512
Image width: 512
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_17_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_17_1.png></a></p> <p>We can do the same with <a href=https://matplotlib.org/3.5.0/api/_as_gen/matplotlib.pyplot.imshow.html><code>matplotlib.pyplot.imshow()</code></a>, except we have to convert the image to a NumPy array first.</p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>numpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>np</span>
<span class=kn>import</span><span class=w> </span><span class=nn>matplotlib.pyplot</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>plt</span>

<span class=c1># Turn the image into an array</span>
<span class=n>img_as_array</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>

<span class=c1># Plot the image with matplotlib</span>
<span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>img_as_array</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image class: </span><span class=si>{</span><span class=n>image_class</span><span class=si>}</span><span class=s2> | Image shape: </span><span class=si>{</span><span class=n>img_as_array</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [height, width, color_channels]&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_19_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_19_0.png></a></p> <h2 id=3-transforming-data>3. Transforming data</h2> <p>Now what if we wanted to load our image data into PyTorch?</p> <p>Before we can use our image data with PyTorch we need to:</p> <ol> <li>Turn it into tensors (numerical representations of our images).</li> <li>Turn it into a <code>torch.utils.data.Dataset</code> and subsequently a <code>torch.utils.data.DataLoader</code>, we'll call these <code>Dataset</code> and <code>DataLoader</code> for short.</li> </ol> <p>There are several different kinds of pre-built datasets and dataset loaders for PyTorch, depending on the problem you're working on. </p> <table> <thead> <tr> <th><strong>Problem space</strong></th> <th><strong>Pre-built Datasets and Functions</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Vision</strong></td> <td><a href=https://pytorch.org/vision/stable/datasets.html><code>torchvision.datasets</code></a></td> </tr> <tr> <td><strong>Audio</strong></td> <td><a href=https://pytorch.org/audio/stable/datasets.html><code>torchaudio.datasets</code></a></td> </tr> <tr> <td><strong>Text</strong></td> <td><a href=https://pytorch.org/text/stable/datasets.html><code>torchtext.datasets</code></a></td> </tr> <tr> <td><strong>Recommendation system</strong></td> <td><a href=https://pytorch.org/torchrec/torchrec.datasets.html><code>torchrec.datasets</code></a></td> </tr> </tbody> </table> <p>Since we're working with a vision problem, we'll be looking at <code>torchvision.datasets</code> for our data loading functions as well as <a href=https://pytorch.org/vision/stable/transforms.html><code>torchvision.transforms</code></a> for preparing our data.</p> <p>Let's import some base libraries.</p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>torch</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch.utils.data</span><span class=w> </span><span class=kn>import</span> <span class=n>DataLoader</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torchvision</span><span class=w> </span><span class=kn>import</span> <span class=n>datasets</span><span class=p>,</span> <span class=n>transforms</span>
</code></pre></div> <div class=highlight><pre><span></span><code>/home/jupyter-trunglph/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html
  from .autonotebook import tqdm as notebook_tqdm
</code></pre></div> <h3 id=31-transforming-data-with-torchvisiontransforms>3.1 Transforming data with <code>torchvision.transforms</code></h3> <p>We've got folders of images but before we can use them with PyTorch, we need to convert them into tensors.</p> <p>One of the ways we can do this is by using the <code>torchvision.transforms</code> module.</p> <p><code>torchvision.transforms</code> contains many pre-built methods for formatting images, turning them into tensors and even manipulating them for <strong>data augmentation</strong> (the practice of altering data to make it harder for a model to learn, we'll see this later on) purposes . </p> <p>To get experience with <code>torchvision.transforms</code>, let's write a series of transform steps that: 1. Resize the images using <a href=https://pytorch.org/vision/stable/generated/torchvision.transforms.Resize.html#torchvision.transforms.Resize><code>transforms.Resize()</code></a> (from about 512x512 to 64x64, the same shape as the images on the <a href=https://poloclub.github.io/cnn-explainer/ >CNN Explainer website</a>). 2. Flip our images randomly on the horizontal using <a href=https://pytorch.org/vision/stable/generated/torchvision.transforms.RandomHorizontalFlip.html#torchvision.transforms.RandomHorizontalFlip><code>transforms.RandomHorizontalFlip()</code></a> (this could be considered a form of data augmentation because it will artificially change our image data). 3. Turn our images from a PIL image to a PyTorch tensor using <a href=https://pytorch.org/vision/stable/generated/torchvision.transforms.ToTensor.html#torchvision.transforms.ToTensor><code>transforms.ToTensor()</code></a>.</p> <p>We can compile all of these steps using <a href=https://pytorch.org/vision/stable/generated/torchvision.transforms.Compose.html#torchvision.transforms.Compose><code>torchvision.transforms.Compose()</code></a>.</p> <div class=highlight><pre><span></span><code><span class=c1># Write transform for image</span>
<span class=n>data_transform</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=c1># Resize the images to 64x64</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>(</span><span class=n>size</span><span class=o>=</span><span class=p>(</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
    <span class=c1># Flip the images randomly on the horizontal</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>RandomHorizontalFlip</span><span class=p>(</span><span class=n>p</span><span class=o>=</span><span class=mf>0.5</span><span class=p>),</span> <span class=c1># p = probability of flip, 0.5 = 50% chance</span>
    <span class=c1># Turn the image into a torch.Tensor</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span> <span class=c1># this also converts all pixel values from 0 to 255 to be between 0.0 and 1.0 </span>
<span class=p>])</span>
</code></pre></div> <p>Now we've got a composition of transforms, let's write a function to try them out on various images.</p> <div class=highlight><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>plot_transformed_images</span><span class=p>(</span><span class=n>image_paths</span><span class=p>,</span> <span class=n>transform</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>seed</span><span class=o>=</span><span class=mi>42</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Plots a series of random images from image_paths.</span>

<span class=sd>    Will open n image paths from image_paths, transform them</span>
<span class=sd>    with transform and plot them side by side.</span>

<span class=sd>    Args:</span>
<span class=sd>        image_paths (list): List of target image paths. </span>
<span class=sd>        transform (PyTorch Transforms): Transforms to apply to images.</span>
<span class=sd>        n (int, optional): Number of images to plot. Defaults to 3.</span>
<span class=sd>        seed (int, optional): Random seed for the random generator. Defaults to 42.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>random</span><span class=o>.</span><span class=n>seed</span><span class=p>(</span><span class=n>seed</span><span class=p>)</span>
    <span class=n>random_image_paths</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=n>image_paths</span><span class=p>,</span> <span class=n>k</span><span class=o>=</span><span class=n>n</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>image_path</span> <span class=ow>in</span> <span class=n>random_image_paths</span><span class=p>:</span>
        <span class=k>with</span> <span class=n>Image</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=n>image_path</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
            <span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
            <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>f</span><span class=p>)</span> 
            <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Original </span><span class=se>\n</span><span class=s2>Size: </span><span class=si>{</span><span class=n>f</span><span class=o>.</span><span class=n>size</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
            <span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s2>&quot;off&quot;</span><span class=p>)</span>

            <span class=c1># Transform and plot image</span>
            <span class=c1># Note: permute() will change shape of image to suit matplotlib </span>
            <span class=c1># (PyTorch default is [C, H, W] but Matplotlib is [H, W, C])</span>
            <span class=n>transformed_image</span> <span class=o>=</span> <span class=n>transform</span><span class=p>(</span><span class=n>f</span><span class=p>)</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> 
            <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>transformed_image</span><span class=p>)</span> 
            <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Transformed </span><span class=se>\n</span><span class=s2>Size: </span><span class=si>{</span><span class=n>transformed_image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
            <span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s2>&quot;off&quot;</span><span class=p>)</span>

            <span class=n>fig</span><span class=o>.</span><span class=n>suptitle</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Class: </span><span class=si>{</span><span class=n>image_path</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>stem</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>16</span><span class=p>)</span>

<span class=n>plot_transformed_images</span><span class=p>(</span><span class=n>image_path_list</span><span class=p>,</span> 
                        <span class=n>transform</span><span class=o>=</span><span class=n>data_transform</span><span class=p>,</span> 
                        <span class=n>n</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_25_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_25_0.png></a></p> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_25_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_25_1.png></a></p> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_25_2.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_25_2.png></a></p> <p>Nice!</p> <p>We've now got a way to convert our images to tensors using <code>torchvision.transforms</code>.</p> <p>We also manipulate their size and orientation if needed (some models prefer images of different sizes and shapes).</p> <p>Generally, the larger the shape of the image, the more information a model can recover.</p> <p>For example, an image of size <code>[256, 256, 3]</code> will have 16x more pixels than an image of size <code>[64, 64, 3]</code> (<code>(256*256*3)/(64*64*3)=16</code>).</p> <p>However, the tradeoff is that more pixels requires more computations.</p> <blockquote> <p><strong>Exercise:</strong> Try commenting out one of the transforms in <code>data_transform</code> and running the plotting function <code>plot_transformed_images()</code> again, what happens?</p> </blockquote> <h2 id=4-option-1-loading-image-data-using-imagefolder>4. Option 1: Loading Image Data Using <a href=https://pytorch.org/vision/stable/generated/torchvision.datasets.ImageFolder.html#torchvision.datasets.ImageFolder><code>ImageFolder</code></a></h2> <p>Alright, time to turn our image data into a <code>Dataset</code> capable of being used with PyTorch.</p> <p>Since our data is in standard image classification format, we can use the class <a href=https://pytorch.org/vision/stable/generated/torchvision.datasets.ImageFolder.html#torchvision.datasets.ImageFolder><code>torchvision.datasets.ImageFolder</code></a>.</p> <p>Where we can pass it the file path of a target image directory as well as a series of transforms we'd like to perform on our images.</p> <p>Let's test it out on our data folders <code>train_dir</code> and <code>test_dir</code> passing in <code>transform=data_transform</code> to turn our images into tensors.</p> <div class=highlight><pre><span></span><code><span class=c1># Use ImageFolder to create dataset(s)</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torchvision</span><span class=w> </span><span class=kn>import</span> <span class=n>datasets</span>
<span class=n>train_data</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>ImageFolder</span><span class=p>(</span><span class=n>root</span><span class=o>=</span><span class=n>train_dir</span><span class=p>,</span> <span class=c1># target folder of images</span>
                                  <span class=n>transform</span><span class=o>=</span><span class=n>data_transform</span><span class=p>,</span> <span class=c1># transforms to perform on data (images)</span>
                                  <span class=n>target_transform</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=c1># transforms to perform on labels (if necessary)</span>

<span class=n>test_data</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>ImageFolder</span><span class=p>(</span><span class=n>root</span><span class=o>=</span><span class=n>test_dir</span><span class=p>,</span> 
                                 <span class=n>transform</span><span class=o>=</span><span class=n>data_transform</span><span class=p>)</span>

<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Train data:</span><span class=se>\n</span><span class=si>{</span><span class=n>train_data</span><span class=si>}</span><span class=se>\n</span><span class=s2>Test data:</span><span class=se>\n</span><span class=si>{</span><span class=n>test_data</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Train data:
Dataset ImageFolder
    Number of datapoints: 225
    Root location: data/pizza_steak_sushi/train
    StandardTransform
Transform: Compose(
               Resize(size=(64, 64), interpolation=bilinear, max_size=None, antialias=True)
               RandomHorizontalFlip(p=0.5)
               ToTensor()
           )
Test data:
Dataset ImageFolder
    Number of datapoints: 75
    Root location: data/pizza_steak_sushi/test
    StandardTransform
Transform: Compose(
               Resize(size=(64, 64), interpolation=bilinear, max_size=None, antialias=True)
               RandomHorizontalFlip(p=0.5)
               ToTensor()
           )
</code></pre></div> <p>Beautiful!</p> <p>It looks like PyTorch has registered our <code>Dataset</code>'s.</p> <p>Let's inspect them by checking out the <code>classes</code> and <code>class_to_idx</code> attributes as well as the lengths of our training and test sets.</p> <div class=highlight><pre><span></span><code><span class=c1># Get class names as a list</span>
<span class=n>class_names</span> <span class=o>=</span> <span class=n>train_data</span><span class=o>.</span><span class=n>classes</span>
<span class=n>class_names</span>
</code></pre></div> <div class=highlight><pre><span></span><code>[&#39;pizza&#39;, &#39;steak&#39;, &#39;sushi&#39;]
</code></pre></div> <div class=highlight><pre><span></span><code><span class=c1># Can also get class names as a dict</span>
<span class=n>class_dict</span> <span class=o>=</span> <span class=n>train_data</span><span class=o>.</span><span class=n>class_to_idx</span>
<span class=n>class_dict</span>
</code></pre></div> <div class=highlight><pre><span></span><code>{&#39;pizza&#39;: 0, &#39;steak&#39;: 1, &#39;sushi&#39;: 2}
</code></pre></div> <div class=highlight><pre><span></span><code><span class=c1># Check the lengths</span>
<span class=nb>len</span><span class=p>(</span><span class=n>train_data</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>test_data</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(225, 75)
</code></pre></div> <p>Nice! Looks like we'll be able to use these to reference for later.</p> <p>How about our images and labels?</p> <p>How do they look?</p> <p>We can index on our <code>train_data</code> and <code>test_data</code> <code>Dataset</code>'s to find samples and their target labels.</p> <div class=highlight><pre><span></span><code><span class=n>img</span><span class=p>,</span> <span class=n>label</span> <span class=o>=</span> <span class=n>train_data</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>train_data</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image tensor:</span><span class=se>\n</span><span class=si>{</span><span class=n>img</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image shape: </span><span class=si>{</span><span class=n>img</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image datatype: </span><span class=si>{</span><span class=n>img</span><span class=o>.</span><span class=n>dtype</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image label: </span><span class=si>{</span><span class=n>label</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Label datatype: </span><span class=si>{</span><span class=nb>type</span><span class=p>(</span><span class=n>label</span><span class=p>)</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Image tensor:
tensor([[[0.1137, 0.1020, 0.0980,  ..., 0.1255, 0.1216, 0.1176],
         [0.1059, 0.0980, 0.0980,  ..., 0.1294, 0.1294, 0.1294],
         [0.1020, 0.0980, 0.0941,  ..., 0.1333, 0.1333, 0.1333],
         ...,
         [0.1098, 0.1098, 0.1255,  ..., 0.1686, 0.1647, 0.1686],
         [0.0902, 0.0941, 0.1098,  ..., 0.1686, 0.1647, 0.1686],
         [0.0863, 0.0863, 0.0980,  ..., 0.1686, 0.1647, 0.1647]],

        [[0.0745, 0.0706, 0.0745,  ..., 0.0588, 0.0588, 0.0588],
         [0.0745, 0.0706, 0.0745,  ..., 0.0627, 0.0627, 0.0627],
         [0.0706, 0.0745, 0.0745,  ..., 0.0706, 0.0706, 0.0706],
         ...,
         [0.1255, 0.1333, 0.1373,  ..., 0.2510, 0.2392, 0.2392],
         [0.1098, 0.1176, 0.1255,  ..., 0.2510, 0.2392, 0.2314],
         [0.1020, 0.1059, 0.1137,  ..., 0.2431, 0.2353, 0.2275]],

        [[0.0941, 0.0902, 0.0902,  ..., 0.0157, 0.0196, 0.0196],
         [0.0902, 0.0863, 0.0902,  ..., 0.0196, 0.0157, 0.0196],
         [0.0902, 0.0902, 0.0902,  ..., 0.0157, 0.0157, 0.0196],
         ...,
         [0.1294, 0.1333, 0.1490,  ..., 0.1961, 0.1882, 0.1843],
         [0.1098, 0.1137, 0.1255,  ..., 0.1922, 0.1843, 0.1804],
         [0.1059, 0.0980, 0.1059,  ..., 0.1882, 0.1804, 0.1765]]])
Image shape: torch.Size([3, 64, 64])
Image datatype: torch.float32
Image label: 0
Label datatype: &lt;class &#39;int&#39;&gt;
</code></pre></div> <p>Our images are now in the form of a tensor (with shape <code>[3, 64, 64]</code>) and the labels are in the form of an integer relating to a specific class (as referenced by the <code>class_to_idx</code> attribute).</p> <p>How about we plot a single image tensor using <code>matplotlib</code>?</p> <p>We'll first have to to permute (rearrange the order of its dimensions) so it's compatible.</p> <p>Right now our image dimensions are in the format <code>CHW</code> (color channels, height, width) but <code>matplotlib</code> prefers <code>HWC</code> (height, width, color channels).</p> <div class=highlight><pre><span></span><code><span class=c1># Rearrange the order of dimensions</span>
<span class=n>img_permute</span> <span class=o>=</span> <span class=n>img</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>

<span class=c1># Print out different shapes (before and after permute)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Original shape: </span><span class=si>{</span><span class=n>img</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [color_channels, height, width]&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image permute shape: </span><span class=si>{</span><span class=n>img_permute</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [height, width, color_channels]&quot;</span><span class=p>)</span>

<span class=c1># Plot the image</span>
<span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>img</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s2>&quot;off&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>class_names</span><span class=p>[</span><span class=n>label</span><span class=p>],</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>14</span><span class=p>);</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Original shape: torch.Size([3, 64, 64]) -&gt; [color_channels, height, width]
Image permute shape: torch.Size([64, 64, 3]) -&gt; [height, width, color_channels]
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_36_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_36_1.png></a></p> <p>Notice the image is now more pixelated (less quality).</p> <p>This is due to it being resized from <code>512x512</code> to <code>64x64</code> pixels.</p> <p>The intuition here is that if you think the image is harder to recognize what's going on, chances are a model will find it harder to understand too.</p> <h3 id=41-turn-loaded-images-into-dataloaders>4.1 Turn loaded images into <code>DataLoader</code>'s</h3> <p>We've got our images as PyTorch <code>Dataset</code>'s but now let's turn them into <code>DataLoader</code>'s.</p> <p>We'll do so using <a href=https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader><code>torch.utils.data.DataLoader</code></a>.</p> <p>Turning our <code>Dataset</code>'s into <code>DataLoader</code>'s makes them iterable so a model can go through learn the relationships between samples and targets (features and labels).</p> <p>To keep things simple, we'll use a <code>batch_size=1</code> and <code>num_workers=1</code>.</p> <p>What's <code>num_workers</code>?</p> <p>Good question.</p> <p>It defines how many subprocesses will be created to load your data.</p> <p>Think of it like this, the higher value <code>num_workers</code> is set to, the more compute power PyTorch will use to load your data.</p> <p>Personally, I usually set it to the total number of CPUs on my machine via Python's <a href=https://docs.python.org/3/library/os.html#os.cpu_count><code>os.cpu_count()</code></a>.</p> <p>This ensures the <code>DataLoader</code> recruits as many cores as possible to load data.</p> <blockquote> <p><strong>Note:</strong> There are more parameters you can get familiar with using <code>torch.utils.data.DataLoader</code> in the <a href=https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader>PyTorch documentation</a>.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># Turn train and test Datasets into DataLoaders</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch.utils.data</span><span class=w> </span><span class=kn>import</span> <span class=n>DataLoader</span>
<span class=n>train_dataloader</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>dataset</span><span class=o>=</span><span class=n>train_data</span><span class=p>,</span> 
                              <span class=n>batch_size</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=c1># how many samples per batch?</span>
                              <span class=n>num_workers</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=c1># how many subprocesses to use for data loading? (higher = more)</span>
                              <span class=n>shuffle</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># shuffle the data?</span>

<span class=n>test_dataloader</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>dataset</span><span class=o>=</span><span class=n>test_data</span><span class=p>,</span> 
                             <span class=n>batch_size</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> 
                             <span class=n>num_workers</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> 
                             <span class=n>shuffle</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=c1># don&#39;t usually need to shuffle testing data</span>

<span class=n>train_dataloader</span><span class=p>,</span> <span class=n>test_dataloader</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(&lt;torch.utils.data.dataloader.DataLoader at 0x7fae875e25b0&gt;,
 &lt;torch.utils.data.dataloader.DataLoader at 0x7fae875e2e50&gt;)
</code></pre></div> <p>Wonderful!</p> <p>Now our data is iterable.</p> <p>Let's try it out and check the shapes.</p> <div class=highlight><pre><span></span><code><span class=n>img</span><span class=p>,</span> <span class=n>label</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=nb>iter</span><span class=p>(</span><span class=n>train_dataloader</span><span class=p>))</span>

<span class=c1># Batch size will now be 1, try changing the batch_size parameter above and see what happens</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image shape: </span><span class=si>{</span><span class=n>img</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, color_channels, height, width]&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Label shape: </span><span class=si>{</span><span class=n>label</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Image shape: torch.Size([1, 3, 64, 64]) -&gt; [batch_size, color_channels, height, width]
Label shape: torch.Size([1])
</code></pre></div> <p>We could now use these <code>DataLoader</code>'s with a training and testing loop to train a model.</p> <p>But before we do, let's look at another option to load images (or almost any other kind of data).</p> <h2 id=5-option-2-loading-image-data-with-a-custom-dataset>5. Option 2: Loading Image Data with a Custom <code>Dataset</code></h2> <p>What if a pre-built <code>Dataset</code> creator like <a href=https://pytorch.org/vision/stable/datasets.html#torchvision.datasets.ImageFolder><code>torchvision.datasets.ImageFolder()</code></a> didn't exist?</p> <p>Or one for your specific problem didn't exist?</p> <p>Well, you could build your own.</p> <p>But wait, what are the pros and cons of creating your own custom way to load <code>Dataset</code>'s?</p> <table> <thead> <tr> <th>Pros of creating a custom <code>Dataset</code></th> <th>Cons of creating a custom <code>Dataset</code></th> </tr> </thead> <tbody> <tr> <td>Can create a <code>Dataset</code> out of almost anything.</td> <td>Even though you <em>could</em> create a <code>Dataset</code> out of almost anything, it doesn't mean it will work.</td> </tr> <tr> <td>Not limited to PyTorch pre-built <code>Dataset</code> functions.</td> <td>Using a custom <code>Dataset</code> often results in writing more code, which could be prone to errors or performance issues.</td> </tr> </tbody> </table> <p>To see this in action, let's work towards replicating <code>torchvision.datasets.ImageFolder()</code> by subclassing <code>torch.utils.data.Dataset</code> (the base class for all <code>Dataset</code>'s in PyTorch). </p> <p>We'll start by importing the modules we need: * Python's <code>os</code> for dealing with directories (our data is stored in directories). * Python's <code>pathlib</code> for dealing with filepaths (each of our images has a unique filepath). * <code>torch</code> for all things PyTorch. * PIL's <code>Image</code> class for loading images. * <code>torch.utils.data.Dataset</code> to subclass and create our own custom <code>Dataset</code>. * <code>torchvision.transforms</code> to turn our images into tensors. * Various types from Python's <code>typing</code> module to add type hints to our code.</p> <blockquote> <p><strong>Note:</strong> You can customize the following steps for your own dataset. The premise remains: write code to load your data in the format you'd like it.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>os</span>
<span class=kn>import</span><span class=w> </span><span class=nn>pathlib</span>
<span class=kn>import</span><span class=w> </span><span class=nn>torch</span>

<span class=kn>from</span><span class=w> </span><span class=nn>PIL</span><span class=w> </span><span class=kn>import</span> <span class=n>Image</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch.utils.data</span><span class=w> </span><span class=kn>import</span> <span class=n>Dataset</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torchvision</span><span class=w> </span><span class=kn>import</span> <span class=n>transforms</span>
<span class=kn>from</span><span class=w> </span><span class=nn>typing</span><span class=w> </span><span class=kn>import</span> <span class=n>Tuple</span><span class=p>,</span> <span class=n>Dict</span><span class=p>,</span> <span class=n>List</span>
</code></pre></div> <p>Remember how our instances of <code>torchvision.datasets.ImageFolder()</code> allowed us to use the <code>classes</code> and <code>class_to_idx</code> attributes?</p> <div class=highlight><pre><span></span><code><span class=c1># Instance of torchvision.datasets.ImageFolder()</span>
<span class=n>train_data</span><span class=o>.</span><span class=n>classes</span><span class=p>,</span> <span class=n>train_data</span><span class=o>.</span><span class=n>class_to_idx</span>
</code></pre></div> <div class=highlight><pre><span></span><code>([&#39;pizza&#39;, &#39;steak&#39;, &#39;sushi&#39;], {&#39;pizza&#39;: 0, &#39;steak&#39;: 1, &#39;sushi&#39;: 2})
</code></pre></div> <h3 id=51-creating-a-helper-function-to-get-class-names>5.1 Creating a helper function to get class names</h3> <p>Let's write a helper function capable of creating a list of class names and a dictionary of class names and their indexes given a directory path.</p> <p>To do so, we'll: 1. Get the class names using <code>os.scandir()</code> to traverse a target directory (ideally the directory is in standard image classification format). 2. Raise an error if the class names aren't found (if this happens, there might be something wrong with the directory structure). 3. Turn the class names into a dictionary of numerical labels, one for each class.</p> <p>Let's see a small example of step 1 before we write the full function.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup path for target directory</span>
<span class=n>target_directory</span> <span class=o>=</span> <span class=n>train_dir</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Target directory: </span><span class=si>{</span><span class=n>target_directory</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># Get the class names from the target directory</span>
<span class=n>class_names_found</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>([</span><span class=n>entry</span><span class=o>.</span><span class=n>name</span> <span class=k>for</span> <span class=n>entry</span> <span class=ow>in</span> <span class=nb>list</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>scandir</span><span class=p>(</span><span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;train&quot;</span><span class=p>))])</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Class names found: </span><span class=si>{</span><span class=n>class_names_found</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Target directory: data/pizza_steak_sushi/train
Class names found: [&#39;pizza&#39;, &#39;steak&#39;, &#39;sushi&#39;]
</code></pre></div> <p>Excellent!</p> <p>How about we turn it into a full function?</p> <div class=highlight><pre><span></span><code><span class=c1># Make function to find classes in target directory</span>
<span class=k>def</span><span class=w> </span><span class=nf>find_classes</span><span class=p>(</span><span class=n>directory</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Finds the class folder names in a target directory.</span>

<span class=sd>    Assumes target directory is in standard image classification format.</span>

<span class=sd>    Args:</span>
<span class=sd>        directory (str): target directory to load classnames from.</span>

<span class=sd>    Returns:</span>
<span class=sd>        Tuple[List[str], Dict[str, int]]: (list_of_class_names, dict(class_name: idx...))</span>

<span class=sd>    Example:</span>
<span class=sd>        find_classes(&quot;food_images/train&quot;)</span>
<span class=sd>        &gt;&gt;&gt; ([&quot;class_1&quot;, &quot;class_2&quot;], {&quot;class_1&quot;: 0, ...})</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># 1. Get the class names by scanning the target directory</span>
    <span class=n>classes</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>entry</span><span class=o>.</span><span class=n>name</span> <span class=k>for</span> <span class=n>entry</span> <span class=ow>in</span> <span class=n>os</span><span class=o>.</span><span class=n>scandir</span><span class=p>(</span><span class=n>directory</span><span class=p>)</span> <span class=k>if</span> <span class=n>entry</span><span class=o>.</span><span class=n>is_dir</span><span class=p>())</span>

    <span class=c1># 2. Raise an error if class names not found</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>classes</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>FileNotFoundError</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Couldn&#39;t find any classes in </span><span class=si>{</span><span class=n>directory</span><span class=si>}</span><span class=s2>.&quot;</span><span class=p>)</span>

    <span class=c1># 3. Create a dictionary of index labels (computers prefer numerical rather than string labels)</span>
    <span class=n>class_to_idx</span> <span class=o>=</span> <span class=p>{</span><span class=n>cls_name</span><span class=p>:</span> <span class=n>i</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>cls_name</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>classes</span><span class=p>)}</span>
    <span class=k>return</span> <span class=n>classes</span><span class=p>,</span> <span class=n>class_to_idx</span>
</code></pre></div> <p>Looking good!</p> <p>Now let's test out our <code>find_classes()</code> function.</p> <div class=highlight><pre><span></span><code><span class=n>find_classes</span><span class=p>(</span><span class=n>train_dir</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>([&#39;pizza&#39;, &#39;steak&#39;, &#39;sushi&#39;], {&#39;pizza&#39;: 0, &#39;steak&#39;: 1, &#39;sushi&#39;: 2})
</code></pre></div> <p>Woohoo! Looking good!</p> <h3 id=52-create-a-custom-dataset-to-replicate-imagefolder>5.2 Create a custom <code>Dataset</code> to replicate <code>ImageFolder</code></h3> <p>Now we're ready to build our own custom <code>Dataset</code>.</p> <p>We'll build one to replicate the functionality of <code>torchvision.datasets.ImageFolder()</code>. </p> <p>This will be good practice, plus, it'll reveal a few of the required steps to make your own custom <code>Dataset</code>.</p> <p>It'll be a fair bit of a code... but nothing we can't handle!</p> <p>Let's break it down: 1. Subclass <code>torch.utils.data.Dataset</code>. 2. Initialize our subclass with a <code>targ_dir</code> parameter (the target data directory) and <code>transform</code> parameter (so we have the option to transform our data if needed). 3. Create several attributes for <code>paths</code> (the paths of our target images), <code>transform</code> (the transforms we might like to use, this can be <code>None</code>), <code>classes</code> and <code>class_to_idx</code> (from our <code>find_classes()</code> function). 4. Create a function to load images from file and return them, this could be using <code>PIL</code> or <a href=https://pytorch.org/vision/stable/io.html#image><code>torchvision.io</code></a> (for input/output of vision data). 5. Overwrite the <code>__len__</code> method of <code>torch.utils.data.Dataset</code> to return the number of samples in the <code>Dataset</code>, this is recommended but not required. This is so you can call <code>len(Dataset)</code>. 6. Overwrite the <code>__getitem__</code> method of <code>torch.utils.data.Dataset</code> to return a single sample from the <code>Dataset</code>, this is required.</p> <p>Let's do it!</p> <div class=highlight><pre><span></span><code><span class=c1># Write a custom dataset class (inherits from torch.utils.data.Dataset)</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch.utils.data</span><span class=w> </span><span class=kn>import</span> <span class=n>Dataset</span>

<span class=c1># 1. Subclass torch.utils.data.Dataset</span>
<span class=k>class</span><span class=w> </span><span class=nc>ImageFolderCustom</span><span class=p>(</span><span class=n>Dataset</span><span class=p>):</span>

    <span class=c1># 2. Initialize with a targ_dir and transform (optional) parameter</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>targ_dir</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>transform</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>

        <span class=c1># 3. Create class attributes</span>
        <span class=c1># Get all image paths</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>paths</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>pathlib</span><span class=o>.</span><span class=n>Path</span><span class=p>(</span><span class=n>targ_dir</span><span class=p>)</span><span class=o>.</span><span class=n>glob</span><span class=p>(</span><span class=s2>&quot;*/*.jpg&quot;</span><span class=p>))</span> <span class=c1># note: you&#39;d have to update this if you&#39;ve got .png&#39;s or .jpeg&#39;s</span>
        <span class=c1># Setup transforms</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>transform</span> <span class=o>=</span> <span class=n>transform</span>
        <span class=c1># Create classes and class_to_idx attributes</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>classes</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>class_to_idx</span> <span class=o>=</span> <span class=n>find_classes</span><span class=p>(</span><span class=n>targ_dir</span><span class=p>)</span>

    <span class=c1># 4. Make function to load images</span>
    <span class=k>def</span><span class=w> </span><span class=nf>load_image</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>index</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Image</span><span class=o>.</span><span class=n>Image</span><span class=p>:</span>
        <span class=s2>&quot;Opens an image via a path and returns it.&quot;</span>
        <span class=n>image_path</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>paths</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
        <span class=k>return</span> <span class=n>Image</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=n>image_path</span><span class=p>)</span> 

    <span class=c1># 5. Overwrite the __len__() method (optional but recommended for subclasses of torch.utils.data.Dataset)</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__len__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
        <span class=s2>&quot;Returns the total number of samples.&quot;</span>
        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>paths</span><span class=p>)</span>

    <span class=c1># 6. Overwrite the __getitem__() method (required for subclasses of torch.utils.data.Dataset)</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>index</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Tuple</span><span class=p>[</span><span class=n>torch</span><span class=o>.</span><span class=n>Tensor</span><span class=p>,</span> <span class=nb>int</span><span class=p>]:</span>
        <span class=s2>&quot;Returns one sample of data, data and label (X, y).&quot;</span>
        <span class=n>img</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>load_image</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
        <span class=n>class_name</span>  <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>paths</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>name</span> <span class=c1># expects path in data_folder/class_name/image.jpeg</span>
        <span class=n>class_idx</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>class_to_idx</span><span class=p>[</span><span class=n>class_name</span><span class=p>]</span>

        <span class=c1># Transform if necessary</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>transform</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>img</span><span class=p>),</span> <span class=n>class_idx</span> <span class=c1># return data, label (X, y)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>img</span><span class=p>,</span> <span class=n>class_idx</span> <span class=c1># return data, label (X, y)</span>
</code></pre></div> <p>Woah! A whole bunch of code to load in our images.</p> <p>This is one of the downsides of creating your own custom <code>Dataset</code>'s.</p> <p>However, now we've written it once, we could move it into a <code>.py</code> file such as <code>data_loader.py</code> along with some other helpful data functions and reuse it later on. </p> <p>Before we test out our new <code>ImageFolderCustom</code> class, let's create some transforms to prepare our images.</p> <div class=highlight><pre><span></span><code><span class=c1># Augment train data</span>
<span class=n>train_transforms</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>RandomHorizontalFlip</span><span class=p>(</span><span class=n>p</span><span class=o>=</span><span class=mf>0.5</span><span class=p>),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span>
<span class=p>])</span>

<span class=c1># Don&#39;t augment test data, only reshape</span>
<span class=n>test_transforms</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span>
<span class=p>])</span>
</code></pre></div> <p>Now comes the moment of truth!</p> <p>Let's turn our training images (contained in <code>train_dir</code>) and our testing images (contained in <code>test_dir</code>) into <code>Dataset</code>'s using our own <code>ImageFolderCustom</code> class.</p> <div class=highlight><pre><span></span><code><span class=n>train_data_custom</span> <span class=o>=</span> <span class=n>ImageFolderCustom</span><span class=p>(</span><span class=n>targ_dir</span><span class=o>=</span><span class=n>train_dir</span><span class=p>,</span> 
                                      <span class=n>transform</span><span class=o>=</span><span class=n>train_transforms</span><span class=p>)</span>
<span class=n>test_data_custom</span> <span class=o>=</span> <span class=n>ImageFolderCustom</span><span class=p>(</span><span class=n>targ_dir</span><span class=o>=</span><span class=n>test_dir</span><span class=p>,</span> 
                                     <span class=n>transform</span><span class=o>=</span><span class=n>test_transforms</span><span class=p>)</span>
<span class=n>train_data_custom</span><span class=p>,</span> <span class=n>test_data_custom</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(&lt;__main__.ImageFolderCustom at 0x7fae87600a30&gt;,
 &lt;__main__.ImageFolderCustom at 0x7fae876007f0&gt;)
</code></pre></div> <p>Hmm... no errors, did it work?</p> <p>Let's try calling <code>len()</code> on our new <code>Dataset</code>'s and find the <code>classes</code> and <code>class_to_idx</code> attributes.</p> <div class=highlight><pre><span></span><code><span class=nb>len</span><span class=p>(</span><span class=n>train_data_custom</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>test_data_custom</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(225, 75)
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>train_data_custom</span><span class=o>.</span><span class=n>classes</span>
</code></pre></div> <div class=highlight><pre><span></span><code>[&#39;pizza&#39;, &#39;steak&#39;, &#39;sushi&#39;]
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>train_data_custom</span><span class=o>.</span><span class=n>class_to_idx</span>
</code></pre></div> <div class=highlight><pre><span></span><code>{&#39;pizza&#39;: 0, &#39;steak&#39;: 1, &#39;sushi&#39;: 2}
</code></pre></div> <p><code>len(test_data_custom) == len(test_data)</code> and <code>len(test_data_custom) == len(test_data)</code> Yes!!!</p> <p>It looks like it worked.</p> <p>We could check for equality with the <code>Dataset</code>'s made by the <code>torchvision.datasets.ImageFolder()</code> class too. </p> <div class=highlight><pre><span></span><code><span class=c1># Check for equality amongst our custom Dataset and ImageFolder Dataset</span>
<span class=nb>print</span><span class=p>((</span><span class=nb>len</span><span class=p>(</span><span class=n>train_data_custom</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>train_data</span><span class=p>))</span> <span class=o>&amp;</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>test_data_custom</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>test_data</span><span class=p>)))</span>
<span class=nb>print</span><span class=p>(</span><span class=n>train_data_custom</span><span class=o>.</span><span class=n>classes</span> <span class=o>==</span> <span class=n>train_data</span><span class=o>.</span><span class=n>classes</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>train_data_custom</span><span class=o>.</span><span class=n>class_to_idx</span> <span class=o>==</span> <span class=n>train_data</span><span class=o>.</span><span class=n>class_to_idx</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>True
True
True
</code></pre></div> <p>Ho ho!</p> <p>Look at us go!</p> <p>Three <code>True</code>'s!</p> <p>You can't get much better than that.</p> <p>How about we take it up a notch and plot some random images to test our <code>__getitem__</code> override? </p> <h3 id=53-create-a-function-to-display-random-images>5.3 Create a function to display random images</h3> <p>You know what time it is!</p> <p>Time to put on our data explorer's hat and <em>visualize, visualize, visualize!</em></p> <p>Let's create a helper function called <code>display_random_images()</code> that helps us visualize images in our <code>Dataset'</code>s.</p> <p>Specifically, it'll: 1. Take in a <code>Dataset</code> and a number of other parameters such as <code>classes</code> (the names of our target classes), the number of images to display (<code>n</code>) and a random seed. 2. To prevent the display getting out of hand, we'll cap <code>n</code> at 10 images. 3. Set the random seed for reproducible plots (if <code>seed</code> is set). 4. Get a list of random sample indexes (we can use Python's <code>random.sample()</code> for this) to plot. 5. Setup a <code>matplotlib</code> plot. 6. Loop through the random sample indexes found in step 4 and plot them with <code>matplotlib</code>. 7. Make sure the sample images are of shape <code>HWC</code> (height, width, color channels) so we can plot them.</p> <div class=highlight><pre><span></span><code><span class=c1># 1. Take in a Dataset as well as a list of class names</span>
<span class=k>def</span><span class=w> </span><span class=nf>display_random_images</span><span class=p>(</span><span class=n>dataset</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>utils</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>dataset</span><span class=o>.</span><span class=n>Dataset</span><span class=p>,</span>
                          <span class=n>classes</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span>
                          <span class=n>n</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span>
                          <span class=n>display_shape</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
                          <span class=n>seed</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=kc>None</span><span class=p>):</span>

    <span class=c1># 2. Adjust display if n too high</span>
    <span class=k>if</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=mi>10</span><span class=p>:</span>
        <span class=n>n</span> <span class=o>=</span> <span class=mi>10</span>
        <span class=n>display_shape</span> <span class=o>=</span> <span class=kc>False</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;For display purposes, n shouldn&#39;t be larger than 10, setting to 10 and removing shape display.&quot;</span><span class=p>)</span>

    <span class=c1># 3. Set random seed</span>
    <span class=k>if</span> <span class=n>seed</span><span class=p>:</span>
        <span class=n>random</span><span class=o>.</span><span class=n>seed</span><span class=p>(</span><span class=n>seed</span><span class=p>)</span>

    <span class=c1># 4. Get random sample indexes</span>
    <span class=n>random_samples_idx</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)),</span> <span class=n>k</span><span class=o>=</span><span class=n>n</span><span class=p>)</span>

    <span class=c1># 5. Setup plot</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>16</span><span class=p>,</span> <span class=mi>8</span><span class=p>))</span>

    <span class=c1># 6. Loop through samples and display random samples </span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>targ_sample</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>random_samples_idx</span><span class=p>):</span>
        <span class=n>targ_image</span><span class=p>,</span> <span class=n>targ_label</span> <span class=o>=</span> <span class=n>dataset</span><span class=p>[</span><span class=n>targ_sample</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>dataset</span><span class=p>[</span><span class=n>targ_sample</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>

        <span class=c1># 7. Adjust image tensor shape for plotting: [color_channels, height, width] -&gt; [color_channels, height, width]</span>
        <span class=n>targ_image_adjust</span> <span class=o>=</span> <span class=n>targ_image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>

        <span class=c1># Plot adjusted samples</span>
        <span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>targ_image_adjust</span><span class=p>)</span>
        <span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s2>&quot;off&quot;</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>classes</span><span class=p>:</span>
            <span class=n>title</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&quot;class: </span><span class=si>{</span><span class=n>classes</span><span class=p>[</span><span class=n>targ_label</span><span class=p>]</span><span class=si>}</span><span class=s2>&quot;</span>
            <span class=k>if</span> <span class=n>display_shape</span><span class=p>:</span>
                <span class=n>title</span> <span class=o>=</span> <span class=n>title</span> <span class=o>+</span> <span class=sa>f</span><span class=s2>&quot;</span><span class=se>\n</span><span class=s2>shape: </span><span class=si>{</span><span class=n>targ_image_adjust</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span>
        <span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>title</span><span class=p>)</span>
</code></pre></div> <p>What a good looking function!</p> <p>Let's test it out first with the <code>Dataset</code> we created with <code>torchvision.datasets.ImageFolder()</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># Display random images from ImageFolder created Dataset</span>
<span class=n>display_random_images</span><span class=p>(</span><span class=n>train_data</span><span class=p>,</span> 
                      <span class=n>n</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span> 
                      <span class=n>classes</span><span class=o>=</span><span class=n>class_names</span><span class=p>,</span>
                      <span class=n>seed</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_70_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_70_0.png></a></p> <p>And now with the <code>Dataset</code> we created with our own <code>ImageFolderCustom</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># Display random images from ImageFolderCustom Dataset</span>
<span class=n>display_random_images</span><span class=p>(</span><span class=n>train_data_custom</span><span class=p>,</span> 
                      <span class=n>n</span><span class=o>=</span><span class=mi>12</span><span class=p>,</span> 
                      <span class=n>classes</span><span class=o>=</span><span class=n>class_names</span><span class=p>,</span>
                      <span class=n>seed</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=c1># Try setting the seed for reproducible images</span>
</code></pre></div> <div class=highlight><pre><span></span><code>For display purposes, n shouldn&#39;t be larger than 10, setting to 10 and removing shape display.
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_72_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_72_1.png></a></p> <p>Nice!!!</p> <p>Looks like our <code>ImageFolderCustom</code> is working just as we'd like it to.</p> <h3 id=54-turn-custom-loaded-images-into-dataloaders>5.4 Turn custom loaded images into <code>DataLoader</code>'s</h3> <p>We've got a way to turn our raw images into <code>Dataset</code>'s (features mapped to labels or <code>X</code>'s mapped to <code>y</code>'s) through our <code>ImageFolderCustom</code> class.</p> <p>Now how could we turn our custom <code>Dataset</code>'s into <code>DataLoader</code>'s?</p> <p>If you guessed by using <code>torch.utils.data.DataLoader()</code>, you'd be right!</p> <p>Because our custom <code>Dataset</code>'s subclass <code>torch.utils.data.Dataset</code>, we can use them directly with <code>torch.utils.data.DataLoader()</code>.</p> <p>And we can do using very similar steps to before except this time we'll be using our custom created <code>Dataset</code>'s.</p> <div class=highlight><pre><span></span><code><span class=c1># Turn train and test custom Dataset&#39;s into DataLoader&#39;s</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch.utils.data</span><span class=w> </span><span class=kn>import</span> <span class=n>DataLoader</span>
<span class=n>train_dataloader_custom</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>dataset</span><span class=o>=</span><span class=n>train_data_custom</span><span class=p>,</span> <span class=c1># use custom created train Dataset</span>
                                     <span class=n>batch_size</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=c1># how many samples per batch?</span>
                                     <span class=n>num_workers</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=c1># how many subprocesses to use for data loading? (higher = more)</span>
                                     <span class=n>shuffle</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># shuffle the data?</span>

<span class=n>test_dataloader_custom</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>dataset</span><span class=o>=</span><span class=n>test_data_custom</span><span class=p>,</span> <span class=c1># use custom created test Dataset</span>
                                    <span class=n>batch_size</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> 
                                    <span class=n>num_workers</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> 
                                    <span class=n>shuffle</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=c1># don&#39;t usually need to shuffle testing data</span>

<span class=n>train_dataloader_custom</span><span class=p>,</span> <span class=n>test_dataloader_custom</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(&lt;torch.utils.data.dataloader.DataLoader at 0x7fae86b5b940&gt;,
 &lt;torch.utils.data.dataloader.DataLoader at 0x7fae86b5bfa0&gt;)
</code></pre></div> <p>Do the shapes of the samples look the same?</p> <div class=highlight><pre><span></span><code><span class=c1># Get image and label from custom DataLoader</span>
<span class=n>img_custom</span><span class=p>,</span> <span class=n>label_custom</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=nb>iter</span><span class=p>(</span><span class=n>train_dataloader_custom</span><span class=p>))</span>

<span class=c1># Batch size will now be 1, try changing the batch_size parameter above and see what happens</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image shape: </span><span class=si>{</span><span class=n>img_custom</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, color_channels, height, width]&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Label shape: </span><span class=si>{</span><span class=n>label_custom</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Image shape: torch.Size([1, 3, 64, 64]) -&gt; [batch_size, color_channels, height, width]
Label shape: torch.Size([1])
</code></pre></div> <p>They sure do!</p> <p>Let's now take a lot at some other forms of data transforms.</p> <h2 id=6-other-forms-of-transforms-data-augmentation>6. Other forms of transforms (data augmentation)</h2> <p>We've seen a couple of transforms on our data already but there's plenty more.</p> <p>You can see them all in the <a href=https://pytorch.org/vision/stable/transforms.html><code>torchvision.transforms</code> documentation</a>.</p> <p>The purpose of tranforms is to alter your images in some way.</p> <p>That may be turning your images into a tensor (as we've seen before).</p> <p>Or cropping it or randomly erasing a portion or randomly rotating them.</p> <p>Doing this kinds of transforms is often referred to as <strong>data augmentation</strong>.</p> <p><strong>Data augmentation</strong> is the process of altering your data in such a way that you <em>artificially</em> increase the diversity of your training set.</p> <p>Training a model on this <em>artificially</em> altered dataset hopefully results in a model that is capable of better <em>generalization</em> (the patterns it learns are more robust to future unseen examples).</p> <p>You can see many different examples of data augmentation performed on images using <code>torchvision.transforms</code> in PyTorch's <a href=https://pytorch.org/vision/stable/auto_examples/plot_transforms.html#illustration-of-transforms>Illustration of Transforms example</a>.</p> <p>But let's try one out ourselves.</p> <p>Machine learning is all about harnessing the power of randomness and research shows that random transforms (like <a href=https://pytorch.org/vision/stable/auto_examples/plot_transforms.html#randaugment><code>transforms.RandAugment()</code></a> and <a href=https://pytorch.org/vision/stable/auto_examples/plot_transforms.html#trivialaugmentwide><code>transforms.TrivialAugmentWide()</code></a>) generally perform better than hand-picked transforms.</p> <p>The idea behind <a href=https://arxiv.org/abs/2103.10158>TrivialAugment</a> is... well, trivial. </p> <p>You have a set of transforms and you randomly pick a number of them to perform on an image and at a random magnitude between a given range (a higher magnitude means more instense).</p> <p>The PyTorch team even <a href=https://pytorch.org/blog/how-to-train-state-of-the-art-models-using-torchvision-latest-primitives/#break-down-of-key-accuracy-improvements>used TrivialAugment it to train their latest state-of-the-art vision models</a>.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-trivial-augment-being-using-in-PyTorch-resize.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt="trivial augment data augmentation being used for PyTorch state of the art training" src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-trivial-augment-being-using-in-PyTorch-resize.png></a></p> <p><em>TrivialAugment was one of the ingredients used in a recent state of the art training upgrade to various PyTorch vision models.</em></p> <p>How about we test it out on some of our own images?</p> <p>The main parameter to pay attention to in <code>transforms.TrivialAugmentWide()</code> is <code>num_magnitude_bins=31</code>.</p> <p>It defines how much of a range an intensity value will be picked to apply a certain transform, <code>0</code> being no range and <code>31</code> being maximum range (highest chance for highest intensity). </p> <p>We can incorporate <code>transforms.TrivialAugmentWide()</code> into <code>transforms.Compose()</code>.</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>torchvision</span><span class=w> </span><span class=kn>import</span> <span class=n>transforms</span>

<span class=n>train_transforms</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>224</span><span class=p>,</span> <span class=mi>224</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>TrivialAugmentWide</span><span class=p>(</span><span class=n>num_magnitude_bins</span><span class=o>=</span><span class=mi>31</span><span class=p>),</span> <span class=c1># how intense </span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span> <span class=c1># use ToTensor() last to get everything between 0 &amp; 1</span>
<span class=p>])</span>

<span class=c1># Don&#39;t need to perform augmentation on the test data</span>
<span class=n>test_transforms</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>224</span><span class=p>,</span> <span class=mi>224</span><span class=p>)),</span> 
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span>
<span class=p>])</span>
</code></pre></div> <blockquote> <p><strong>Note:</strong> You usually don't perform data augmentation on the test set. The idea of data augmentation is to to <em>artificially</em> increase the diversity of the training set to better predict on the testing set. </p> <p>However, you do need to make sure your test set images are transformed to tensors. We size the test images to the same size as our training images too, however, inference can be done on different size images if necessary (though this may alter performance).</p> </blockquote> <p>Beautiful, now we've got a training transform (with data augmentation) and test transform (without data augmentation).</p> <p>Let's test our data augmentation out!</p> <div class=highlight><pre><span></span><code><span class=c1># Get all image paths</span>
<span class=n>image_path_list</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>image_path</span><span class=o>.</span><span class=n>glob</span><span class=p>(</span><span class=s2>&quot;*/*/*.jpg&quot;</span><span class=p>))</span>

<span class=c1># Plot random images</span>
<span class=n>plot_transformed_images</span><span class=p>(</span>
    <span class=n>image_paths</span><span class=o>=</span><span class=n>image_path_list</span><span class=p>,</span>
    <span class=n>transform</span><span class=o>=</span><span class=n>train_transforms</span><span class=p>,</span>
    <span class=n>n</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
    <span class=n>seed</span><span class=o>=</span><span class=kc>None</span>
<span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_82_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_82_0.png></a></p> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_82_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_82_1.png></a></p> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_82_2.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_82_2.png></a></p> <p>Try running the cell above a few times and seeing how the original image changes as it goes through the transform.</p> <h2 id=7-model-0-tinyvgg-without-data-augmentation>7. Model 0: TinyVGG without data augmentation</h2> <p>Alright, we've seen how to turn our data from images in folders to transformed tensors.</p> <p>Now let's construct a computer vision model to see if we can classify if an image is of pizza, steak or sushi.</p> <p>To begin, we'll start with a simple transform, only resizing the images to <code>(64, 64)</code> and turning them into tensors.</p> <h3 id=71-creating-transforms-and-loading-data-for-model-0>7.1 Creating transforms and loading data for Model 0</h3> <div class=highlight><pre><span></span><code><span class=c1># Create simple transform</span>
<span class=n>simple_transform</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span> 
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>(),</span>
<span class=p>])</span>
</code></pre></div> <p>Excellent, now we've got a simple transform, let's: 1. Load the data, turning each of our training and test folders first into a <code>Dataset</code> with <code>torchvision.datasets.ImageFolder()</code> 2. Then into a <code>DataLoader</code> using <code>torch.utils.data.DataLoader()</code>. * We'll set the <code>batch_size=32</code> and <code>num_workers</code> to as many CPUs on our machine (this will depend on what machine you're using).</p> <div class=highlight><pre><span></span><code><span class=c1># 1. Load and transform data</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torchvision</span><span class=w> </span><span class=kn>import</span> <span class=n>datasets</span>
<span class=n>train_data_simple</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>ImageFolder</span><span class=p>(</span><span class=n>root</span><span class=o>=</span><span class=n>train_dir</span><span class=p>,</span> <span class=n>transform</span><span class=o>=</span><span class=n>simple_transform</span><span class=p>)</span>
<span class=n>test_data_simple</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>ImageFolder</span><span class=p>(</span><span class=n>root</span><span class=o>=</span><span class=n>test_dir</span><span class=p>,</span> <span class=n>transform</span><span class=o>=</span><span class=n>simple_transform</span><span class=p>)</span>

<span class=c1># 2. Turn data into DataLoaders</span>
<span class=kn>import</span><span class=w> </span><span class=nn>os</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torch.utils.data</span><span class=w> </span><span class=kn>import</span> <span class=n>DataLoader</span>

<span class=c1># Setup batch size and number of workers </span>
<span class=n>BATCH_SIZE</span> <span class=o>=</span> <span class=mi>32</span>
<span class=n>NUM_WORKERS</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>cpu_count</span><span class=p>()</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Creating DataLoader&#39;s with batch size </span><span class=si>{</span><span class=n>BATCH_SIZE</span><span class=si>}</span><span class=s2> and </span><span class=si>{</span><span class=n>NUM_WORKERS</span><span class=si>}</span><span class=s2> workers.&quot;</span><span class=p>)</span>

<span class=c1># Create DataLoader&#39;s</span>
<span class=n>train_dataloader_simple</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>train_data_simple</span><span class=p>,</span> 
                                     <span class=n>batch_size</span><span class=o>=</span><span class=n>BATCH_SIZE</span><span class=p>,</span> 
                                     <span class=n>shuffle</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> 
                                     <span class=n>num_workers</span><span class=o>=</span><span class=n>NUM_WORKERS</span><span class=p>)</span>

<span class=n>test_dataloader_simple</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>test_data_simple</span><span class=p>,</span> 
                                    <span class=n>batch_size</span><span class=o>=</span><span class=n>BATCH_SIZE</span><span class=p>,</span> 
                                    <span class=n>shuffle</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> 
                                    <span class=n>num_workers</span><span class=o>=</span><span class=n>NUM_WORKERS</span><span class=p>)</span>

<span class=n>train_dataloader_simple</span><span class=p>,</span> <span class=n>test_dataloader_simple</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Creating DataLoader&#39;s with batch size 32 and 32 workers.





(&lt;torch.utils.data.dataloader.DataLoader at 0x7fae877121f0&gt;,
 &lt;torch.utils.data.dataloader.DataLoader at 0x7fae875dbb80&gt;)
</code></pre></div> <p><code>DataLoader</code>'s created! </p> <p>Let's build a model.</p> <h3 id=72-create-tinyvgg-model-class>7.2 Create TinyVGG model class</h3> <p>In <a href=https://www.learnpytorch.io/03_pytorch_computer_vision/#7-model-2-building-a-convolutional-neural-network-cnn>notebook 03</a>, we used the TinyVGG model from the <a href=https://poloclub.github.io/cnn-explainer/ >CNN Explainer website</a>.</p> <p>Let's recreate the same model, except this time we'll be using color images instead of grayscale (<code>in_channels=3</code> instead of <code>in_channels=1</code> for RGB pixels). </p> <div class=highlight><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>TinyVGG</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Model architecture copying TinyVGG from: </span>
<span class=sd>    https://poloclub.github.io/cnn-explainer/</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>input_shape</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>hidden_units</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>output_shape</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>conv_block_1</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Conv2d</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=n>input_shape</span><span class=p>,</span> 
                      <span class=n>out_channels</span><span class=o>=</span><span class=n>hidden_units</span><span class=p>,</span> 
                      <span class=n>kernel_size</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=c1># how big is the square that&#39;s going over the image?</span>
                      <span class=n>stride</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=c1># default</span>
                      <span class=n>padding</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span> <span class=c1># options = &quot;valid&quot; (no padding) or &quot;same&quot; (output has same shape as input) or int for specific number </span>
            <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Conv2d</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=n>hidden_units</span><span class=p>,</span> 
                      <span class=n>out_channels</span><span class=o>=</span><span class=n>hidden_units</span><span class=p>,</span>
                      <span class=n>kernel_size</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
                      <span class=n>stride</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span>
                      <span class=n>padding</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>MaxPool2d</span><span class=p>(</span><span class=n>kernel_size</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span>
                         <span class=n>stride</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span> <span class=c1># default stride value is same as kernel_size</span>
        <span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>conv_block_2</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Conv2d</span><span class=p>(</span><span class=n>hidden_units</span><span class=p>,</span> <span class=n>hidden_units</span><span class=p>,</span> <span class=n>kernel_size</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>padding</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Conv2d</span><span class=p>(</span><span class=n>hidden_units</span><span class=p>,</span> <span class=n>hidden_units</span><span class=p>,</span> <span class=n>kernel_size</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>padding</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>MaxPool2d</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
        <span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>classifier</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Flatten</span><span class=p>(),</span>
            <span class=c1># Where did this in_features shape come from? </span>
            <span class=c1># It&#39;s because each layer of our network compresses and changes the shape of our inputs data.</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>in_features</span><span class=o>=</span><span class=n>hidden_units</span><span class=o>*</span><span class=mi>16</span><span class=o>*</span><span class=mi>16</span><span class=p>,</span>
                      <span class=n>out_features</span><span class=o>=</span><span class=n>output_shape</span><span class=p>)</span>
        <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>Tensor</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>conv_block_1</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=c1># print(x.shape)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>conv_block_2</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=c1># print(x.shape)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>classifier</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=c1># print(x.shape)</span>
        <span class=k>return</span> <span class=n>x</span>
        <span class=c1># return self.classifier(self.conv_block_2(self.conv_block_1(x))) # &lt;- leverage the benefits of operator fusion</span>

<span class=n>torch</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
<span class=n>model_0</span> <span class=o>=</span> <span class=n>TinyVGG</span><span class=p>(</span><span class=n>input_shape</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=c1># number of color channels (3 for RGB) </span>
                  <span class=n>hidden_units</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> 
                  <span class=n>output_shape</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>train_data</span><span class=o>.</span><span class=n>classes</span><span class=p>))</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>
<span class=n>model_0</span>
</code></pre></div> <div class=highlight><pre><span></span><code>TinyVGG(
  (conv_block_1): Sequential(
    (0): Conv2d(3, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU()
    (2): Conv2d(10, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU()
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (conv_block_2): Sequential(
    (0): Conv2d(10, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU()
    (2): Conv2d(10, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU()
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (classifier): Sequential(
    (0): Flatten(start_dim=1, end_dim=-1)
    (1): Linear(in_features=2560, out_features=3, bias=True)
  )
)
</code></pre></div> <blockquote> <p><strong>Note:</strong> One of the ways to speed up deep learning models computing on a GPU is to leverage <strong>operator fusion</strong>.</p> <p>This means in the <code>forward()</code> method in our model above, instead of calling a layer block and reassigning <code>x</code> every time, we call each block in succession (see the final line of the <code>forward()</code> method in the model above for an example).</p> <p>This saves the time spent reassigning <code>x</code> (memory heavy) and focuses on only computing on <code>x</code>.</p> <p>See <a href=https://horace.io/brrr_intro.html><em>Making Deep Learning Go Brrrr From First Principles</em></a> by Horace He for more ways on how to speed up machine learning models.</p> </blockquote> <p>Now that's a nice looking model!</p> <p>How about we test it out with a forward pass on a single image?</p> <h3 id=73-try-a-forward-pass-on-a-single-image-to-test-the-model>7.3 Try a forward pass on a single image (to test the model)</h3> <p>A good way to test a model is to do a forward pass on a single piece of data.</p> <p>It's also handy way to test the input and output shapes of our different layers.</p> <p>To do a forward pass on a single image, let's: 1. Get a batch of images and labels from the <code>DataLoader</code>. 2. Get a single image from the batch and <code>unsqueeze()</code> the image so it has a batch size of <code>1</code> (so its shape fits the model). 3. Perform inference on a single image (making sure to send the image to the target <code>device</code>). 4. Print out what's happening and convert the model's raw output logits to prediction probabilities with <code>torch.softmax()</code> (since we're working with multi-class data) and convert the prediction probabilities to prediction labels with <code>torch.argmax()</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># 1. Get a batch of images and labels from the DataLoader</span>
<span class=n>img_batch</span><span class=p>,</span> <span class=n>label_batch</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=nb>iter</span><span class=p>(</span><span class=n>train_dataloader_simple</span><span class=p>))</span>

<span class=c1># 2. Get a single image from the batch and unsqueeze the image so its shape fits the model</span>
<span class=n>img_single</span><span class=p>,</span> <span class=n>label_single</span> <span class=o>=</span> <span class=n>img_batch</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=n>dim</span><span class=o>=</span><span class=mi>0</span><span class=p>),</span> <span class=n>label_batch</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Single image shape: </span><span class=si>{</span><span class=n>img_single</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 3. Perform a forward pass on a single image</span>
<span class=n>model_0</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
<span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
    <span class=n>pred</span> <span class=o>=</span> <span class=n>model_0</span><span class=p>(</span><span class=n>img_single</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>))</span>

<span class=c1># 4. Print out what&#39;s happening and convert model logits -&gt; pred probs -&gt; pred label</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output logits:</span><span class=se>\n</span><span class=si>{</span><span class=n>pred</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output prediction probabilities:</span><span class=se>\n</span><span class=si>{</span><span class=n>torch</span><span class=o>.</span><span class=n>softmax</span><span class=p>(</span><span class=n>pred</span><span class=p>,</span><span class=w> </span><span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output prediction label:</span><span class=se>\n</span><span class=si>{</span><span class=n>torch</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>softmax</span><span class=p>(</span><span class=n>pred</span><span class=p>,</span><span class=w> </span><span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Actual label:</span><span class=se>\n</span><span class=si>{</span><span class=n>label_single</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Single image shape: torch.Size([1, 3, 64, 64])

Output logits:
tensor([[0.0578, 0.0634, 0.0351]], device=&#39;cuda:0&#39;)

Output prediction probabilities:
tensor([[0.3352, 0.3371, 0.3277]], device=&#39;cuda:0&#39;)

Output prediction label:
tensor([1], device=&#39;cuda:0&#39;)

Actual label:
2
</code></pre></div> <p>Wonderful, it looks like our model is outputting what we'd expect it to output.</p> <p>You can run the cell above a few times and each time have a different image be predicted on.</p> <p>And you'll probably notice the predictions are often wrong.</p> <p>This is to be expected because the model hasn't been trained yet and it's essentially guessing using random weights.</p> <h3 id=74-use-torchinfo-to-get-an-idea-of-the-shapes-going-through-our-model>7.4 Use <code>torchinfo</code> to get an idea of the shapes going through our model</h3> <p>Printing out our model with <code>print(model)</code> gives us an idea of what's going on with our model.</p> <p>And we can print out the shapes of our data throughout the <code>forward()</code> method.</p> <p>However, a helpful way to get information from our model is to use <a href=https://github.com/TylerYep/torchinfo><code>torchinfo</code></a>.</p> <p><code>torchinfo</code> comes with a <code>summary()</code> method that takes a PyTorch model as well as an <code>input_shape</code> and returns what happens as a tensor moves through your model.</p> <blockquote> <p><strong>Note:</strong> If you're using Google Colab, you'll need to install <code>torchinfo</code>.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># Install torchinfo if it&#39;s not available, import it if it is</span>
<span class=k>try</span><span class=p>:</span> 
    <span class=kn>import</span><span class=w> </span><span class=nn>torchinfo</span>
<span class=k>except</span><span class=p>:</span>
    <span class=err>!</span><span class=n>pip</span> <span class=n>install</span> <span class=n>torchinfo</span>
    <span class=kn>import</span><span class=w> </span><span class=nn>torchinfo</span>

<span class=kn>from</span><span class=w> </span><span class=nn>torchinfo</span><span class=w> </span><span class=kn>import</span> <span class=n>summary</span>
<span class=n>summary</span><span class=p>(</span><span class=n>model_0</span><span class=p>,</span> <span class=n>input_size</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>])</span> <span class=c1># do a test pass through of an example input size </span>
</code></pre></div> <div class=highlight><pre><span></span><code>Collecting torchinfo
  Downloading torchinfo-1.8.0-py3-none-any.whl.metadata (21 kB)
Downloading torchinfo-1.8.0-py3-none-any.whl (23 kB)
Installing collected packages: torchinfo
Successfully installed torchinfo-1.8.0





==========================================================================================
Layer (type:depth-idx)                   Output Shape              Param #
==========================================================================================
TinyVGG                                  [1, 3]                    --
├─Sequential: 1-1                        [1, 10, 32, 32]           --
│    └─Conv2d: 2-1                       [1, 10, 64, 64]           280
│    └─ReLU: 2-2                         [1, 10, 64, 64]           --
│    └─Conv2d: 2-3                       [1, 10, 64, 64]           910
│    └─ReLU: 2-4                         [1, 10, 64, 64]           --
│    └─MaxPool2d: 2-5                    [1, 10, 32, 32]           --
├─Sequential: 1-2                        [1, 10, 16, 16]           --
│    └─Conv2d: 2-6                       [1, 10, 32, 32]           910
│    └─ReLU: 2-7                         [1, 10, 32, 32]           --
│    └─Conv2d: 2-8                       [1, 10, 32, 32]           910
│    └─ReLU: 2-9                         [1, 10, 32, 32]           --
│    └─MaxPool2d: 2-10                   [1, 10, 16, 16]           --
├─Sequential: 1-3                        [1, 3]                    --
│    └─Flatten: 2-11                     [1, 2560]                 --
│    └─Linear: 2-12                      [1, 3]                    7,683
==========================================================================================
Total params: 10,693
Trainable params: 10,693
Non-trainable params: 0
Total mult-adds (M): 6.75
==========================================================================================
Input size (MB): 0.05
Forward/backward pass size (MB): 0.82
Params size (MB): 0.04
Estimated Total Size (MB): 0.91
==========================================================================================
</code></pre></div> <p>Nice! </p> <p>The output of <code>torchinfo.summary()</code> gives us a whole bunch of information about our model.</p> <p>Such as <code>Total params</code>, the total number of parameters in our model, the <code>Estimated Total Size (MB)</code> which is the size of our model.</p> <p>You can also see the change in input and output shapes as data of a certain <code>input_size</code> moves through our model.</p> <p>Right now, our parameter numbers and total model size is low. </p> <p>This because we're starting with a small model.</p> <p>And if we need to increase its size later, we can.</p> <h3 id=75-create-train-test-loop-functions>7.5 Create train &amp; test loop functions</h3> <p>We've got data and we've got a model.</p> <p>Now let's make some training and test loop functions to train our model on the training data and evaluate our model on the testing data.</p> <p>And to make sure we can use these the training and testing loops again, we'll functionize them.</p> <p>Specifically, we're going to make three functions: 1. <code>train_step()</code> - takes in a model, a <code>DataLoader</code>, a loss function and an optimizer and trains the model on the <code>DataLoader</code>. 2. <code>test_step()</code> - takes in a model, a <code>DataLoader</code> and a loss function and evaluates the model on the <code>DataLoader</code>. 3. <code>train()</code> - performs 1. and 2. together for a given number of epochs and returns a results dictionary.</p> <blockquote> <p><strong>Note:</strong> We covered the steps in a PyTorch opimization loop in <a href=https://www.learnpytorch.io/01_pytorch_workflow/#creating-an-optimization-loop-in-pytorch>notebook 01</a>, as well as the<a href=https://youtu.be/Nutpusq_AFw> Unofficial PyTorch Optimization Loop Song</a> and we've built similar functions in <a href=https://www.learnpytorch.io/03_pytorch_computer_vision/#62-functionizing-training-and-test-loops>notebook 03</a>.</p> </blockquote> <p>Let's start by building <code>train_step()</code>.</p> <p>Because we're dealing with batches in the <code>DataLoader</code>'s, we'll accumulate the model loss and accuracy values during training (by adding them up for each batch) and then adjust them at the end before we return them.</p> <div class=highlight><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>train_step</span><span class=p>(</span><span class=n>model</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>,</span> 
               <span class=n>dataloader</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>utils</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>DataLoader</span><span class=p>,</span> 
               <span class=n>loss_fn</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>,</span> 
               <span class=n>optimizer</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>optim</span><span class=o>.</span><span class=n>Optimizer</span><span class=p>):</span>
    <span class=c1># Put model in train mode</span>
    <span class=n>model</span><span class=o>.</span><span class=n>train</span><span class=p>()</span>

    <span class=c1># Setup train loss and train accuracy values</span>
    <span class=n>train_loss</span><span class=p>,</span> <span class=n>train_acc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>

    <span class=c1># Loop through data loader data batches</span>
    <span class=k>for</span> <span class=n>batch</span><span class=p>,</span> <span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>dataloader</span><span class=p>):</span>
        <span class=c1># Send data to target device</span>
        <span class=n>X</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=n>X</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>),</span> <span class=n>y</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>

        <span class=c1># 1. Forward pass</span>
        <span class=n>y_pred</span> <span class=o>=</span> <span class=n>model</span><span class=p>(</span><span class=n>X</span><span class=p>)</span>

        <span class=c1># 2. Calculate  and accumulate loss</span>
        <span class=n>loss</span> <span class=o>=</span> <span class=n>loss_fn</span><span class=p>(</span><span class=n>y_pred</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
        <span class=n>train_loss</span> <span class=o>+=</span> <span class=n>loss</span><span class=o>.</span><span class=n>item</span><span class=p>()</span> 

        <span class=c1># 3. Optimizer zero grad</span>
        <span class=n>optimizer</span><span class=o>.</span><span class=n>zero_grad</span><span class=p>()</span>

        <span class=c1># 4. Loss backward</span>
        <span class=n>loss</span><span class=o>.</span><span class=n>backward</span><span class=p>()</span>

        <span class=c1># 5. Optimizer step</span>
        <span class=n>optimizer</span><span class=o>.</span><span class=n>step</span><span class=p>()</span>

        <span class=c1># Calculate and accumulate accuracy metric across all batches</span>
        <span class=n>y_pred_class</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>softmax</span><span class=p>(</span><span class=n>y_pred</span><span class=p>,</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>train_acc</span> <span class=o>+=</span> <span class=p>(</span><span class=n>y_pred_class</span> <span class=o>==</span> <span class=n>y</span><span class=p>)</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span><span class=o>.</span><span class=n>item</span><span class=p>()</span><span class=o>/</span><span class=nb>len</span><span class=p>(</span><span class=n>y_pred</span><span class=p>)</span>

    <span class=c1># Adjust metrics to get average loss and accuracy per batch </span>
    <span class=n>train_loss</span> <span class=o>=</span> <span class=n>train_loss</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>dataloader</span><span class=p>)</span>
    <span class=n>train_acc</span> <span class=o>=</span> <span class=n>train_acc</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>dataloader</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>train_loss</span><span class=p>,</span> <span class=n>train_acc</span>
</code></pre></div> <p>Woohoo! <code>train_step()</code> function done.</p> <p>Now let's do the same for the <code>test_step()</code> function.</p> <p>The main difference here will be the <code>test_step()</code> won't take in an optimizer and therefore won't perform gradient descent.</p> <p>But since we'll be doing inference, we'll make sure to turn on the <code>torch.inference_mode()</code> context manager for making predictions.</p> <div class=highlight><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>test_step</span><span class=p>(</span><span class=n>model</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>,</span> 
              <span class=n>dataloader</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>utils</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>DataLoader</span><span class=p>,</span> 
              <span class=n>loss_fn</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
    <span class=c1># Put model in eval mode</span>
    <span class=n>model</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span> 

    <span class=c1># Setup test loss and test accuracy values</span>
    <span class=n>test_loss</span><span class=p>,</span> <span class=n>test_acc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>

    <span class=c1># Turn on inference context manager</span>
    <span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
        <span class=c1># Loop through DataLoader batches</span>
        <span class=k>for</span> <span class=n>batch</span><span class=p>,</span> <span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>dataloader</span><span class=p>):</span>
            <span class=c1># Send data to target device</span>
            <span class=n>X</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=n>X</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>),</span> <span class=n>y</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>

            <span class=c1># 1. Forward pass</span>
            <span class=n>test_pred_logits</span> <span class=o>=</span> <span class=n>model</span><span class=p>(</span><span class=n>X</span><span class=p>)</span>

            <span class=c1># 2. Calculate and accumulate loss</span>
            <span class=n>loss</span> <span class=o>=</span> <span class=n>loss_fn</span><span class=p>(</span><span class=n>test_pred_logits</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
            <span class=n>test_loss</span> <span class=o>+=</span> <span class=n>loss</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>

            <span class=c1># Calculate and accumulate accuracy</span>
            <span class=n>test_pred_labels</span> <span class=o>=</span> <span class=n>test_pred_logits</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=n>test_acc</span> <span class=o>+=</span> <span class=p>((</span><span class=n>test_pred_labels</span> <span class=o>==</span> <span class=n>y</span><span class=p>)</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span><span class=o>.</span><span class=n>item</span><span class=p>()</span><span class=o>/</span><span class=nb>len</span><span class=p>(</span><span class=n>test_pred_labels</span><span class=p>))</span>

    <span class=c1># Adjust metrics to get average loss and accuracy per batch </span>
    <span class=n>test_loss</span> <span class=o>=</span> <span class=n>test_loss</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>dataloader</span><span class=p>)</span>
    <span class=n>test_acc</span> <span class=o>=</span> <span class=n>test_acc</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=n>dataloader</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>test_loss</span><span class=p>,</span> <span class=n>test_acc</span>
</code></pre></div> <p>Excellent!</p> <h3 id=76-creating-a-train-function-to-combine-train_step-and-test_step>7.6 Creating a <code>train()</code> function to combine <code>train_step()</code> and <code>test_step()</code></h3> <p>Now we need a way to put our <code>train_step()</code> and <code>test_step()</code> functions together.</p> <p>To do so, we'll package them up in a <code>train()</code> function.</p> <p>This function will train the model as well as evaluate it.</p> <p>Specificially, it'll: 1. Take in a model, a <code>DataLoader</code> for training and test sets, an optimizer, a loss function and how many epochs to perform each train and test step for. 2. Create an empty results dictionary for <code>train_loss</code>, <code>train_acc</code>, <code>test_loss</code> and <code>test_acc</code> values (we can fill this up as training goes on). 3. Loop through the training and test step functions for a number of epochs. 4. Print out what's happening at the end of each epoch. 5. Update the empty results dictionary with the updated metrics each epoch. 6. Return the filled</p> <p>To keep track of the number of epochs we've been through, let's import <code>tqdm</code> from <code>tqdm.auto</code> (<a href=https://github.com/tqdm/tqdm><code>tqdm</code></a> is one of the most popular progress bar libraries for Python and <code>tqdm.auto</code> automatically decides what kind of progress bar is best for your computing environment, e.g. Jupyter Notebook vs. Python script).</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>tqdm.auto</span><span class=w> </span><span class=kn>import</span> <span class=n>tqdm</span>

<span class=c1># 1. Take in various parameters required for training and test steps</span>
<span class=k>def</span><span class=w> </span><span class=nf>train</span><span class=p>(</span><span class=n>model</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>,</span> 
          <span class=n>train_dataloader</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>utils</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>DataLoader</span><span class=p>,</span> 
          <span class=n>test_dataloader</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>utils</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>DataLoader</span><span class=p>,</span> 
          <span class=n>optimizer</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>optim</span><span class=o>.</span><span class=n>Optimizer</span><span class=p>,</span>
          <span class=n>loss_fn</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>CrossEntropyLoss</span><span class=p>(),</span>
          <span class=n>epochs</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>5</span><span class=p>):</span>

    <span class=c1># 2. Create empty results dictionary</span>
    <span class=n>results</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&quot;train_loss&quot;</span><span class=p>:</span> <span class=p>[],</span>
        <span class=s2>&quot;train_acc&quot;</span><span class=p>:</span> <span class=p>[],</span>
        <span class=s2>&quot;test_loss&quot;</span><span class=p>:</span> <span class=p>[],</span>
        <span class=s2>&quot;test_acc&quot;</span><span class=p>:</span> <span class=p>[]</span>
    <span class=p>}</span>

    <span class=c1># 3. Loop through training and testing steps for a number of epochs</span>
    <span class=k>for</span> <span class=n>epoch</span> <span class=ow>in</span> <span class=n>tqdm</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>epochs</span><span class=p>)):</span>
        <span class=n>train_loss</span><span class=p>,</span> <span class=n>train_acc</span> <span class=o>=</span> <span class=n>train_step</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>model</span><span class=p>,</span>
                                           <span class=n>dataloader</span><span class=o>=</span><span class=n>train_dataloader</span><span class=p>,</span>
                                           <span class=n>loss_fn</span><span class=o>=</span><span class=n>loss_fn</span><span class=p>,</span>
                                           <span class=n>optimizer</span><span class=o>=</span><span class=n>optimizer</span><span class=p>)</span>
        <span class=n>test_loss</span><span class=p>,</span> <span class=n>test_acc</span> <span class=o>=</span> <span class=n>test_step</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>model</span><span class=p>,</span>
            <span class=n>dataloader</span><span class=o>=</span><span class=n>test_dataloader</span><span class=p>,</span>
            <span class=n>loss_fn</span><span class=o>=</span><span class=n>loss_fn</span><span class=p>)</span>

        <span class=c1># 4. Print out what&#39;s happening</span>
        <span class=nb>print</span><span class=p>(</span>
            <span class=sa>f</span><span class=s2>&quot;Epoch: </span><span class=si>{</span><span class=n>epoch</span><span class=o>+</span><span class=mi>1</span><span class=si>}</span><span class=s2> | &quot;</span>
            <span class=sa>f</span><span class=s2>&quot;train_loss: </span><span class=si>{</span><span class=n>train_loss</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> | &quot;</span>
            <span class=sa>f</span><span class=s2>&quot;train_acc: </span><span class=si>{</span><span class=n>train_acc</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> | &quot;</span>
            <span class=sa>f</span><span class=s2>&quot;test_loss: </span><span class=si>{</span><span class=n>test_loss</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> | &quot;</span>
            <span class=sa>f</span><span class=s2>&quot;test_acc: </span><span class=si>{</span><span class=n>test_acc</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2>&quot;</span>
        <span class=p>)</span>

        <span class=c1># 5. Update results dictionary</span>
        <span class=n>results</span><span class=p>[</span><span class=s2>&quot;train_loss&quot;</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>train_loss</span><span class=p>)</span>
        <span class=n>results</span><span class=p>[</span><span class=s2>&quot;train_acc&quot;</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>train_acc</span><span class=p>)</span>
        <span class=n>results</span><span class=p>[</span><span class=s2>&quot;test_loss&quot;</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>test_loss</span><span class=p>)</span>
        <span class=n>results</span><span class=p>[</span><span class=s2>&quot;test_acc&quot;</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>test_acc</span><span class=p>)</span>

    <span class=c1># 6. Return the filled results at the end of the epochs</span>
    <span class=k>return</span> <span class=n>results</span>
</code></pre></div> <h3 id=77-train-and-evaluate-model-0>7.7 Train and Evaluate Model 0</h3> <p>Alright, alright, alright we've got all of the ingredients we need to train and evaluate our model.</p> <p>Time to put our <code>TinyVGG</code> model, <code>DataLoader</code>'s and <code>train()</code> function together to see if we can build a model capable of discerning between pizza, steak and sushi!</p> <p>Let's recreate <code>model_0</code> (we don't need to but we will for completeness) then call our <code>train()</code> function passing in the necessary parameters.</p> <p>To keep our experiments quick, we'll train our model for <strong>5 epochs</strong> (though you could increase this if you want).</p> <p>As for an <strong>optimizer</strong> and <strong>loss function</strong>, we'll use <code>torch.nn.CrossEntropyLoss()</code> (since we're working with multi-class classification data) and <code>torch.optim.Adam()</code> with a learning rate of <code>1e-3</code> respecitvely.</p> <p>To see how long things take, we'll import Python's <a href=https://docs.python.org/3/library/timeit.html#timeit.default_timer><code>timeit.default_timer()</code></a> method to calculate the training time.</p> <div class=highlight><pre><span></span><code><span class=c1># Set random seeds</span>
<span class=n>torch</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span> 
<span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>

<span class=c1># Set number of epochs</span>
<span class=n>NUM_EPOCHS</span> <span class=o>=</span> <span class=mi>5</span>

<span class=c1># Recreate an instance of TinyVGG</span>
<span class=n>model_0</span> <span class=o>=</span> <span class=n>TinyVGG</span><span class=p>(</span><span class=n>input_shape</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=c1># number of color channels (3 for RGB) </span>
                  <span class=n>hidden_units</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> 
                  <span class=n>output_shape</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>train_data</span><span class=o>.</span><span class=n>classes</span><span class=p>))</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>

<span class=c1># Setup loss function and optimizer</span>
<span class=n>loss_fn</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>CrossEntropyLoss</span><span class=p>()</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>optim</span><span class=o>.</span><span class=n>Adam</span><span class=p>(</span><span class=n>params</span><span class=o>=</span><span class=n>model_0</span><span class=o>.</span><span class=n>parameters</span><span class=p>(),</span> <span class=n>lr</span><span class=o>=</span><span class=mf>0.001</span><span class=p>)</span>

<span class=c1># Start the timer</span>
<span class=kn>from</span><span class=w> </span><span class=nn>timeit</span><span class=w> </span><span class=kn>import</span> <span class=n>default_timer</span> <span class=k>as</span> <span class=n>timer</span> 
<span class=n>start_time</span> <span class=o>=</span> <span class=n>timer</span><span class=p>()</span>

<span class=c1># Train model_0 </span>
<span class=n>model_0_results</span> <span class=o>=</span> <span class=n>train</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>model_0</span><span class=p>,</span> 
                        <span class=n>train_dataloader</span><span class=o>=</span><span class=n>train_dataloader_simple</span><span class=p>,</span>
                        <span class=n>test_dataloader</span><span class=o>=</span><span class=n>test_dataloader_simple</span><span class=p>,</span>
                        <span class=n>optimizer</span><span class=o>=</span><span class=n>optimizer</span><span class=p>,</span>
                        <span class=n>loss_fn</span><span class=o>=</span><span class=n>loss_fn</span><span class=p>,</span> 
                        <span class=n>epochs</span><span class=o>=</span><span class=n>NUM_EPOCHS</span><span class=p>)</span>

<span class=c1># End the timer and print out how long it took</span>
<span class=n>end_time</span> <span class=o>=</span> <span class=n>timer</span><span class=p>()</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Total training time: </span><span class=si>{</span><span class=n>end_time</span><span class=o>-</span><span class=n>start_time</span><span class=si>:</span><span class=s2>.3f</span><span class=si>}</span><span class=s2> seconds&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code> 20%|██        | 1/5 [00:01&lt;00:06,  1.59s/it]

Epoch: 1 | train_loss: 1.1078 | train_acc: 0.2578 | test_loss: 1.1362 | test_acc: 0.2604


 40%|████      | 2/5 [00:03&lt;00:04,  1.56s/it]

Epoch: 2 | train_loss: 1.0846 | train_acc: 0.4258 | test_loss: 1.1622 | test_acc: 0.1979


 60%|██████    | 3/5 [00:04&lt;00:03,  1.57s/it]

Epoch: 3 | train_loss: 1.1153 | train_acc: 0.2930 | test_loss: 1.1695 | test_acc: 0.1979


 80%|████████  | 4/5 [00:06&lt;00:01,  1.53s/it]

Epoch: 4 | train_loss: 1.0990 | train_acc: 0.2891 | test_loss: 1.1341 | test_acc: 0.1979


100%|██████████| 5/5 [00:07&lt;00:00,  1.53s/it]

Epoch: 5 | train_loss: 1.0989 | train_acc: 0.2930 | test_loss: 1.1434 | test_acc: 0.1979
Total training time: 7.671 seconds
</code></pre></div> <p>Hmm...</p> <p>It looks like our model performed pretty poorly.</p> <p>But that's okay for now, we'll keep persevering.</p> <p>What are some ways you could potentially improve it?</p> <blockquote> <p><strong>Note:</strong> Check out the <a href=https://www.learnpytorch.io/02_pytorch_classification/#5-improving-a-model-from-a-model-perspective><em>Improving a model (from a model perspective)</em> section in notebook 02</a> for ideas on improving our TinyVGG model.</p> </blockquote> <h3 id=78-plot-the-loss-curves-of-model-0>7.8 Plot the loss curves of Model 0</h3> <p>From the print outs of our <code>model_0</code> training, it didn't look like it did too well.</p> <p>But we can further evaluate it by plotting the model's <strong>loss curves</strong>. </p> <p><strong>Loss curves</strong> show the model's results over time.</p> <p>And they're a great way to see how your model performs on different datasets (e.g. training and test).</p> <p>Let's create a function to plot the values in our <code>model_0_results</code> dictionary.</p> <div class=highlight><pre><span></span><code><span class=c1># Check the model_0_results keys</span>
<span class=n>model_0_results</span><span class=o>.</span><span class=n>keys</span><span class=p>()</span>
</code></pre></div> <div class=highlight><pre><span></span><code>dict_keys([&#39;train_loss&#39;, &#39;train_acc&#39;, &#39;test_loss&#39;, &#39;test_acc&#39;])
</code></pre></div> <p>We'll need to extract each of these keys and turn them into a plot.</p> <div class=highlight><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>plot_loss_curves</span><span class=p>(</span><span class=n>results</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]]):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Plots training curves of a results dictionary.</span>

<span class=sd>    Args:</span>
<span class=sd>        results (dict): dictionary containing list of values, e.g.</span>
<span class=sd>            {&quot;train_loss&quot;: [...],</span>
<span class=sd>             &quot;train_acc&quot;: [...],</span>
<span class=sd>             &quot;test_loss&quot;: [...],</span>
<span class=sd>             &quot;test_acc&quot;: [...]}</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># Get the loss values of the results dictionary (training and test)</span>
    <span class=n>loss</span> <span class=o>=</span> <span class=n>results</span><span class=p>[</span><span class=s1>&#39;train_loss&#39;</span><span class=p>]</span>
    <span class=n>test_loss</span> <span class=o>=</span> <span class=n>results</span><span class=p>[</span><span class=s1>&#39;test_loss&#39;</span><span class=p>]</span>

    <span class=c1># Get the accuracy values of the results dictionary (training and test)</span>
    <span class=n>accuracy</span> <span class=o>=</span> <span class=n>results</span><span class=p>[</span><span class=s1>&#39;train_acc&#39;</span><span class=p>]</span>
    <span class=n>test_accuracy</span> <span class=o>=</span> <span class=n>results</span><span class=p>[</span><span class=s1>&#39;test_acc&#39;</span><span class=p>]</span>

    <span class=c1># Figure out how many epochs there were</span>
    <span class=n>epochs</span> <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>results</span><span class=p>[</span><span class=s1>&#39;train_loss&#39;</span><span class=p>]))</span>

    <span class=c1># Setup a plot </span>
    <span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>15</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>

    <span class=c1># Plot loss</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>loss</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;train_loss&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>test_loss</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;test_loss&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s1>&#39;Loss&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s1>&#39;Epochs&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>

    <span class=c1># Plot accuracy</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>accuracy</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;train_accuracy&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>test_accuracy</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;test_accuracy&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s1>&#39;Accuracy&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s1>&#39;Epochs&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>();</span>
</code></pre></div> <p>Okay, let's test our <code>plot_loss_curves()</code> function out.</p> <div class=highlight><pre><span></span><code><span class=n>plot_loss_curves</span><span class=p>(</span><span class=n>model_0_results</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_114_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_114_0.png></a></p> <p>Woah.</p> <p>Looks like things are all over the place...</p> <p>But we kind of knew that because our model's print out results during training didn't show much promise.</p> <p>You could try training the model for longer and see what happens when you plot a loss curve over a longer time horizon.</p> <h2 id=8-what-should-an-ideal-loss-curve-look-like>8. What should an ideal loss curve look like?</h2> <p>Looking at training and test loss curves is a great way to see if your model is <strong>overfitting</strong>.</p> <p>An overfitting model is one that performs better (often by a considerable margin) on the training set than the validation/test set.</p> <p>If your training loss is far lower than your test loss, your model is <strong>overfitting</strong>.</p> <p>As in, it's learning the patterns in the training too well and those patterns aren't generalizing to the test data.</p> <p>The other side is when your training and test loss are not as low as you'd like, this is considered <strong>underfitting</strong>.</p> <p>The ideal position for a training and test loss curve is for them to line up closely with each other.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-loss-curves-overfitting-underfitting-ideal.jpg data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-loss-curves-overfitting-underfitting-ideal.jpg alt="different training and test loss curves illustrating overfitting, underfitting and the ideal loss curves" width=800></a></p> <p><em>Left: If your training and test loss curves aren't as low as you'd like, this is considered </em><em>underfitting</em><em>. </em>Middle:<em> When your test/validation loss is higher than your training loss this is considered </em><em>overfitting</em><em>. </em>Right:<em> The ideal scenario is when your training and test loss curves line up over time. This means your model is generalizing well. There are more combinations and different things loss curves can do, for more on these, see Google's <a href=https://developers.google.com/machine-learning/testing-debugging/metrics/interpretic>Interpreting Loss Curves guide</a>.</em></p> <h3 id=81-how-to-deal-with-overfitting>8.1 How to deal with overfitting</h3> <p>Since the main problem with overfitting is that you're model is fitting the training data <em>too well</em>, you'll want to use techniques to "reign it in".</p> <p>A common technique of preventing overfitting is known as <a href=https://ml-cheatsheet.readthedocs.io/en/latest/regularization.html><strong>regularization</strong></a>.</p> <p>I like to think of this as "making our models more regular", as in, capable of fitting <em>more</em> kinds of data.</p> <p>Let's discuss a few methods to prevent overfitting.</p> <table> <thead> <tr> <th><strong>Method to prevent overfitting</strong></th> <th><strong>What is it?</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Get more data</strong></td> <td>Having more data gives the model more opportunities to learn patterns, patterns which may be more generalizable to new examples.</td> </tr> <tr> <td><strong>Simplify your model</strong></td> <td>If the current model is already overfitting the training data, it may be too complicated of a model. This means it's learning the patterns of the data too well and isn't able to generalize well to unseen data. One way to simplify a model is to reduce the number of layers it uses or to reduce the number of hidden units in each layer.</td> </tr> <tr> <td><strong>Use data augmentation</strong></td> <td><a href=https://developers.google.com/machine-learning/glossary#data-augmentation><strong>Data augmentation</strong></a> manipulates the training data in a way so that's harder for the model to learn as it artificially adds more variety to the data. If a model is able to learn patterns in augmented data, the model may be able to generalize better to unseen data.</td> </tr> <tr> <td><strong>Use transfer learning</strong></td> <td><a href=https://developers.google.com/machine-learning/glossary#transfer-learning><strong>Transfer learning</strong></a> involves leveraging the patterns (also called pretrained weights) one model has learned to use as the foundation for your own task. In our case, we could use one computer vision model pretrained on a large variety of images and then tweak it slightly to be more specialized for food images.</td> </tr> <tr> <td><strong>Use dropout layers</strong></td> <td>Dropout layers randomly remove connections between hidden layers in neural networks, effectively simplifying a model but also making the remaining connections better. See <a href=https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html><code>torch.nn.Dropout()</code></a> for more.</td> </tr> <tr> <td><strong>Use learning rate decay</strong></td> <td>The idea here is to slowly decrease the learning rate as a model trains. This is akin to reaching for a coin at the back of a couch. The closer you get, the smaller your steps. The same with the learning rate, the closer you get to <a href=https://developers.google.com/machine-learning/glossary#convergence><strong>convergence</strong></a>, the smaller you'll want your weight updates to be.</td> </tr> <tr> <td><strong>Use early stopping</strong></td> <td><a href=https://developers.google.com/machine-learning/glossary#early_stopping><strong>Early stopping</strong></a> stops model training <em>before</em> it begins to overfit. As in, say the model's loss has stopped decreasing for the past 10 epochs (this number is arbitrary), you may want to stop the model training here and go with the model weights that had the lowest loss (10 epochs prior).</td> </tr> </tbody> </table> <p>There are more methods for dealing with overfitting but these are some of the main ones.</p> <p>As you start to build more and more deep models, you'll find because deep learnings are <em>so good</em> at learning patterns in data, dealing with overfitting is one of the primary problems of deep learning.</p> <h3 id=82-how-to-deal-with-underfitting>8.2 How to deal with underfitting</h3> <p>When a model is <a href=https://developers.google.com/machine-learning/glossary#underfitting><strong>underfitting</strong></a> it is considered to have poor predictive power on the training and test sets.</p> <p>In essence, an underfitting model will fail to reduce the loss values to a desired level.</p> <p>Right now, looking at our current loss curves, I'd considered our <code>TinyVGG</code> model, <code>model_0</code>, to be underfitting the data.</p> <p>The main idea behind dealing with underfitting is to <em>increase</em> your model's predictive power.</p> <p>There are several ways to do this.</p> <table> <thead> <tr> <th><strong>Method to prevent underfitting</strong></th> <th><strong>What is it?</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Add more layers/units to your model</strong></td> <td>If your model is underfitting, it may not have enough capability to <em>learn</em> the required patterns/weights/representations of the data to be predictive. One way to add more predictive power to your model is to increase the number of hidden layers/units within those layers.</td> </tr> <tr> <td><strong>Tweak the learning rate</strong></td> <td>Perhaps your model's learning rate is too high to begin with. And it's trying to update its weights each epoch too much, in turn not learning anything. In this case, you might lower the learning rate and see what happens.</td> </tr> <tr> <td><strong>Use transfer learning</strong></td> <td>Transfer learning is capable of preventing overfitting and underfitting. It involves using the patterns from a previously working model and adjusting them to your own problem.</td> </tr> <tr> <td><strong>Train for longer</strong></td> <td>Sometimes a model just needs more time to learn representations of data. If you find in your smaller experiments your model isn't learning anything, perhaps leaving it train for a more epochs may result in better performance.</td> </tr> <tr> <td><strong>Use less regularization</strong></td> <td>Perhaps your model is underfitting because you're trying to prevent overfitting too much. Holding back on regularization techniques can help your model fit the data better.</td> </tr> </tbody> </table> <h3 id=83-the-balance-between-overfitting-and-underfitting>8.3 The balance between overfitting and underfitting</h3> <p>None of the methods discussed above are silver bullets, meaning, they don't always work.</p> <p>And preventing overfitting and underfitting is possibly the most active area of machine learning research.</p> <p>Since everone wants their models to fit better (less underfitting) but not so good they don't generalize well and perform in the real world (less overfitting).</p> <p>There's a fine line between overfitting and underfitting.</p> <p>Because too much of each can cause the other.</p> <p>Transfer learning is perhaps one of the most powerful techniques when it comes to dealing with both overfitting and underfitting on your own problems.</p> <p>Rather than handcraft different overfitting and underfitting techniques, transfer learning enables you to take an already working model in a similar problem space to yours (say one from <a href=https://paperswithcode.com/sota>paperswithcode.com/sota</a> or <a href=https://huggingface.co/models>Hugging Face models</a>) and apply it to your own dataset.</p> <p>We'll see the power of transfer learning in a later notebook.</p> <h2 id=9-model-1-tinyvgg-with-data-augmentation>9. Model 1: TinyVGG with Data Augmentation</h2> <p>Time to try out another model!</p> <p>This time, let's load in the data and use <strong>data augmentation</strong> to see if it improves our results in anyway.</p> <p>First, we'll compose a training transform to include <code>transforms.TrivialAugmentWide()</code> as well as resize and turn our images into tensors.</p> <p>We'll do the same for a testing transform except without the data augmentation.</p> <h3 id=91-create-transform-with-data-augmentation>9.1 Create transform with data augmentation</h3> <div class=highlight><pre><span></span><code><span class=c1># Create training transform with TrivialAugment</span>
<span class=n>train_transform_trivial_augment</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>TrivialAugmentWide</span><span class=p>(</span><span class=n>num_magnitude_bins</span><span class=o>=</span><span class=mi>31</span><span class=p>),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span> 
<span class=p>])</span>

<span class=c1># Create testing transform (no data augmentation)</span>
<span class=n>test_transform</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>()</span>
<span class=p>])</span>
</code></pre></div> <p>Wonderful!</p> <p>Now let's turn our images into <code>Dataset</code>'s using <code>torchvision.datasets.ImageFolder()</code> and then into <code>DataLoader</code>'s with <code>torch.utils.data.DataLoader()</code>.</p> <h3 id=92-create-train-and-test-datasets-and-dataloaders>9.2 Create train and test <code>Dataset</code>'s and <code>DataLoader</code>'s</h3> <p>We'll make sure the train <code>Dataset</code> uses the <code>train_transform_trivial_augment</code> and the test <code>Dataset</code> uses the <code>test_transform</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># Turn image folders into Datasets</span>
<span class=n>train_data_augmented</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>ImageFolder</span><span class=p>(</span><span class=n>train_dir</span><span class=p>,</span> <span class=n>transform</span><span class=o>=</span><span class=n>train_transform_trivial_augment</span><span class=p>)</span>
<span class=n>test_data_simple</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>ImageFolder</span><span class=p>(</span><span class=n>test_dir</span><span class=p>,</span> <span class=n>transform</span><span class=o>=</span><span class=n>test_transform</span><span class=p>)</span>

<span class=n>train_data_augmented</span><span class=p>,</span> <span class=n>test_data_simple</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(Dataset ImageFolder
     Number of datapoints: 225
     Root location: data/pizza_steak_sushi/train
     StandardTransform
 Transform: Compose(
                Resize(size=(64, 64), interpolation=bilinear, max_size=None, antialias=True)
                TrivialAugmentWide(num_magnitude_bins=31, interpolation=InterpolationMode.NEAREST, fill=None)
                ToTensor()
            ),
 Dataset ImageFolder
     Number of datapoints: 75
     Root location: data/pizza_steak_sushi/test
     StandardTransform
 Transform: Compose(
                Resize(size=(64, 64), interpolation=bilinear, max_size=None, antialias=True)
                ToTensor()
            ))
</code></pre></div> <p>And we'll make <code>DataLoader</code>'s with a <code>batch_size=32</code> and with <code>num_workers</code> set to the number of CPUs available on our machine (we can get this using Python's <code>os.cpu_count()</code>).</p> <div class=highlight><pre><span></span><code><span class=c1># Turn Datasets into DataLoader&#39;s</span>
<span class=kn>import</span><span class=w> </span><span class=nn>os</span>
<span class=n>BATCH_SIZE</span> <span class=o>=</span> <span class=mi>32</span>
<span class=n>NUM_WORKERS</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>cpu_count</span><span class=p>()</span>

<span class=n>torch</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
<span class=n>train_dataloader_augmented</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>train_data_augmented</span><span class=p>,</span> 
                                        <span class=n>batch_size</span><span class=o>=</span><span class=n>BATCH_SIZE</span><span class=p>,</span> 
                                        <span class=n>shuffle</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
                                        <span class=n>num_workers</span><span class=o>=</span><span class=n>NUM_WORKERS</span><span class=p>)</span>

<span class=n>test_dataloader_simple</span> <span class=o>=</span> <span class=n>DataLoader</span><span class=p>(</span><span class=n>test_data_simple</span><span class=p>,</span> 
                                    <span class=n>batch_size</span><span class=o>=</span><span class=n>BATCH_SIZE</span><span class=p>,</span> 
                                    <span class=n>shuffle</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> 
                                    <span class=n>num_workers</span><span class=o>=</span><span class=n>NUM_WORKERS</span><span class=p>)</span>

<span class=n>train_dataloader_augmented</span><span class=p>,</span> <span class=n>test_dataloader</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(&lt;torch.utils.data.dataloader.DataLoader at 0x7fae84165fa0&gt;,
 &lt;torch.utils.data.dataloader.DataLoader at 0x7fae875e2e50&gt;)
</code></pre></div> <h3 id=93-construct-and-train-model-1>9.3 Construct and train Model 1</h3> <p>Data loaded!</p> <p>Now to build our next model, <code>model_1</code>, we can reuse our <code>TinyVGG</code> class from before. </p> <p>We'll make sure to send it to the target device.</p> <div class=highlight><pre><span></span><code><span class=c1># Create model_1 and send it to the target device</span>
<span class=n>torch</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
<span class=n>model_1</span> <span class=o>=</span> <span class=n>TinyVGG</span><span class=p>(</span>
    <span class=n>input_shape</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
    <span class=n>hidden_units</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span>
    <span class=n>output_shape</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>train_data_augmented</span><span class=o>.</span><span class=n>classes</span><span class=p>))</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>
<span class=n>model_1</span>
</code></pre></div> <div class=highlight><pre><span></span><code>TinyVGG(
  (conv_block_1): Sequential(
    (0): Conv2d(3, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU()
    (2): Conv2d(10, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU()
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (conv_block_2): Sequential(
    (0): Conv2d(10, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU()
    (2): Conv2d(10, 10, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU()
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (classifier): Sequential(
    (0): Flatten(start_dim=1, end_dim=-1)
    (1): Linear(in_features=2560, out_features=3, bias=True)
  )
)
</code></pre></div> <p>Model ready!</p> <p>Time to train!</p> <p>Since we've already got functions for the training loop (<code>train_step()</code>) and testing loop (<code>test_step()</code>) and a function to put them together in <code>train()</code>, let's reuse those.</p> <p>We'll use the same setup as <code>model_0</code> with only the <code>train_dataloader</code> parameter varying: * Train for 5 epochs. * Use <code>train_dataloader=train_dataloader_augmented</code> as the training data in <code>train()</code>. * Use <code>torch.nn.CrossEntropyLoss()</code> as the loss function (since we're working with multi-class classification). * Use <code>torch.optim.Adam()</code> with <code>lr=0.001</code> as the learning rate as the optimizer. </p> <div class=highlight><pre><span></span><code><span class=c1># Set random seeds</span>
<span class=n>torch</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span> 
<span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>manual_seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>

<span class=c1># Set number of epochs</span>
<span class=n>NUM_EPOCHS</span> <span class=o>=</span> <span class=mi>5</span>

<span class=c1># Setup loss function and optimizer</span>
<span class=n>loss_fn</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>CrossEntropyLoss</span><span class=p>()</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>optim</span><span class=o>.</span><span class=n>Adam</span><span class=p>(</span><span class=n>params</span><span class=o>=</span><span class=n>model_1</span><span class=o>.</span><span class=n>parameters</span><span class=p>(),</span> <span class=n>lr</span><span class=o>=</span><span class=mf>0.001</span><span class=p>)</span>

<span class=c1># Start the timer</span>
<span class=kn>from</span><span class=w> </span><span class=nn>timeit</span><span class=w> </span><span class=kn>import</span> <span class=n>default_timer</span> <span class=k>as</span> <span class=n>timer</span> 
<span class=n>start_time</span> <span class=o>=</span> <span class=n>timer</span><span class=p>()</span>

<span class=c1># Train model_1</span>
<span class=n>model_1_results</span> <span class=o>=</span> <span class=n>train</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>model_1</span><span class=p>,</span> 
                        <span class=n>train_dataloader</span><span class=o>=</span><span class=n>train_dataloader_augmented</span><span class=p>,</span>
                        <span class=n>test_dataloader</span><span class=o>=</span><span class=n>test_dataloader_simple</span><span class=p>,</span>
                        <span class=n>optimizer</span><span class=o>=</span><span class=n>optimizer</span><span class=p>,</span>
                        <span class=n>loss_fn</span><span class=o>=</span><span class=n>loss_fn</span><span class=p>,</span> 
                        <span class=n>epochs</span><span class=o>=</span><span class=n>NUM_EPOCHS</span><span class=p>)</span>

<span class=c1># End the timer and print out how long it took</span>
<span class=n>end_time</span> <span class=o>=</span> <span class=n>timer</span><span class=p>()</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Total training time: </span><span class=si>{</span><span class=n>end_time</span><span class=o>-</span><span class=n>start_time</span><span class=si>:</span><span class=s2>.3f</span><span class=si>}</span><span class=s2> seconds&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code> 20%|██        | 1/5 [00:01&lt;00:05,  1.46s/it]

Epoch: 1 | train_loss: 1.1074 | train_acc: 0.2500 | test_loss: 1.1059 | test_acc: 0.2604


 40%|████      | 2/5 [00:03&lt;00:04,  1.52s/it]

Epoch: 2 | train_loss: 1.0790 | train_acc: 0.4258 | test_loss: 1.1384 | test_acc: 0.2604


 60%|██████    | 3/5 [00:04&lt;00:03,  1.51s/it]

Epoch: 3 | train_loss: 1.0802 | train_acc: 0.4258 | test_loss: 1.1694 | test_acc: 0.2604


 80%|████████  | 4/5 [00:05&lt;00:01,  1.47s/it]

Epoch: 4 | train_loss: 1.1286 | train_acc: 0.3047 | test_loss: 1.1621 | test_acc: 0.2604


100%|██████████| 5/5 [00:07&lt;00:00,  1.51s/it]

Epoch: 5 | train_loss: 1.0884 | train_acc: 0.4258 | test_loss: 1.1477 | test_acc: 0.2604
Total training time: 7.551 seconds
</code></pre></div> <p>Hmm...</p> <p>It doesn't look like our model performed very well again.</p> <p>Let's check out its loss curves.</p> <h3 id=94-plot-the-loss-curves-of-model-1>9.4 Plot the loss curves of Model 1</h3> <p>Since we've got the results of <code>model_1</code> saved in a results dictionary, <code>model_1_results</code>, we can plot them using <code>plot_loss_curves()</code>.</p> <div class=highlight><pre><span></span><code><span class=n>plot_loss_curves</span><span class=p>(</span><span class=n>model_1_results</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_132_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_132_0.png></a></p> <p>Wow...</p> <p>These don't look very good either...</p> <p>Is our model <strong>underfitting</strong> or <strong>overfitting</strong>?</p> <p>Or both?</p> <p>Ideally we'd like it have higher accuracy and lower loss right?</p> <p>What are some methods you could try to use to achieve these?</p> <h2 id=10-compare-model-results>10. Compare model results</h2> <p>Even though our models our performing quite poorly, we can still write code to compare them.</p> <p>Let's first turn our model results in pandas DataFrames.</p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>pandas</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>pd</span>
<span class=n>model_0_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>model_0_results</span><span class=p>)</span>
<span class=n>model_1_df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>model_1_results</span><span class=p>)</span>
<span class=n>model_0_df</span>
</code></pre></div> <div> <style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style> <table border=1 class=dataframe> <thead> <tr style="text-align: right;"> <th></th> <th>train_loss</th> <th>train_acc</th> <th>test_loss</th> <th>test_acc</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>1.107836</td> <td>0.257812</td> <td>1.136208</td> <td>0.260417</td> </tr> <tr> <th>1</th> <td>1.084645</td> <td>0.425781</td> <td>1.162170</td> <td>0.197917</td> </tr> <tr> <th>2</th> <td>1.115274</td> <td>0.292969</td> <td>1.169458</td> <td>0.197917</td> </tr> <tr> <th>3</th> <td>1.099046</td> <td>0.289062</td> <td>1.134122</td> <td>0.197917</td> </tr> <tr> <th>4</th> <td>1.098948</td> <td>0.292969</td> <td>1.143407</td> <td>0.197917</td> </tr> </tbody> </table> </div> <p>And now we can write some plotting code using <code>matplotlib</code> to visualize the results of <code>model_0</code> and <code>model_1</code> together.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup a plot </span>
<span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>15</span><span class=p>,</span> <span class=mi>10</span><span class=p>))</span>

<span class=c1># Get number of epochs</span>
<span class=n>epochs</span> <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>model_0_df</span><span class=p>))</span>

<span class=c1># Plot train loss</span>
<span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_0_df</span><span class=p>[</span><span class=s2>&quot;train_loss&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 0&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_1_df</span><span class=p>[</span><span class=s2>&quot;train_loss&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 1&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s2>&quot;Train Loss&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&quot;Epochs&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>

<span class=c1># Plot test loss</span>
<span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_0_df</span><span class=p>[</span><span class=s2>&quot;test_loss&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 0&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_1_df</span><span class=p>[</span><span class=s2>&quot;test_loss&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 1&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s2>&quot;Test Loss&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&quot;Epochs&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>

<span class=c1># Plot train accuracy</span>
<span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_0_df</span><span class=p>[</span><span class=s2>&quot;train_acc&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 0&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_1_df</span><span class=p>[</span><span class=s2>&quot;train_acc&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 1&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s2>&quot;Train Accuracy&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&quot;Epochs&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>

<span class=c1># Plot test accuracy</span>
<span class=n>plt</span><span class=o>.</span><span class=n>subplot</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_0_df</span><span class=p>[</span><span class=s2>&quot;test_acc&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 0&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>epochs</span><span class=p>,</span> <span class=n>model_1_df</span><span class=p>[</span><span class=s2>&quot;test_acc&quot;</span><span class=p>],</span> <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Model 1&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=s2>&quot;Test Accuracy&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&quot;Epochs&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>();</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_137_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_137_0.png></a></p> <p>It looks like our models both performed equally poorly and were kind of sporadic (the metrics go up and down sharply).</p> <p>If you built <code>model_2</code>, what would you do differently to try and improve performance?</p> <h2 id=11-make-a-prediction-on-a-custom-image>11. Make a prediction on a custom image</h2> <p>If you've trained a model on a certain dataset, chances are you'd like to make a prediction on on your own custom data.</p> <p>In our case, since we've trained a model on pizza, steak and sushi images, how could we use our model to make a prediction on one of our own images?</p> <p>To do so, we can load an image and then <strong>preprocess it in a way that matches the type of data our model was trained on</strong>.</p> <p>In other words, we'll have to convert our own custom image to a tensor and make sure it's in the right datatype before passing it to our model.</p> <p>Let's start by downloading a custom image.</p> <p>Since our model predicts whether an image contains pizza, steak or sushi, let's download a photo of <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/images/04-pizza-dad.jpeg>my Dad giving two thumbs up to a big pizza from the Learn PyTorch for Deep Learning GitHub</a>.</p> <p>We download the image using Python's <code>requests</code> module.</p> <blockquote> <p><strong>Note:</strong> If you're using Google Colab, you can also upload an image to the current session by going to the left hand side menu -&gt; Files -&gt; Upload to session storage. Beware though, this image will delete when your Google Colab session ends.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># Download custom image</span>
<span class=kn>import</span><span class=w> </span><span class=nn>requests</span>

<span class=c1># Setup custom image path</span>
<span class=n>custom_image_path</span> <span class=o>=</span> <span class=n>data_path</span> <span class=o>/</span> <span class=s2>&quot;04-pizza-dad.jpeg&quot;</span>

<span class=c1># Download the image if it doesn&#39;t already exist</span>
<span class=k>if</span> <span class=ow>not</span> <span class=n>custom_image_path</span><span class=o>.</span><span class=n>is_file</span><span class=p>():</span>
    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>custom_image_path</span><span class=p>,</span> <span class=s2>&quot;wb&quot;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
        <span class=c1># When downloading from GitHub, need to use the &quot;raw&quot; file link</span>
        <span class=n>request</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pizza-dad.jpeg&quot;</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Downloading </span><span class=si>{</span><span class=n>custom_image_path</span><span class=si>}</span><span class=s2>...&quot;</span><span class=p>)</span>
        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>request</span><span class=o>.</span><span class=n>content</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;</span><span class=si>{</span><span class=n>custom_image_path</span><span class=si>}</span><span class=s2> already exists, skipping download.&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Downloading data/04-pizza-dad.jpeg...
</code></pre></div> <h3 id=111-loading-in-a-custom-image-with-pytorch>11.1 Loading in a custom image with PyTorch</h3> <p>Excellent!</p> <p>Looks like we've got a custom image downloaded and ready to go at <code>data/04-pizza-dad.jpeg</code>. </p> <p>Time to load it in.</p> <p>PyTorch's <code>torchvision</code> has several input and output ("IO" or "io" for short) methods for reading and writing images and video in <a href=https://pytorch.org/vision/stable/io.html><code>torchvision.io</code></a>.</p> <p>Since we want to load in an image, we'll use <a href=https://pytorch.org/vision/stable/generated/torchvision.io.read_image.html#torchvision.io.read_image><code>torchvision.io.read_image()</code></a>.</p> <p>This method will read a JPEG or PNG image and turn it into a 3 dimensional RGB or grayscale <code>torch.Tensor</code> with values of datatype <code>uint8</code> in range <code>[0, 255]</code>.</p> <p>Let's try it out.</p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>torchvision</span>

<span class=c1># Read in custom image</span>
<span class=n>custom_image_uint8</span> <span class=o>=</span> <span class=n>torchvision</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_image</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>custom_image_path</span><span class=p>))</span>

<span class=c1># Print out image data</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image tensor:</span><span class=se>\n</span><span class=si>{</span><span class=n>custom_image_uint8</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image shape: </span><span class=si>{</span><span class=n>custom_image_uint8</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image dtype: </span><span class=si>{</span><span class=n>custom_image_uint8</span><span class=o>.</span><span class=n>dtype</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Custom image tensor:
tensor([[[154, 173, 181,  ...,  21,  18,  14],
         [146, 165, 181,  ...,  21,  18,  15],
         [124, 146, 172,  ...,  18,  17,  15],
         ...,
         [ 72,  59,  45,  ..., 152, 150, 148],
         [ 64,  55,  41,  ..., 150, 147, 144],
         [ 64,  60,  46,  ..., 149, 146, 143]],

        [[171, 190, 193,  ...,  22,  19,  15],
         [163, 182, 193,  ...,  22,  19,  16],
         [141, 163, 184,  ...,  19,  18,  16],
         ...,
         [ 55,  42,  28,  ..., 107, 104, 103],
         [ 47,  38,  24,  ..., 108, 104, 102],
         [ 47,  43,  29,  ..., 107, 104, 101]],

        [[119, 138, 147,  ...,  17,  14,  10],
         [111, 130, 145,  ...,  17,  14,  11],
         [ 87, 111, 136,  ...,  14,  13,  11],
         ...,
         [ 35,  22,   8,  ...,  52,  52,  48],
         [ 27,  18,   4,  ...,  50,  49,  44],
         [ 27,  23,   9,  ...,  49,  46,  43]]], dtype=torch.uint8)

Custom image shape: torch.Size([3, 4032, 3024])

Custom image dtype: torch.uint8
</code></pre></div> <p>Nice! Looks like our image is in tensor format, however, is this image format compatible with our model?</p> <p>Our <code>custom_image</code> tensor is of datatype <code>torch.uint8</code> and its values are between <code>[0, 255]</code>.</p> <p>But our model takes image tensors of datatype <code>torch.float32</code> and with values between <code>[0, 1]</code>.</p> <p>So before we use our custom image with our model, <strong>we'll need to convert it to the same format as the data our model is trained on</strong>.</p> <p>If we don't do this, our model will error.</p> <div class=highlight><pre><span></span><code><span class=c1># Try to make a prediction on image in uint8 format (this will error)</span>
<span class=n>model_1</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
<span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
    <span class=n>model_1</span><span class=p>(</span><span class=n>custom_image_uint8</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>))</span>
</code></pre></div> <div class=highlight><pre><span></span><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[61], line 4
      2 model_1.eval()
      3 with torch.inference_mode():
----&gt; 4     model_1(custom_image_uint8.to(device))


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


Cell In[41], line 40, in TinyVGG.forward(self, x)
     39 def forward(self, x: torch.Tensor):
---&gt; 40     x = self.conv_block_1(x)
     41     # print(x.shape)
     42     x = self.conv_block_2(x)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/container.py:217, in Sequential.forward(self, input)
    215 def forward(self, input):
    216     for module in self:
--&gt; 217         input = module(input)
    218     return input


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/conv.py:460, in Conv2d.forward(self, input)
    459 def forward(self, input: Tensor) -&gt; Tensor:
--&gt; 460     return self._conv_forward(input, self.weight, self.bias)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/conv.py:456, in Conv2d._conv_forward(self, input, weight, bias)
    452 if self.padding_mode != &#39;zeros&#39;:
    453     return F.conv2d(F.pad(input, self._reversed_padding_repeated_twice, mode=self.padding_mode),
    454                     weight, bias, self.stride,
    455                     _pair(0), self.dilation, self.groups)
--&gt; 456 return F.conv2d(input, weight, bias, self.stride,
    457                 self.padding, self.dilation, self.groups)


RuntimeError: Input type (unsigned char) and bias type (float) should be the same
</code></pre></div> <p>If we try to make a prediction on an image in a different datatype to what our model was trained on, we get an error like the following:</p> <blockquote> <p><code>RuntimeError: Input type (torch.cuda.ByteTensor) and weight type (torch.cuda.FloatTensor) should be the same</code></p> </blockquote> <p>Let's fix this by converting our custom image to the same datatype as what our model was trained on (<code>torch.float32</code>).</p> <div class=highlight><pre><span></span><code><span class=c1># Load in custom image and convert the tensor values to float32</span>
<span class=n>custom_image</span> <span class=o>=</span> <span class=n>torchvision</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_image</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>custom_image_path</span><span class=p>))</span><span class=o>.</span><span class=n>type</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>float32</span><span class=p>)</span>

<span class=c1># Divide the image pixel values by 255 to get them between [0, 1]</span>
<span class=n>custom_image</span> <span class=o>=</span> <span class=n>custom_image</span> <span class=o>/</span> <span class=mf>255.</span> 

<span class=c1># Print out image data</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image tensor:</span><span class=se>\n</span><span class=si>{</span><span class=n>custom_image</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image shape: </span><span class=si>{</span><span class=n>custom_image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=se>\n</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image dtype: </span><span class=si>{</span><span class=n>custom_image</span><span class=o>.</span><span class=n>dtype</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Custom image tensor:
tensor([[[0.6039, 0.6784, 0.7098,  ..., 0.0824, 0.0706, 0.0549],
         [0.5725, 0.6471, 0.7098,  ..., 0.0824, 0.0706, 0.0588],
         [0.4863, 0.5725, 0.6745,  ..., 0.0706, 0.0667, 0.0588],
         ...,
         [0.2824, 0.2314, 0.1765,  ..., 0.5961, 0.5882, 0.5804],
         [0.2510, 0.2157, 0.1608,  ..., 0.5882, 0.5765, 0.5647],
         [0.2510, 0.2353, 0.1804,  ..., 0.5843, 0.5725, 0.5608]],

        [[0.6706, 0.7451, 0.7569,  ..., 0.0863, 0.0745, 0.0588],
         [0.6392, 0.7137, 0.7569,  ..., 0.0863, 0.0745, 0.0627],
         [0.5529, 0.6392, 0.7216,  ..., 0.0745, 0.0706, 0.0627],
         ...,
         [0.2157, 0.1647, 0.1098,  ..., 0.4196, 0.4078, 0.4039],
         [0.1843, 0.1490, 0.0941,  ..., 0.4235, 0.4078, 0.4000],
         [0.1843, 0.1686, 0.1137,  ..., 0.4196, 0.4078, 0.3961]],

        [[0.4667, 0.5412, 0.5765,  ..., 0.0667, 0.0549, 0.0392],
         [0.4353, 0.5098, 0.5686,  ..., 0.0667, 0.0549, 0.0431],
         [0.3412, 0.4353, 0.5333,  ..., 0.0549, 0.0510, 0.0431],
         ...,
         [0.1373, 0.0863, 0.0314,  ..., 0.2039, 0.2039, 0.1882],
         [0.1059, 0.0706, 0.0157,  ..., 0.1961, 0.1922, 0.1725],
         [0.1059, 0.0902, 0.0353,  ..., 0.1922, 0.1804, 0.1686]]])

Custom image shape: torch.Size([3, 4032, 3024])

Custom image dtype: torch.float32
</code></pre></div> <h3 id=112-predicting-on-custom-images-with-a-trained-pytorch-model>11.2 Predicting on custom images with a trained PyTorch model</h3> <p>Beautiful, it looks like our image data is now in the same format our model was trained on.</p> <p>Except for one thing...</p> <p>It's <code>shape</code>.</p> <p>Our model was trained on images with shape <code>[3, 64, 64]</code>, whereas our custom image is currently <code>[3, 4032, 3024]</code>. </p> <p>How could we make sure our custom image is the same shape as the images our model was trained on?</p> <p>Are there any <code>torchvision.transforms</code> that could help?</p> <p>Before we answer that question, let's plot the image with <code>matplotlib</code> to make sure it looks okay, remember we'll have to permute the dimensions from <code>CHW</code> to <code>HWC</code> to suit <code>matplotlib</code>'s requirements.</p> <div class=highlight><pre><span></span><code><span class=c1># Plot custom image</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>custom_image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># need to permute image dimensions from CHW -&gt; HWC otherwise matplotlib will error</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image shape: </span><span class=si>{</span><span class=n>custom_image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_148_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_148_0.png></a></p> <p>Two thumbs up!</p> <p>Now how could we get our image to be the same size as the images our model was trained on?</p> <p>One way to do so is with <code>torchvision.transforms.Resize()</code>.</p> <p>Let's compose a transform pipeline to do so.</p> <div class=highlight><pre><span></span><code><span class=c1># Create transform pipleine to resize image</span>
<span class=n>custom_image_transform</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=mi>64</span><span class=p>,</span> <span class=mi>64</span><span class=p>)),</span>
<span class=p>])</span>

<span class=c1># Transform target image</span>
<span class=n>custom_image_transformed</span> <span class=o>=</span> <span class=n>custom_image_transform</span><span class=p>(</span><span class=n>custom_image</span><span class=p>)</span>

<span class=c1># Print out original shape and new shape</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Original shape: </span><span class=si>{</span><span class=n>custom_image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;New shape: </span><span class=si>{</span><span class=n>custom_image_transformed</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Original shape: torch.Size([3, 4032, 3024])
New shape: torch.Size([3, 64, 64])
</code></pre></div> <p>Woohoo!</p> <p>Let's finally make a prediction on our own custom image.</p> <div class=highlight><pre><span></span><code><span class=n>model_1</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
<span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
    <span class=n>custom_image_pred</span> <span class=o>=</span> <span class=n>model_1</span><span class=p>(</span><span class=n>custom_image_transformed</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[65], line 3
      1 model_1.eval()
      2 with torch.inference_mode():
----&gt; 3     custom_image_pred = model_1(custom_image_transformed)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


Cell In[41], line 40, in TinyVGG.forward(self, x)
     39 def forward(self, x: torch.Tensor):
---&gt; 40     x = self.conv_block_1(x)
     41     # print(x.shape)
     42     x = self.conv_block_2(x)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/container.py:217, in Sequential.forward(self, input)
    215 def forward(self, input):
    216     for module in self:
--&gt; 217         input = module(input)
    218     return input


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/conv.py:460, in Conv2d.forward(self, input)
    459 def forward(self, input: Tensor) -&gt; Tensor:
--&gt; 460     return self._conv_forward(input, self.weight, self.bias)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/conv.py:456, in Conv2d._conv_forward(self, input, weight, bias)
    452 if self.padding_mode != &#39;zeros&#39;:
    453     return F.conv2d(F.pad(input, self._reversed_padding_repeated_twice, mode=self.padding_mode),
    454                     weight, bias, self.stride,
    455                     _pair(0), self.dilation, self.groups)
--&gt; 456 return F.conv2d(input, weight, bias, self.stride,
    457                 self.padding, self.dilation, self.groups)


RuntimeError: Expected all tensors to be on the same device, but found at least two devices, cpu and cuda:0! (when checking argument for argument weight in method wrapper_CUDA___slow_conv2d_forward)
</code></pre></div> <p>Oh my goodness...</p> <p>Despite our preparations our custom image and model are on different devices.</p> <p>And we get the error:</p> <blockquote> <p><code>RuntimeError: Expected all tensors to be on the same device, but found at least two devices, cpu and cuda:0! (when checking argument for argument weight in method wrapper___slow_conv2d_forward)</code></p> </blockquote> <p>Let's fix that by putting our <code>custom_image_transformed</code> on the target device.</p> <div class=highlight><pre><span></span><code><span class=n>model_1</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
<span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
    <span class=n>custom_image_pred</span> <span class=o>=</span> <span class=n>model_1</span><span class=p>(</span><span class=n>custom_image_transformed</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>))</span>
</code></pre></div> <div class=highlight><pre><span></span><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[66], line 3
      1 model_1.eval()
      2 with torch.inference_mode():
----&gt; 3     custom_image_pred = model_1(custom_image_transformed.to(device))


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


Cell In[41], line 44, in TinyVGG.forward(self, x)
     42 x = self.conv_block_2(x)
     43 # print(x.shape)
---&gt; 44 x = self.classifier(x)
     45 # print(x.shape)
     46 return x


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/container.py:217, in Sequential.forward(self, input)
    215 def forward(self, input):
    216     for module in self:
--&gt; 217         input = module(input)
    218     return input


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1511, in Module._wrapped_call_impl(self, *args, **kwargs)
   1509     return self._compiled_call_impl(*args, **kwargs)  # type: ignore[misc]
   1510 else:
-&gt; 1511     return self._call_impl(*args, **kwargs)


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/module.py:1520, in Module._call_impl(self, *args, **kwargs)
   1515 # If we don&#39;t have any hooks, we want to skip the rest of the logic in
   1516 # this function, and just call forward.
   1517 if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
   1518         or _global_backward_pre_hooks or _global_backward_hooks
   1519         or _global_forward_hooks or _global_forward_pre_hooks):
-&gt; 1520     return forward_call(*args, **kwargs)
   1522 try:
   1523     result = None


File ~/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/torch/nn/modules/linear.py:116, in Linear.forward(self, input)
    115 def forward(self, input: Tensor) -&gt; Tensor:
--&gt; 116     return F.linear(input, self.weight, self.bias)


RuntimeError: mat1 and mat2 shapes cannot be multiplied (10x256 and 2560x3)
</code></pre></div> <p>What now?</p> <p>It looks like we're getting a shape error.</p> <p>Why might this be?</p> <p>We converted our custom image to be the same size as the images our model was trained on...</p> <p>Oh wait...</p> <p>There's one dimension we forgot about.</p> <p>The batch size.</p> <p>Our model expects image tensors with a batch size dimension at the start (<code>NCHW</code> where <code>N</code> is the batch size).</p> <p>Except our custom image is currently only <code>CHW</code>. </p> <p>We can add a batch size dimension using <code>torch.unsqueeze(dim=0)</code> to add an extra dimension our image and <em>finally</em> make a prediction. </p> <p>Essentially we'll be telling our model to predict on a single image (an image with a <code>batch_size</code> of 1).</p> <div class=highlight><pre><span></span><code><span class=n>model_1</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
<span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
    <span class=c1># Add an extra dimension to image</span>
    <span class=n>custom_image_transformed_with_batch_size</span> <span class=o>=</span> <span class=n>custom_image_transformed</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=n>dim</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

    <span class=c1># Print out different shapes</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Custom image transformed shape: </span><span class=si>{</span><span class=n>custom_image_transformed</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Unsqueezed custom image shape: </span><span class=si>{</span><span class=n>custom_image_transformed_with_batch_size</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

    <span class=c1># Make a prediction on image with an extra dimension</span>
    <span class=n>custom_image_pred</span> <span class=o>=</span> <span class=n>model_1</span><span class=p>(</span><span class=n>custom_image_transformed</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=n>dim</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>))</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Custom image transformed shape: torch.Size([3, 64, 64])
Unsqueezed custom image shape: torch.Size([1, 3, 64, 64])
</code></pre></div> <p>Yes!!!</p> <p>It looks like it worked!</p> <blockquote> <p><strong>Note:</strong> What we've just gone through are three of the classical and most common deep learning and PyTorch issues: 1. <strong>Wrong datatypes</strong> - our model expects <code>torch.float32</code> where our original custom image was <code>uint8</code>. 2. <strong>Wrong device</strong> - our model was on the target <code>device</code> (in our case, the GPU) whereas our target data hadn't been moved to the target <code>device</code> yet. 3. <strong>Wrong shapes</strong> - our model expected an input image of shape <code>[N, C, H, W]</code> or <code>[batch_size, color_channels, height, width]</code> whereas our custom image tensor was of shape <code>[color_channels, height, width]</code>.</p> <p>Keep in mind, these errors aren't just for predicting on custom images. </p> <p>They will be present with almost every kind of data type (text, audio, structured data) and problem you work with.</p> </blockquote> <p>Now let's take a look at our model's predictions.</p> <div class=highlight><pre><span></span><code><span class=n>custom_image_pred</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[ 0.1185,  0.0272, -0.1456]], device=&#39;cuda:0&#39;)
</code></pre></div> <p>Alright, these are still in <em>logit form</em> (the raw outputs of a model are called logits).</p> <p>Let's convert them from logits -&gt; prediction probabilities -&gt; prediction labels.</p> <div class=highlight><pre><span></span><code><span class=c1># Print out prediction logits</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Prediction logits: </span><span class=si>{</span><span class=n>custom_image_pred</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># Convert logits -&gt; prediction probabilities (using torch.softmax() for multi-class classification)</span>
<span class=n>custom_image_pred_probs</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>softmax</span><span class=p>(</span><span class=n>custom_image_pred</span><span class=p>,</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Prediction probabilities: </span><span class=si>{</span><span class=n>custom_image_pred_probs</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># Convert prediction probabilities -&gt; prediction labels</span>
<span class=n>custom_image_pred_label</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>custom_image_pred_probs</span><span class=p>,</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Prediction label: </span><span class=si>{</span><span class=n>custom_image_pred_label</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Prediction logits: tensor([[ 0.1185,  0.0272, -0.1456]], device=&#39;cuda:0&#39;)
Prediction probabilities: tensor([[0.3731, 0.3405, 0.2865]], device=&#39;cuda:0&#39;)
Prediction label: tensor([0], device=&#39;cuda:0&#39;)
</code></pre></div> <p>Alright!</p> <p>Looking good.</p> <p>But of course our prediction label is still in index/tensor form.</p> <p>We can convert it to a string class name prediction by indexing on the <code>class_names</code> list.</p> <div class=highlight><pre><span></span><code><span class=c1># Find the predicted label</span>
<span class=n>custom_image_pred_class</span> <span class=o>=</span> <span class=n>class_names</span><span class=p>[</span><span class=n>custom_image_pred_label</span><span class=o>.</span><span class=n>cpu</span><span class=p>()]</span> <span class=c1># put pred label to CPU, otherwise will error</span>
<span class=n>custom_image_pred_class</span>
</code></pre></div> <div class=highlight><pre><span></span><code>&#39;pizza&#39;
</code></pre></div> <p>Wow.</p> <p>It looks like the model gets the prediction right, even though it was performing poorly based on our evaluation metrics.</p> <blockquote> <p><strong>Note:</strong> The model in its current form will predict "pizza", "steak" or "sushi" no matter what image it's given. If you wanted your model to predict on a different class, you'd have to train it to do so.</p> </blockquote> <p>But if we check the <code>custom_image_pred_probs</code>, we'll notice that the model gives almost equal weight (the values are similar) to every class.</p> <div class=highlight><pre><span></span><code><span class=c1># The values of the prediction probabilities are quite similar</span>
<span class=n>custom_image_pred_probs</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[0.3731, 0.3405, 0.2865]], device=&#39;cuda:0&#39;)
</code></pre></div> <p>Having prediction probabilities this similar could mean a couple of things: 1. The model is trying to predict all three classes at the same time (there may be an image containing pizza, steak and sushi). 2. The model doesn't really know what it wants to predict and is in turn just assigning similar values to each of the classes.</p> <p>Our case is number 2, since our model is poorly trained, it is basically <em>guessing</em> the prediction.</p> <h3 id=113-putting-custom-image-prediction-together-building-a-function>11.3 Putting custom image prediction together: building a function</h3> <p>Doing all of the above steps every time you'd like to make a prediction on a custom image would quickly become tedious.</p> <p>So let's put them all together in a function we can easily use over and over again.</p> <p>Specifically, let's make a function that: 1. Takes in a target image path and converts to the right datatype for our model (<code>torch.float32</code>). 2. Makes sure the target image pixel values are in the range <code>[0, 1]</code>. 3. Transforms the target image if necessary. 4. Makes sure the model is on the target device. 5. Makes a prediction on the target image with a trained model (ensuring the image is the right size and on the same device as the model). 6. Converts the model's output logits to prediction probabilities. 7. Converts the prediction probabilities to prediction labels. 8. Plots the target image alongside the model prediction and prediction probability.</p> <p>A fair few steps but we've got this!</p> <div class=highlight><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>pred_and_plot_image</span><span class=p>(</span><span class=n>model</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>,</span> 
                        <span class=n>image_path</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> 
                        <span class=n>class_names</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> 
                        <span class=n>transform</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
                        <span class=n>device</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>device</span> <span class=o>=</span> <span class=n>device</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Makes a prediction on a target image and plots the image with its prediction.&quot;&quot;&quot;</span>

    <span class=c1># 1. Load in image and convert the tensor values to float32</span>
    <span class=n>target_image</span> <span class=o>=</span> <span class=n>torchvision</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_image</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>image_path</span><span class=p>))</span><span class=o>.</span><span class=n>type</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>float32</span><span class=p>)</span>

    <span class=c1># 2. Divide the image pixel values by 255 to get them between [0, 1]</span>
    <span class=n>target_image</span> <span class=o>=</span> <span class=n>target_image</span> <span class=o>/</span> <span class=mf>255.</span> 

    <span class=c1># 3. Transform if necessary</span>
    <span class=k>if</span> <span class=n>transform</span><span class=p>:</span>
        <span class=n>target_image</span> <span class=o>=</span> <span class=n>transform</span><span class=p>(</span><span class=n>target_image</span><span class=p>)</span>

    <span class=c1># 4. Make sure the model is on the target device</span>
    <span class=n>model</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>

    <span class=c1># 5. Turn on model evaluation mode and inference mode</span>
    <span class=n>model</span><span class=o>.</span><span class=n>eval</span><span class=p>()</span>
    <span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>inference_mode</span><span class=p>():</span>
        <span class=c1># Add an extra dimension to the image</span>
        <span class=n>target_image</span> <span class=o>=</span> <span class=n>target_image</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=n>dim</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

        <span class=c1># Make a prediction on image with an extra dimension and send it to the target device</span>
        <span class=n>target_image_pred</span> <span class=o>=</span> <span class=n>model</span><span class=p>(</span><span class=n>target_image</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>))</span>

    <span class=c1># 6. Convert logits -&gt; prediction probabilities (using torch.softmax() for multi-class classification)</span>
    <span class=n>target_image_pred_probs</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>softmax</span><span class=p>(</span><span class=n>target_image_pred</span><span class=p>,</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>

    <span class=c1># 7. Convert prediction probabilities -&gt; prediction labels</span>
    <span class=n>target_image_pred_label</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>target_image_pred_probs</span><span class=p>,</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>

    <span class=c1># 8. Plot the image alongside the prediction and prediction probability</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>target_image</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># make sure it&#39;s the right size for matplotlib</span>
    <span class=k>if</span> <span class=n>class_names</span><span class=p>:</span>
        <span class=n>title</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&quot;Pred: </span><span class=si>{</span><span class=n>class_names</span><span class=p>[</span><span class=n>target_image_pred_label</span><span class=o>.</span><span class=n>cpu</span><span class=p>()]</span><span class=si>}</span><span class=s2> | Prob: </span><span class=si>{</span><span class=n>target_image_pred_probs</span><span class=o>.</span><span class=n>max</span><span class=p>()</span><span class=o>.</span><span class=n>cpu</span><span class=p>()</span><span class=si>:</span><span class=s2>.3f</span><span class=si>}</span><span class=s2>&quot;</span>
    <span class=k>else</span><span class=p>:</span> 
        <span class=n>title</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&quot;Pred: </span><span class=si>{</span><span class=n>target_image_pred_label</span><span class=si>}</span><span class=s2> | Prob: </span><span class=si>{</span><span class=n>target_image_pred_probs</span><span class=o>.</span><span class=n>max</span><span class=p>()</span><span class=o>.</span><span class=n>cpu</span><span class=p>()</span><span class=si>:</span><span class=s2>.3f</span><span class=si>}</span><span class=s2>&quot;</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>title</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p>What a nice looking function, let's test it out.</p> <div class=highlight><pre><span></span><code><span class=c1># Pred on our custom image</span>
<span class=n>pred_and_plot_image</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>model_1</span><span class=p>,</span>
                    <span class=n>image_path</span><span class=o>=</span><span class=n>custom_image_path</span><span class=p>,</span>
                    <span class=n>class_names</span><span class=o>=</span><span class=n>class_names</span><span class=p>,</span>
                    <span class=n>transform</span><span class=o>=</span><span class=n>custom_image_transform</span><span class=p>,</span>
                    <span class=n>device</span><span class=o>=</span><span class=n>device</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_169_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../04_pytorch_custom_datasets_files/04_pytorch_custom_datasets_169_0.png></a></p> <p>Two thumbs up again!</p> <p>Looks like our model got the prediction right just by guessing.</p> <p>This won't always be the case with other images though...</p> <p>The image is pixelated too because we resized it to <code>[64, 64]</code> using <code>custom_image_transform</code>.</p> <blockquote> <p><strong>Exercise:</strong> Try making a prediction with one of your own images of pizza, steak or sushi and see what happens.</p> </blockquote> <h2 id=main-takeaways>Main takeaways</h2> <p>We've covered a fair bit in this module.</p> <p>Let's summarise it with a few dot points.</p> <ul> <li>PyTorch has many in-built functions to deal with all kinds of data, from vision to text to audio to recommendation systems.</li> <li>If PyTorch's built-in data loading functions don't suit your requirements, you can write code to create your own custom datasets by subclassing <code>torch.utils.data.Dataset</code>.</li> <li><code>torch.utils.data.DataLoader</code>'s in PyTorch help turn your <code>Dataset</code>'s into iterables that can be used when training and testing a model.</li> <li>A lot of machine learning is dealing with the balance between <strong>overfitting</strong> and <strong>underfitting</strong> (we discussed different methods for each above, so a good exercise would be to research more and writing code to try out the different techniques).</li> <li>Predicting on your own custom data with a trained model is possible, as long as you format the data into a similar format to what the model was trained on. Make sure you take care of the three big PyTorch and deep learning errors:<ol> <li><strong>Wrong datatypes</strong> - Your model expected <code>torch.float32</code> when your data is <code>torch.uint8</code>.</li> <li><strong>Wrong data shapes</strong> - Your model expected <code>[batch_size, color_channels, height, width]</code> when your data is <code>[color_channels, height, width]</code>.</li> <li><strong>Wrong devices</strong> - Your model is on the GPU but your data is on the CPU. </li> </ol> </li> </ul> <h2 id=exercises>Exercises</h2> <p>All of the exercises are focused on practicing the code in the sections above.</p> <p>You should be able to complete them by referencing each section or by following the resource(s) linked.</p> <p>All exercises should be completed using <a href=https://pytorch.org/docs/stable/notes/cuda.html#device-agnostic-code>device-agnostic code</a>.</p> <p><strong>Resources:</strong> * <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/exercises/04_pytorch_custom_datasets_exercises.ipynb>Exercise template notebook for 04</a> * <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/solutions/04_pytorch_custom_datasets_exercise_solutions.ipynb>Example solutions notebook for 04</a> (try the exercises <em>before</em> looking at this)</p> <ol> <li>Our models are underperforming (not fitting the data well). What are 3 methods for preventing underfitting? Write them down and explain each with a sentence.</li> <li>Recreate the data loading functions we built in sections 1, 2, 3 and 4. You should have train and test <code>DataLoader</code>'s ready to use.</li> <li>Recreate <code>model_0</code> we built in section 7.</li> <li>Create training and testing functions for <code>model_0</code>.</li> <li>Try training the model you made in exercise 3 for 5, 20 and 50 epochs, what happens to the results?<ul> <li>Use <code>torch.optim.Adam()</code> with a learning rate of 0.001 as the optimizer. </li> </ul> </li> <li>Double the number of hidden units in your model and train it for 20 epochs, what happens to the results?</li> <li>Double the data you're using with your model and train it for 20 epochs, what happens to the results?<ul> <li><strong>Note:</strong> You can use the <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/04_custom_data_creation.ipynb>custom data creation notebook</a> to scale up your Food101 dataset.</li> <li>You can also find the <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/data/pizza_steak_sushi_20_percent.zip>already formatted double data (20% instead of 10% subset) dataset on GitHub</a>, you will need to write download code like in exercise 2 to get it into this notebook.</li> </ul> </li> <li>Make a prediction on your own custom image of pizza/steak/sushi (you could even download one from the internet) and share your prediction. <ul> <li>Does the model you trained in exercise 7 get it right? </li> <li>If not, what do you think you could do to improve it?</li> </ul> </li> </ol> <h2 id=extra-curriculum>Extra-curriculum</h2> <ul> <li>To practice your knowledge of PyTorch <code>Dataset</code>'s and <code>DataLoader</code>'s through PyTorch <a href=https://pytorch.org/tutorials/beginner/basics/data_tutorial.html>datasets and dataloaders tutorial notebook</a>.</li> <li>Spend 10-minutes reading the <a href=https://pytorch.org/vision/stable/transforms.html>PyTorch <code>torchvision.transforms</code> documentation</a>.<ul> <li>You can see demos of transforms in action in the <a href=https://pytorch.org/vision/stable/auto_examples/plot_transforms.html#illustration-of-transforms>illustrations of transforms tutorial</a>. </li> </ul> </li> <li>Spend 10-minutes reading the PyTorch <a href=https://pytorch.org/vision/stable/datasets.html><code>torchvision.datasets</code> documentation</a>.<ul> <li>What are some datasets that stand out to you?</li> <li>How could you try building a model on these?</li> </ul> </li> <li><a href=https://pytorch.org/data/beta/index.html>TorchData is currently in beta</a> (as of April 2022), it'll be a future way of loading data in PyTorch, but you can start to check it out now. </li> <li>To speed up deep learning models, you can do a few tricks to improve compute, memory and overhead computations, for more read the post <a href=https://horace.io/brrr_intro.html><em>Making Deep Learning Go Brrrr From First Principles</em></a> by Horace He. </li> </ul> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.instant", "navigation.path", "navigation.indexes", "navigation.top", "navigation.tracking"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../../../assets/javascripts/bundle.c8b220af.min.js></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script> <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body> </html>