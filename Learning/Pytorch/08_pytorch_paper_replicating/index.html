<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=prev href=../07_pytorch_experiment_tracking.pdf><link rel=next href=../08_pytorch_paper_replicating.pdf><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.7"><title>8 Paper replicating (ipynb) - My Documentation</title><link rel=stylesheet href=../../../assets/stylesheets/main.8608ea7d.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Merriweather";--md-code-font:"JetBrains Mono"}</style><link rel=stylesheet href=../../../assets/extra.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script> <link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../assets/javascripts/glightbox.min.js"></script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#08-pytorch-paper-replicating class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title="My Documentation" class="md-header__button md-logo" aria-label="My Documentation" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> My Documentation </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 8 Paper replicating (ipynb) </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../home/ class=md-tabs__link> Home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../../AI_Model/lenet/lenet5/ class=md-tabs__link> Kiến thức lập trình </a> </li> <li class=md-tabs__item> <a href=../../../Subject/XSTK/Exercise2/homework/ class=md-tabs__link> Môn học </a> </li> <li class=md-tabs__item> <a href=../../../Problem/general/ class=md-tabs__link> CP-Problem </a> </li> <li class=md-tabs__item> <a href=../../../other/other/ class=md-tabs__link> Other </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title="My Documentation" class="md-nav__button md-logo" aria-label="My Documentation" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> My Documentation </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1> <div class="md-nav__link md-nav__container"> <a href=../../../home/ class="md-nav__link "> <span class=md-ellipsis> Home </span> </a> <label class="md-nav__link " for=__nav_1 id=__nav_1_label tabindex=0> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> Home </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../home/about/ class=md-nav__link> <span class=md-ellipsis> About </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> Kiến thức lập trình </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Kiến thức lập trình </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_1> <label class=md-nav__link for=__nav_2_1 id=__nav_2_1_label tabindex=0> <span class=md-ellipsis> Các kiến trúc, mô hình AI và các kĩ thuật </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_1_label aria-expanded=false> <label class=md-nav__title for=__nav_2_1> <span class="md-nav__icon md-icon"></span> Các kiến trúc, mô hình AI và các kĩ thuật </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_1_1> <label class=md-nav__link for=__nav_2_1_1 id=__nav_2_1_1_label tabindex=0> <span class=md-ellipsis> Lenet-5 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_2_1_1_label aria-expanded=false> <label class=md-nav__title for=__nav_2_1_1> <span class="md-nav__icon md-icon"></span> Lenet-5 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../AI_Model/lenet/lenet5/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/lenet/lenetpart1/ class=md-nav__link> <span class=md-ellipsis> Tutorial part 1 </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/lenet/lenetpart2/ class=md-nav__link> <span class=md-ellipsis> Tutorial part 2 </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/lenet/Lenet5_MNIST/ class=md-nav__link> <span class=md-ellipsis> Lenet-5 (Final Project 1) </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_1_2> <label class=md-nav__link for=__nav_2_1_2 id=__nav_2_1_2_label tabindex=0> <span class=md-ellipsis> UNet </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_2_1_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2_1_2> <span class="md-nav__icon md-icon"></span> UNet </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../AI_Model/unet/unet/ class=md-nav__link> <span class=md-ellipsis> Unet tutorial </span> </a> </li> <li class=md-nav__item> <a href=../../AI_Model/unet/unet_model/ class=md-nav__link> <span class=md-ellipsis> UNet (Final Project 2) </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../AI_Model/essential/essential/ class=md-nav__link> <span class=md-ellipsis> Các kiến thức cần thiết </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_2> <label class=md-nav__link for=__nav_2_2 id=__nav_2_2_label tabindex=0> <span class=md-ellipsis> Python </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2_2> <span class="md-nav__icon md-icon"></span> Python </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Python/Numpy_1/ class=md-nav__link> <span class=md-ellipsis> Numpy 1 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Numpy_2/ class=md-nav__link> <span class=md-ellipsis> Numpy 2 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Pandas/ class=md-nav__link> <span class=md-ellipsis> Pandas </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Python_Pandas_exercise1/ class=md-nav__link> <span class=md-ellipsis> Pandas exercise 1 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Pandas2/ class=md-nav__link> <span class=md-ellipsis> Pandas 2 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Python_Pandas_exercise2/ class=md-nav__link> <span class=md-ellipsis> Pandas exercise 2 </span> </a> </li> <li class=md-nav__item> <a href=../../Python/Pandas_Join_Combine/ class=md-nav__link> <span class=md-ellipsis> Pandas Join Combine </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_3 checked> <label class=md-nav__link for=__nav_2_3 id=__nav_2_3_label tabindex=0> <span class=md-ellipsis> PyTorch </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_3_label aria-expanded=true> <label class=md-nav__title for=__nav_2_3> <span class="md-nav__icon md-icon"></span> PyTorch </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../00_pytorch_fundamentals/ class=md-nav__link> <span class=md-ellipsis> 0 Pytorch Fundamentals (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../00_pytorch_and_deep_learning_fundamentals.pdf class=md-nav__link> <span class=md-ellipsis> 0 Deep learning fundamentals (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../01_pytorch_workflow/ class=md-nav__link> <span class=md-ellipsis> 1 Pytorch workflow (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../01_pytorch_workflow.pdf class=md-nav__link> <span class=md-ellipsis> 1 Pytorch workflow (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../02_pytorch_classification/ class=md-nav__link> <span class=md-ellipsis> 2 classification (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../03_pytorch_computer_vision/ class=md-nav__link> <span class=md-ellipsis> 3 Computer vision (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../03_pytorch_computer_vision.pdf class=md-nav__link> <span class=md-ellipsis> 3 Compupter vision (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../04_pytorch_custom_datasets/ class=md-nav__link> <span class=md-ellipsis> 4 Custom datasets (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../05_pytorch_going_modular.pdf class=md-nav__link> <span class=md-ellipsis> 5 Going moduler (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../06_pytorch_transfer_learning/ class=md-nav__link> <span class=md-ellipsis> 6 Transfer learning (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../06_pytorch_transfer_learning.pdf class=md-nav__link> <span class=md-ellipsis> 6 Transfer learning (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../07_pytorch_experiment_tracking/ class=md-nav__link> <span class=md-ellipsis> 7 Experiment tracking (ipynb) </span> </a> </li> <li class=md-nav__item> <a href=../07_pytorch_experiment_tracking.pdf class=md-nav__link> <span class=md-ellipsis> 7 Experiment tracking (pdf) </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 8 Paper replicating (ipynb) </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 8 Paper replicating (ipynb) </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#what-is-paper-replicating class=md-nav__link> <span class=md-ellipsis> What is paper replicating? </span> </a> </li> <li class=md-nav__item> <a href=#what-is-a-machine-learning-research-paper class=md-nav__link> <span class=md-ellipsis> What is a machine learning research paper? </span> </a> </li> <li class=md-nav__item> <a href=#why-replicate-a-machine-learning-research-paper class=md-nav__link> <span class=md-ellipsis> Why replicate a machine learning research paper? </span> </a> </li> <li class=md-nav__item> <a href=#where-can-you-find-code-examples-for-machine-learning-research-papers class=md-nav__link> <span class=md-ellipsis> Where can you find code examples for machine learning research papers? </span> </a> </li> <li class=md-nav__item> <a href=#what-were-going-to-cover class=md-nav__link> <span class=md-ellipsis> What we're going to cover </span> </a> </li> <li class=md-nav__item> <a href=#terminology class=md-nav__link> <span class=md-ellipsis> Terminology </span> </a> </li> <li class=md-nav__item> <a href=#where-can-you-get-help class=md-nav__link> <span class=md-ellipsis> Where can you get help? </span> </a> </li> <li class=md-nav__item> <a href=#0-getting-setup class=md-nav__link> <span class=md-ellipsis> 0. Getting setup </span> </a> </li> <li class=md-nav__item> <a href=#1-get-data class=md-nav__link> <span class=md-ellipsis> 1. Get Data </span> </a> </li> <li class=md-nav__item> <a href=#2-create-datasets-and-dataloaders class=md-nav__link> <span class=md-ellipsis> 2. Create Datasets and DataLoaders </span> </a> <nav class=md-nav aria-label="2. Create Datasets and DataLoaders"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-prepare-transforms-for-images class=md-nav__link> <span class=md-ellipsis> 2.1 Prepare transforms for images </span> </a> </li> <li class=md-nav__item> <a href=#22-turn-images-into-dataloaders class=md-nav__link> <span class=md-ellipsis> 2.2 Turn images into DataLoader's </span> </a> </li> <li class=md-nav__item> <a href=#23-visualize-a-single-image class=md-nav__link> <span class=md-ellipsis> 2.3 Visualize a single image </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3-replicating-the-vit-paper-an-overview class=md-nav__link> <span class=md-ellipsis> 3. Replicating the ViT paper: an overview </span> </a> <nav class=md-nav aria-label="3. Replicating the ViT paper: an overview"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-inputs-and-outputs-layers-and-blocks class=md-nav__link> <span class=md-ellipsis> 3.1 Inputs and outputs, layers and blocks </span> </a> </li> <li class=md-nav__item> <a href=#32-getting-specific-whats-vit-made-of class=md-nav__link> <span class=md-ellipsis> 3.2 Getting specific: What's ViT made of? </span> </a> <nav class=md-nav aria-label="3.2 Getting specific: What's ViT made of?"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#321-exploring-figure-1 class=md-nav__link> <span class=md-ellipsis> 3.2.1 Exploring Figure 1 </span> </a> </li> <li class=md-nav__item> <a href=#322-exploring-the-four-equations class=md-nav__link> <span class=md-ellipsis> 3.2.2 Exploring the Four Equations </span> </a> </li> <li class=md-nav__item> <a href=#323-equation-1-overview class=md-nav__link> <span class=md-ellipsis> 3.2.3 Equation 1 overview </span> </a> </li> <li class=md-nav__item> <a href=#324-equation-2-overview class=md-nav__link> <span class=md-ellipsis> 3.2.4 Equation 2 overview </span> </a> </li> <li class=md-nav__item> <a href=#325-equation-3-overview class=md-nav__link> <span class=md-ellipsis> 3.2.5 Equation 3 overview </span> </a> </li> <li class=md-nav__item> <a href=#326-equation-4-overview class=md-nav__link> <span class=md-ellipsis> 3.2.6 Equation 4 overview </span> </a> </li> <li class=md-nav__item> <a href=#327-exploring-table-1 class=md-nav__link> <span class=md-ellipsis> 3.2.7 Exploring Table 1 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#33-my-workflow-for-replicating-papers class=md-nav__link> <span class=md-ellipsis> 3.3 My workflow for replicating papers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-equation-1-split-data-into-patches-and-creating-the-class-position-and-patch-embedding class=md-nav__link> <span class=md-ellipsis> 4. Equation 1: Split data into patches and creating the class, position and patch embedding </span> </a> <nav class=md-nav aria-label="4. Equation 1: Split data into patches and creating the class, position and patch embedding"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#41-calculating-patch-embedding-input-and-output-shapes-by-hand class=md-nav__link> <span class=md-ellipsis> 4.1 Calculating patch embedding input and output shapes by hand </span> </a> </li> <li class=md-nav__item> <a href=#42-turning-a-single-image-into-patches class=md-nav__link> <span class=md-ellipsis> 4.2 Turning a single image into patches </span> </a> </li> <li class=md-nav__item> <a href=#43-creating-image-patches-with-torchnnconv2d class=md-nav__link> <span class=md-ellipsis> 4.3 Creating image patches with torch.nn.Conv2d() </span> </a> </li> <li class=md-nav__item> <a href=#44-flattening-the-patch-embedding-with-torchnnflatten class=md-nav__link> <span class=md-ellipsis> 4.4 Flattening the patch embedding with torch.nn.Flatten() </span> </a> </li> <li class=md-nav__item> <a href=#45-turning-the-vit-patch-embedding-layer-into-a-pytorch-module class=md-nav__link> <span class=md-ellipsis> 4.5 Turning the ViT patch embedding layer into a PyTorch module </span> </a> </li> <li class=md-nav__item> <a href=#46-creating-the-class-token-embedding class=md-nav__link> <span class=md-ellipsis> 4.6 Creating the class token embedding </span> </a> </li> <li class=md-nav__item> <a href=#47-creating-the-position-embedding class=md-nav__link> <span class=md-ellipsis> 4.7 Creating the position embedding </span> </a> </li> <li class=md-nav__item> <a href=#48-putting-it-all-together-from-image-to-embedding class=md-nav__link> <span class=md-ellipsis> 4.8 Putting it all together: from image to embedding </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5-equation-2-multi-head-attention-msa class=md-nav__link> <span class=md-ellipsis> 5. Equation 2: Multi-Head Attention (MSA) </span> </a> <nav class=md-nav aria-label="5. Equation 2: Multi-Head Attention (MSA)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-the-layernorm-ln-layer class=md-nav__link> <span class=md-ellipsis> 5.1 The LayerNorm (LN) layer </span> </a> </li> <li class=md-nav__item> <a href=#52-the-multi-head-self-attention-msa-layer class=md-nav__link> <span class=md-ellipsis> 5.2 The Multi-Head Self Attention (MSA) layer </span> </a> </li> <li class=md-nav__item> <a href=#53-replicating-equation-2-with-pytorch-layers class=md-nav__link> <span class=md-ellipsis> 5.3 Replicating Equation 2 with PyTorch layers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6-equation-3-multilayer-perceptron-mlp class=md-nav__link> <span class=md-ellipsis> 6. Equation 3: Multilayer Perceptron (MLP) </span> </a> <nav class=md-nav aria-label="6. Equation 3: Multilayer Perceptron (MLP)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#61-the-mlp-layers class=md-nav__link> <span class=md-ellipsis> 6.1 The MLP layer(s) </span> </a> </li> <li class=md-nav__item> <a href=#62-replicating-equation-3-with-pytorch-layers class=md-nav__link> <span class=md-ellipsis> 6.2 Replicating Equation 3 with PyTorch layers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#7-create-the-transformer-encoder class=md-nav__link> <span class=md-ellipsis> 7. Create the Transformer Encoder </span> </a> <nav class=md-nav aria-label="7. Create the Transformer Encoder"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#71-creating-a-transformer-encoder-by-combining-our-custom-made-layers class=md-nav__link> <span class=md-ellipsis> 7.1 Creating a Transformer Encoder by combining our custom made layers </span> </a> </li> <li class=md-nav__item> <a href=#72-creating-a-transformer-encoder-with-pytorchs-transformer-layers class=md-nav__link> <span class=md-ellipsis> 7.2 Creating a Transformer Encoder with PyTorch's Transformer layers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#8-putting-it-all-together-to-create-vit class=md-nav__link> <span class=md-ellipsis> 8. Putting it all together to create ViT </span> </a> <nav class=md-nav aria-label="8. Putting it all together to create ViT"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#81-getting-a-visual-summary-of-our-vit-model class=md-nav__link> <span class=md-ellipsis> 8.1 Getting a visual summary of our ViT model </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#9-setting-up-training-code-for-our-vit-model class=md-nav__link> <span class=md-ellipsis> 9. Setting up training code for our ViT model </span> </a> <nav class=md-nav aria-label="9. Setting up training code for our ViT model"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#91-creating-an-optimizer class=md-nav__link> <span class=md-ellipsis> 9.1 Creating an optimizer </span> </a> </li> <li class=md-nav__item> <a href=#92-creating-a-loss-function class=md-nav__link> <span class=md-ellipsis> 9.2 Creating a loss function </span> </a> </li> <li class=md-nav__item> <a href=#93-training-our-vit-model class=md-nav__link> <span class=md-ellipsis> 9.3 Training our ViT model </span> </a> </li> <li class=md-nav__item> <a href=#94-what-our-training-setup-is-missing class=md-nav__link> <span class=md-ellipsis> 9.4 What our training setup is missing </span> </a> </li> <li class=md-nav__item> <a href=#95-plot-the-loss-curves-of-our-vit-model class=md-nav__link> <span class=md-ellipsis> 9.5 Plot the loss curves of our ViT model </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#10-using-a-pretrained-vit-from-torchvisionmodels-on-the-same-dataset class=md-nav__link> <span class=md-ellipsis> 10. Using a pretrained ViT from torchvision.models on the same dataset </span> </a> <nav class=md-nav aria-label="10. Using a pretrained ViT from torchvision.models on the same dataset"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#101-why-use-a-pretrained-model class=md-nav__link> <span class=md-ellipsis> 10.1 Why use a pretrained model? </span> </a> </li> <li class=md-nav__item> <a href=#102-getting-a-pretrained-vit-model-and-creating-a-feature-extractor class=md-nav__link> <span class=md-ellipsis> 10.2 Getting a pretrained ViT model and creating a feature extractor </span> </a> </li> <li class=md-nav__item> <a href=#103-preparing-data-for-the-pretrained-vit-model class=md-nav__link> <span class=md-ellipsis> 10.3 Preparing data for the pretrained ViT model </span> </a> </li> <li class=md-nav__item> <a href=#104-train-feature-extractor-vit-model class=md-nav__link> <span class=md-ellipsis> 10.4 Train feature extractor ViT model </span> </a> </li> <li class=md-nav__item> <a href=#105-plot-feature-extractor-vit-model-loss-curves class=md-nav__link> <span class=md-ellipsis> 10.5 Plot feature extractor ViT model loss curves </span> </a> </li> <li class=md-nav__item> <a href=#106-save-feature-extractor-vit-model-and-check-file-size class=md-nav__link> <span class=md-ellipsis> 10.6 Save feature extractor ViT model and check file size </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#11-make-predictions-on-a-custom-image class=md-nav__link> <span class=md-ellipsis> 11. Make predictions on a custom image </span> </a> </li> <li class=md-nav__item> <a href=#main-takeaways class=md-nav__link> <span class=md-ellipsis> Main takeaways </span> </a> </li> <li class=md-nav__item> <a href=#exercises class=md-nav__link> <span class=md-ellipsis> Exercises </span> </a> </li> <li class=md-nav__item> <a href=#extra-curriculum class=md-nav__link> <span class=md-ellipsis> Extra-curriculum </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../08_pytorch_paper_replicating.pdf class=md-nav__link> <span class=md-ellipsis> 8 Paper replicating (pdf) </span> </a> </li> <li class=md-nav__item> <a href=../09_pytorch_model_deployment.pdf class=md-nav__link> <span class=md-ellipsis> 9 Model deployment(pdf) </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_4> <label class=md-nav__link for=__nav_2_4 id=__nav_2_4_label tabindex=0> <span class=md-ellipsis> Tensorflow </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_4_label aria-expanded=false> <label class=md-nav__title for=__nav_2_4> <span class="md-nav__icon md-icon"></span> Tensorflow </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Tensorflow/00_tensorflow_fundamentals/ class=md-nav__link> <span class=md-ellipsis> 0 Tensorflow fundamentals </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/01_neural_network_regression_in_tensorflow/ class=md-nav__link> <span class=md-ellipsis> 1 Neural network regression </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/02_neural_network_classification_in_tensorflow/ class=md-nav__link> <span class=md-ellipsis> 2 Neural network classification </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/04_transfer_learning_in_tensorflow_part_1_feature_extraction/ class=md-nav__link> <span class=md-ellipsis> 4 Transfer learning </span> </a> </li> <li class=md-nav__item> <a href=../../Tensorflow/10_time_series_forecasting_in_tensorflow/ class=md-nav__link> <span class=md-ellipsis> 10 Time series forecasting </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../OOP_Practice/ class=md-nav__link> <span class=md-ellipsis> OOP Practice </span> </a> </li> <li class=md-nav__item> <a href=../../Visualization/ class=md-nav__link> <span class=md-ellipsis> Visualization </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Môn học </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Môn học </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3_1> <label class=md-nav__link for=__nav_3_1 id=__nav_3_1_label tabindex=0> <span class=md-ellipsis> Xác suất thống kê </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_3_1_label aria-expanded=false> <label class=md-nav__title for=__nav_3_1> <span class="md-nav__icon md-icon"></span> Xác suất thống kê </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Subject/XSTK/Exercise2/homework/ class=md-nav__link> <span class=md-ellipsis> Bài tập về nhà buổi 2 </span> </a> </li> <li class=md-nav__item> <a href=../../../Subject/XSTK/Exercise3/homework/ class=md-nav__link> <span class=md-ellipsis> Bài tập về nhà buổi 3 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> CP-Problem </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> CP-Problem </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/general/ class=md-nav__link> <span class=md-ellipsis> General </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2> <label class=md-nav__link for=__nav_4_2 id=__nav_4_2_label tabindex=0> <span class=md-ellipsis> COCI 2006 2007 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_2_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2> <span class="md-nav__icon md-icon"></span> COCI 2006 2007 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Overview/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_2> <label class=md-nav__link for=__nav_4_2_2 id=__nav_4_2_2_label tabindex=0> <span class=md-ellipsis> Contest 1 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_2_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_2> <span class="md-nav__icon md-icon"></span> Contest 1 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P1_MODULO/ class=md-nav__link> <span class=md-ellipsis> MODULO </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P2_HERMAN/ class=md-nav__link> <span class=md-ellipsis> HERMAN </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P3_OKVIRI/ class=md-nav__link> <span class=md-ellipsis> OKVIRI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P4_SLIKAR/ class=md-nav__link> <span class=md-ellipsis> SLIKAR </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P5_BOND/ class=md-nav__link> <span class=md-ellipsis> BOND </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest1/P6_DEBUG/ class=md-nav__link> <span class=md-ellipsis> DEBUG </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_3> <label class=md-nav__link for=__nav_4_2_3 id=__nav_4_2_3_label tabindex=0> <span class=md-ellipsis> Contest 2 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_3> <span class="md-nav__icon md-icon"></span> Contest 2 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P1_R2/ class=md-nav__link> <span class=md-ellipsis> R2 </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P2_ABC/ class=md-nav__link> <span class=md-ellipsis> ABC </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P3_KOLONE/ class=md-nav__link> <span class=md-ellipsis> KOLONE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P4_SJECISTA/ class=md-nav__link> <span class=md-ellipsis> SJECISTA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P5_STOL/ class=md-nav__link> <span class=md-ellipsis> STOL </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest2/P6_STRAZA/ class=md-nav__link> <span class=md-ellipsis> STRAZA </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_4> <label class=md-nav__link for=__nav_4_2_4 id=__nav_4_2_4_label tabindex=0> <span class=md-ellipsis> Contest 3 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_4> <span class="md-nav__icon md-icon"></span> Contest 3 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P1_PATULJCI/ class=md-nav__link> <span class=md-ellipsis> PATULJCI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P2_NPUZZLE/ class=md-nav__link> <span class=md-ellipsis> NPUZZLE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P3_TROJKE/ class=md-nav__link> <span class=md-ellipsis> TROJKE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P4_TENKICI/ class=md-nav__link> <span class=md-ellipsis> TENKICI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P5_BICIKLI/ class=md-nav__link> <span class=md-ellipsis> BICIKLI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest3/P6_LISTA/ class=md-nav__link> <span class=md-ellipsis> LISTA </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_5> <label class=md-nav__link for=__nav_4_2_5 id=__nav_4_2_5_label tabindex=0> <span class=md-ellipsis> Contest 4 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_5_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_5> <span class="md-nav__icon md-icon"></span> Contest 4 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P1_Sibice/ class=md-nav__link> <span class=md-ellipsis> SIBICE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P2_Skener/ class=md-nav__link> <span class=md-ellipsis> SKENER </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P3_Prsteni/ class=md-nav__link> <span class=md-ellipsis> PRSTENI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P4_Zbrka/ class=md-nav__link> <span class=md-ellipsis> ZBRKA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P5_Jogurt/ class=md-nav__link> <span class=md-ellipsis> JOGURT </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest4/P6_Ispiti/ class=md-nav__link> <span class=md-ellipsis> ISPITI </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_6> <label class=md-nav__link for=__nav_4_2_6 id=__nav_4_2_6_label tabindex=0> <span class=md-ellipsis> Contest 5 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_6_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_6> <span class="md-nav__icon md-icon"></span> Contest 5 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P1_Trik/ class=md-nav__link> <span class=md-ellipsis> TRIK </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P2_Natrij/ class=md-nav__link> <span class=md-ellipsis> NATRIJ </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P3_Tenis/ class=md-nav__link> <span class=md-ellipsis> TENIS </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P4_Liga/ class=md-nav__link> <span class=md-ellipsis> LIGA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P5_Ivana/ class=md-nav__link> <span class=md-ellipsis> IVANA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest5/P6_Dvaput/ class=md-nav__link> <span class=md-ellipsis> DVAPUT </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_7> <label class=md-nav__link for=__nav_4_2_7 id=__nav_4_2_7_label tabindex=0> <span class=md-ellipsis> Contest 6 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_7_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_7> <span class="md-nav__icon md-icon"></span> Contest 6 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P1_PRASE/ class=md-nav__link> <span class=md-ellipsis> PRASE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P2_MAGIJA/ class=md-nav__link> <span class=md-ellipsis> MAGIJA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P3_MARATON/ class=md-nav__link> <span class=md-ellipsis> MARATON </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P4_KAMEN/ class=md-nav__link> <span class=md-ellipsis> KAMEN </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P5_V/ class=md-nav__link> <span class=md-ellipsis> V </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Contest6/P6_PROSTOR/ class=md-nav__link> <span class=md-ellipsis> PROSTOR </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_8> <label class=md-nav__link for=__nav_4_2_8 id=__nav_4_2_8_label tabindex=0> <span class=md-ellipsis> Regional </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_8_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_8> <span class="md-nav__icon md-icon"></span> Regional </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Regional/P1_BARD/ class=md-nav__link> <span class=md-ellipsis> BARD </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Regional/P2_TETRIS/ class=md-nav__link> <span class=md-ellipsis> TETRIS </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Regional/P4_CIRCLE/ class=md-nav__link> <span class=md-ellipsis> CIRCLE </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_2_9> <label class=md-nav__link for=__nav_4_2_9 id=__nav_4_2_9_label tabindex=0> <span class=md-ellipsis> Croatian Olympiad </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_2_9_label aria-expanded=false> <label class=md-nav__title for=__nav_4_2_9> <span class="md-nav__icon md-icon"></span> Croatian Olympiad </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0607/Olympiad/P1_PATRIK/ class=md-nav__link> <span class=md-ellipsis> PATRIK </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Olympiad/P2_POLICIJA/ class=md-nav__link> <span class=md-ellipsis> POLICIJA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0607/Olympiad/P3_SABOR/ class=md-nav__link> <span class=md-ellipsis> SABOR </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3> <label class=md-nav__link for=__nav_4_3 id=__nav_4_3_label tabindex=0> <span class=md-ellipsis> COCI 2007 2008 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3> <span class="md-nav__icon md-icon"></span> COCI 2007 2008 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Overview/ class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3_2> <label class=md-nav__link for=__nav_4_3_2 id=__nav_4_3_2_label tabindex=0> <span class=md-ellipsis> Contest 1 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_3_2_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3_2> <span class="md-nav__icon md-icon"></span> Contest 1 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P1_CETVRTA/ class=md-nav__link> <span class=md-ellipsis> CETVRTA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P2_PEG/ class=md-nav__link> <span class=md-ellipsis> PEG </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P3_PRINOVA/ class=md-nav__link> <span class=md-ellipsis> PRINOVA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P4_ZAPIS/ class=md-nav__link> <span class=md-ellipsis> ZAPIS </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P5_SREDNJI/ class=md-nav__link> <span class=md-ellipsis> SREDNJI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest1/P6_STAZA/ class=md-nav__link> <span class=md-ellipsis> STAZA </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3_3> <label class=md-nav__link for=__nav_4_3_3 id=__nav_4_3_3_label tabindex=0> <span class=md-ellipsis> Contest 4 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_3_3_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3_3> <span class="md-nav__icon md-icon"></span> Contest 4 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P1_CIRCLE/ class=md-nav__link> <span class=md-ellipsis> CIRCLE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P2_VECI/ class=md-nav__link> <span class=md-ellipsis> VECI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P3_LEKTIRA/ class=md-nav__link> <span class=md-ellipsis> LEKTIRA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P4_MUZICARI/ class=md-nav__link> <span class=md-ellipsis> MUZICARI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P5_POKLON/ class=md-nav__link> <span class=md-ellipsis> POKLON </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest4/P6_KOCKE/ class=md-nav__link> <span class=md-ellipsis> KOCKE </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_3_4> <label class=md-nav__link for=__nav_4_3_4 id=__nav_4_3_4_label tabindex=0> <span class=md-ellipsis> Contest 6 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_4_3_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4_3_4> <span class="md-nav__icon md-icon"></span> Contest 6 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P1_PARKING/ class=md-nav__link> <span class=md-ellipsis> PARKING </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P2_SEMAFORI/ class=md-nav__link> <span class=md-ellipsis> SEMAFORI </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P3_GRANICA/ class=md-nav__link> <span class=md-ellipsis> GRANICA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P4_GEORGE/ class=md-nav__link> <span class=md-ellipsis> GEORGE </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P5_PRINCEZA/ class=md-nav__link> <span class=md-ellipsis> PRINCEZA </span> </a> </li> <li class=md-nav__item> <a href=../../../Problem/coci0708/Contest6/P6_CESTARINE/ class=md-nav__link> <span class=md-ellipsis> CESTARINE </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../../other/other/ class=md-nav__link> <span class=md-ellipsis> Other </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#what-is-paper-replicating class=md-nav__link> <span class=md-ellipsis> What is paper replicating? </span> </a> </li> <li class=md-nav__item> <a href=#what-is-a-machine-learning-research-paper class=md-nav__link> <span class=md-ellipsis> What is a machine learning research paper? </span> </a> </li> <li class=md-nav__item> <a href=#why-replicate-a-machine-learning-research-paper class=md-nav__link> <span class=md-ellipsis> Why replicate a machine learning research paper? </span> </a> </li> <li class=md-nav__item> <a href=#where-can-you-find-code-examples-for-machine-learning-research-papers class=md-nav__link> <span class=md-ellipsis> Where can you find code examples for machine learning research papers? </span> </a> </li> <li class=md-nav__item> <a href=#what-were-going-to-cover class=md-nav__link> <span class=md-ellipsis> What we're going to cover </span> </a> </li> <li class=md-nav__item> <a href=#terminology class=md-nav__link> <span class=md-ellipsis> Terminology </span> </a> </li> <li class=md-nav__item> <a href=#where-can-you-get-help class=md-nav__link> <span class=md-ellipsis> Where can you get help? </span> </a> </li> <li class=md-nav__item> <a href=#0-getting-setup class=md-nav__link> <span class=md-ellipsis> 0. Getting setup </span> </a> </li> <li class=md-nav__item> <a href=#1-get-data class=md-nav__link> <span class=md-ellipsis> 1. Get Data </span> </a> </li> <li class=md-nav__item> <a href=#2-create-datasets-and-dataloaders class=md-nav__link> <span class=md-ellipsis> 2. Create Datasets and DataLoaders </span> </a> <nav class=md-nav aria-label="2. Create Datasets and DataLoaders"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-prepare-transforms-for-images class=md-nav__link> <span class=md-ellipsis> 2.1 Prepare transforms for images </span> </a> </li> <li class=md-nav__item> <a href=#22-turn-images-into-dataloaders class=md-nav__link> <span class=md-ellipsis> 2.2 Turn images into DataLoader's </span> </a> </li> <li class=md-nav__item> <a href=#23-visualize-a-single-image class=md-nav__link> <span class=md-ellipsis> 2.3 Visualize a single image </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3-replicating-the-vit-paper-an-overview class=md-nav__link> <span class=md-ellipsis> 3. Replicating the ViT paper: an overview </span> </a> <nav class=md-nav aria-label="3. Replicating the ViT paper: an overview"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-inputs-and-outputs-layers-and-blocks class=md-nav__link> <span class=md-ellipsis> 3.1 Inputs and outputs, layers and blocks </span> </a> </li> <li class=md-nav__item> <a href=#32-getting-specific-whats-vit-made-of class=md-nav__link> <span class=md-ellipsis> 3.2 Getting specific: What's ViT made of? </span> </a> <nav class=md-nav aria-label="3.2 Getting specific: What's ViT made of?"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#321-exploring-figure-1 class=md-nav__link> <span class=md-ellipsis> 3.2.1 Exploring Figure 1 </span> </a> </li> <li class=md-nav__item> <a href=#322-exploring-the-four-equations class=md-nav__link> <span class=md-ellipsis> 3.2.2 Exploring the Four Equations </span> </a> </li> <li class=md-nav__item> <a href=#323-equation-1-overview class=md-nav__link> <span class=md-ellipsis> 3.2.3 Equation 1 overview </span> </a> </li> <li class=md-nav__item> <a href=#324-equation-2-overview class=md-nav__link> <span class=md-ellipsis> 3.2.4 Equation 2 overview </span> </a> </li> <li class=md-nav__item> <a href=#325-equation-3-overview class=md-nav__link> <span class=md-ellipsis> 3.2.5 Equation 3 overview </span> </a> </li> <li class=md-nav__item> <a href=#326-equation-4-overview class=md-nav__link> <span class=md-ellipsis> 3.2.6 Equation 4 overview </span> </a> </li> <li class=md-nav__item> <a href=#327-exploring-table-1 class=md-nav__link> <span class=md-ellipsis> 3.2.7 Exploring Table 1 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#33-my-workflow-for-replicating-papers class=md-nav__link> <span class=md-ellipsis> 3.3 My workflow for replicating papers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-equation-1-split-data-into-patches-and-creating-the-class-position-and-patch-embedding class=md-nav__link> <span class=md-ellipsis> 4. Equation 1: Split data into patches and creating the class, position and patch embedding </span> </a> <nav class=md-nav aria-label="4. Equation 1: Split data into patches and creating the class, position and patch embedding"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#41-calculating-patch-embedding-input-and-output-shapes-by-hand class=md-nav__link> <span class=md-ellipsis> 4.1 Calculating patch embedding input and output shapes by hand </span> </a> </li> <li class=md-nav__item> <a href=#42-turning-a-single-image-into-patches class=md-nav__link> <span class=md-ellipsis> 4.2 Turning a single image into patches </span> </a> </li> <li class=md-nav__item> <a href=#43-creating-image-patches-with-torchnnconv2d class=md-nav__link> <span class=md-ellipsis> 4.3 Creating image patches with torch.nn.Conv2d() </span> </a> </li> <li class=md-nav__item> <a href=#44-flattening-the-patch-embedding-with-torchnnflatten class=md-nav__link> <span class=md-ellipsis> 4.4 Flattening the patch embedding with torch.nn.Flatten() </span> </a> </li> <li class=md-nav__item> <a href=#45-turning-the-vit-patch-embedding-layer-into-a-pytorch-module class=md-nav__link> <span class=md-ellipsis> 4.5 Turning the ViT patch embedding layer into a PyTorch module </span> </a> </li> <li class=md-nav__item> <a href=#46-creating-the-class-token-embedding class=md-nav__link> <span class=md-ellipsis> 4.6 Creating the class token embedding </span> </a> </li> <li class=md-nav__item> <a href=#47-creating-the-position-embedding class=md-nav__link> <span class=md-ellipsis> 4.7 Creating the position embedding </span> </a> </li> <li class=md-nav__item> <a href=#48-putting-it-all-together-from-image-to-embedding class=md-nav__link> <span class=md-ellipsis> 4.8 Putting it all together: from image to embedding </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5-equation-2-multi-head-attention-msa class=md-nav__link> <span class=md-ellipsis> 5. Equation 2: Multi-Head Attention (MSA) </span> </a> <nav class=md-nav aria-label="5. Equation 2: Multi-Head Attention (MSA)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-the-layernorm-ln-layer class=md-nav__link> <span class=md-ellipsis> 5.1 The LayerNorm (LN) layer </span> </a> </li> <li class=md-nav__item> <a href=#52-the-multi-head-self-attention-msa-layer class=md-nav__link> <span class=md-ellipsis> 5.2 The Multi-Head Self Attention (MSA) layer </span> </a> </li> <li class=md-nav__item> <a href=#53-replicating-equation-2-with-pytorch-layers class=md-nav__link> <span class=md-ellipsis> 5.3 Replicating Equation 2 with PyTorch layers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6-equation-3-multilayer-perceptron-mlp class=md-nav__link> <span class=md-ellipsis> 6. Equation 3: Multilayer Perceptron (MLP) </span> </a> <nav class=md-nav aria-label="6. Equation 3: Multilayer Perceptron (MLP)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#61-the-mlp-layers class=md-nav__link> <span class=md-ellipsis> 6.1 The MLP layer(s) </span> </a> </li> <li class=md-nav__item> <a href=#62-replicating-equation-3-with-pytorch-layers class=md-nav__link> <span class=md-ellipsis> 6.2 Replicating Equation 3 with PyTorch layers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#7-create-the-transformer-encoder class=md-nav__link> <span class=md-ellipsis> 7. Create the Transformer Encoder </span> </a> <nav class=md-nav aria-label="7. Create the Transformer Encoder"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#71-creating-a-transformer-encoder-by-combining-our-custom-made-layers class=md-nav__link> <span class=md-ellipsis> 7.1 Creating a Transformer Encoder by combining our custom made layers </span> </a> </li> <li class=md-nav__item> <a href=#72-creating-a-transformer-encoder-with-pytorchs-transformer-layers class=md-nav__link> <span class=md-ellipsis> 7.2 Creating a Transformer Encoder with PyTorch's Transformer layers </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#8-putting-it-all-together-to-create-vit class=md-nav__link> <span class=md-ellipsis> 8. Putting it all together to create ViT </span> </a> <nav class=md-nav aria-label="8. Putting it all together to create ViT"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#81-getting-a-visual-summary-of-our-vit-model class=md-nav__link> <span class=md-ellipsis> 8.1 Getting a visual summary of our ViT model </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#9-setting-up-training-code-for-our-vit-model class=md-nav__link> <span class=md-ellipsis> 9. Setting up training code for our ViT model </span> </a> <nav class=md-nav aria-label="9. Setting up training code for our ViT model"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#91-creating-an-optimizer class=md-nav__link> <span class=md-ellipsis> 9.1 Creating an optimizer </span> </a> </li> <li class=md-nav__item> <a href=#92-creating-a-loss-function class=md-nav__link> <span class=md-ellipsis> 9.2 Creating a loss function </span> </a> </li> <li class=md-nav__item> <a href=#93-training-our-vit-model class=md-nav__link> <span class=md-ellipsis> 9.3 Training our ViT model </span> </a> </li> <li class=md-nav__item> <a href=#94-what-our-training-setup-is-missing class=md-nav__link> <span class=md-ellipsis> 9.4 What our training setup is missing </span> </a> </li> <li class=md-nav__item> <a href=#95-plot-the-loss-curves-of-our-vit-model class=md-nav__link> <span class=md-ellipsis> 9.5 Plot the loss curves of our ViT model </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#10-using-a-pretrained-vit-from-torchvisionmodels-on-the-same-dataset class=md-nav__link> <span class=md-ellipsis> 10. Using a pretrained ViT from torchvision.models on the same dataset </span> </a> <nav class=md-nav aria-label="10. Using a pretrained ViT from torchvision.models on the same dataset"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#101-why-use-a-pretrained-model class=md-nav__link> <span class=md-ellipsis> 10.1 Why use a pretrained model? </span> </a> </li> <li class=md-nav__item> <a href=#102-getting-a-pretrained-vit-model-and-creating-a-feature-extractor class=md-nav__link> <span class=md-ellipsis> 10.2 Getting a pretrained ViT model and creating a feature extractor </span> </a> </li> <li class=md-nav__item> <a href=#103-preparing-data-for-the-pretrained-vit-model class=md-nav__link> <span class=md-ellipsis> 10.3 Preparing data for the pretrained ViT model </span> </a> </li> <li class=md-nav__item> <a href=#104-train-feature-extractor-vit-model class=md-nav__link> <span class=md-ellipsis> 10.4 Train feature extractor ViT model </span> </a> </li> <li class=md-nav__item> <a href=#105-plot-feature-extractor-vit-model-loss-curves class=md-nav__link> <span class=md-ellipsis> 10.5 Plot feature extractor ViT model loss curves </span> </a> </li> <li class=md-nav__item> <a href=#106-save-feature-extractor-vit-model-and-check-file-size class=md-nav__link> <span class=md-ellipsis> 10.6 Save feature extractor ViT model and check file size </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#11-make-predictions-on-a-custom-image class=md-nav__link> <span class=md-ellipsis> 11. Make predictions on a custom image </span> </a> </li> <li class=md-nav__item> <a href=#main-takeaways class=md-nav__link> <span class=md-ellipsis> Main takeaways </span> </a> </li> <li class=md-nav__item> <a href=#exercises class=md-nav__link> <span class=md-ellipsis> Exercises </span> </a> </li> <li class=md-nav__item> <a href=#extra-curriculum class=md-nav__link> <span class=md-ellipsis> Extra-curriculum </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p><a href=https://colab.research.google.com/github/mrdbourke/pytorch-deep-learning/blob/main/08_pytorch_paper_replicating.ipynb target=_parent><img src=https://colab.research.google.com/assets/colab-badge.svg alt="Open In Colab"></a></p> <p><a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/08_pytorch_paper_replicating.ipynb>View Source Code</a> | <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/slides/08_pytorch_paper_replicating.pdf>View Slides</a></p> <h1 id=08-pytorch-paper-replicating>08. PyTorch Paper Replicating</h1> <p>Welcome to Milestone Project 2: PyTorch Paper Replicating!</p> <p>In this project, we're going to be <strong>replicating a machine learning research paper</strong> and creating a Vision Transformer (ViT) from scratch using PyTorch.</p> <p>We'll then see how ViT, a state-of-the-art computer vision architecture, performs on our FoodVision Mini problem.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-applying-vit-to-food-vision-mini.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-applying-vit-to-food-vision-mini.png width=900/ alt="appyling the vision transformer architecture to FoodVision mini"></a></p> <p><em>For Milestone Project 2 we're going to focus on recreating the Vision Transformer (ViT) computer vision architecture and applying it to our FoodVision Mini problem to classify different images of pizza, steak and sushi.</em></p> <h2 id=what-is-paper-replicating>What is paper replicating?</h2> <p>It's no secret machine learning is advancing fast.</p> <p>Many of these advances get published in machine learning research papers.</p> <p>And the goal of <strong>paper replicating</strong> is to replicate these advances with code so you can use the techniques for your own problem.</p> <p>For example, let's say a new model architecture gets released that performs better than any other architecture before on various benchmarks, wouldn't it be nice to try that architecture on your own problems?</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-what-is-paper-replicating-images-math-text-to-code.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-what-is-paper-replicating-images-math-text-to-code.png width=1000/ alt="paper replicating involves turning a machine learning reserch paper comprised of images/diagrams, text and math into usable code"></a></p> <p><em>Machine learning paper replicating involves turning a machine learning paper comprised of images/diagrams, math and text into usable code and in our case, usable PyTorch code. Diagram, math equations and text from the <a href=https://arxiv.org/abs/2010.11929>ViT paper</a>.</em></p> <h2 id=what-is-a-machine-learning-research-paper>What is a machine learning research paper?</h2> <p>A machine learning research paper is a scientific paper that details findings of a research group on a specific area.</p> <p>The contents of a machine learning research paper can vary from paper to paper but they generally follow the structure:</p> <table> <thead> <tr> <th><strong>Section</strong></th> <th><strong>Contents</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Abstract</strong></td> <td>An overview/summary of the paper's main findings/contributions.</td> </tr> <tr> <td><strong>Introduction</strong></td> <td>What's the paper's main problem and details of previous methods used to try and solve it.</td> </tr> <tr> <td><strong>Method</strong></td> <td>How did the researchers go about conducting their research? For example, what model(s), data sources, training setups were used?</td> </tr> <tr> <td><strong>Results</strong></td> <td>What are the outcomes of the paper? If a new type of model or training setup was used, how did the results of findings compare to previous works? (this is where <strong>experiment tracking</strong> comes in handy)</td> </tr> <tr> <td><strong>Conclusion</strong></td> <td>What are the limitations of the suggested methods? What are some next steps for the research community?</td> </tr> <tr> <td><strong>References</strong></td> <td>What resources/other papers did the researchers look at to build their own body of work?</td> </tr> <tr> <td><strong>Appendix</strong></td> <td>Are there any extra resources/findings to look at that weren't included in any of the above sections?</td> </tr> </tbody> </table> <h2 id=why-replicate-a-machine-learning-research-paper>Why replicate a machine learning research paper?</h2> <p>A machine learning research paper is often a presentation of months of work and experiments done by some of the best machine learning teams in the world condensed into a few pages of text.</p> <p>And if these experiments lead to better results in an area related to the problem you're working on, it'd be nice to check them out.</p> <p>Also, replicating the work of others is a fantastic way to practice your skills.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-george-hotz-quote.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-george-hotz-quote.png width=600 alt="george hotz quote saying to get better at being a machine learning engineer, download a paper, implement it and keep going until you have skills"></a></p> <p><em>George Hotz is founder of <a href=https://comma.ai/ >comma.ai</a>, a self-driving car company and livestreams machine learning coding on <a href=https://www.twitch.tv/georgehotz>Twitch</a> and those videos get posted in full to <a href=https://www.youtube.com/c/georgehotzarchive>YouTube</a>. I pulled this quote from one of his livestreams. The "٭" is to note that machine learning engineering often involves the extra step(s) of preprocessing data and making your models available for others to use (deployment).</em></p> <p>When you first start trying to replicate research papers, you'll likely be overwhelmed.</p> <p>That's normal.</p> <p>Research teams spend weeks, months and sometimes years creating these works so it makes sense if it takes you sometime to even read let alone reproduce the works.</p> <p>Replicating research is such a tough problem, phenomenal machine learning libraries and tools such as, <a href=https://huggingface.co/ >HuggingFace</a>, <a href=https://github.com/rwightman/pytorch-image-models>PyTorch Image Models</a> (<code>timm</code> library) and <a href=https://www.fast.ai/ >fast.ai</a> have been born out of making machine learning research more accessible.</p> <h2 id=where-can-you-find-code-examples-for-machine-learning-research-papers>Where can you find code examples for machine learning research papers?</h2> <p>One of the first things you'll notice when it comes to machine learning research is: there's a lot of it.</p> <p>So beware, trying to stay on top of it is like trying to outrun a hamster wheel.</p> <p>Follow your interest, pick a few things that stand out to you.</p> <p>In saying this, there are several places to find and read machine learning research papers (and code):</p> <table> <thead> <tr> <th><strong>Resource</strong></th> <th><strong>What is it?</strong></th> </tr> </thead> <tbody> <tr> <td><a href=https://arxiv.org/ >arXiv</a></td> <td>Pronounced "archive", arXiv is a free and open resource for reading technical articles on everything from physics to computer science (inlcuding machine learning).</td> </tr> <tr> <td><a href=https://twitter.com/_akhaliq>AK Twitter</a></td> <td>The AK Twitter account publishes machine learning research highlights, often with live demos almost every day. I don't understand 9/10 posts but I find it fun to explore every so often.</td> </tr> <tr> <td><a href=https://paperswithcode.com/ >Papers with Code</a></td> <td>A curated collection of trending, active and greatest machine learning papers, many of which include code resources attached. Also includes a collection of common machine learning datasets, benchmarks and current state-of-the-art models.</td> </tr> <tr> <td><a href=https://github.com/lucidrains/vit-pytorch>lucidrains' <code>vit-pytorch</code> GitHub repository</a></td> <td>Less of a place to find research papers and more of an example of what paper replicating with code on a larger-scale and with a specific focus looks like. The <code>vit-pytorch</code> repository is a collection of Vision Transformer model architectures from various research papers replicated with PyTorch code (much of the inspiration for this notebook was gathered from this repository).</td> </tr> </tbody> </table> <blockquote> <p><strong>Note:</strong> This list is far from exhaustive. I only list a few places, the ones I use most frequently personally. So beware the bias. However, I've noticed that even this short list often sully satisfies my needs for knowing what's going on in the field. Any more and I might go crazy.</p> </blockquote> <h2 id=what-were-going-to-cover>What we're going to cover</h2> <p>Rather than talk about replicating a paper, we're going to get hands-on and <em>actually</em> replicate a paper.</p> <p>The process for replicating all papers will be slightly different but by seeing what it's like to do one, we'll get the momentum to do more.</p> <p>More specifically, we're going to be replicating the machine learning research paper <a href=https://arxiv.org/abs/2010.11929><em>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</em></a> (ViT paper) with PyTorch.</p> <p>The Transformer neural network architecture was originally introduced in the machine learning research paper <a href=https://arxiv.org/abs/1706.03762><em>Attention is all you need</em></a>.</p> <p>And the original Transformer architecture was designed to work on one-dimensional (1D) sequences of text.</p> <p>A <strong>Transformer architecture</strong> is generally considered to be any neural network that uses the <a href=https://en.wikipedia.org/wiki/Attention_(machine_learning)><strong>attention mechanism</strong></a> as its primary learning layer. Similar to a how a convolutional neural network (CNN) uses convolutions as its primary learning layer.</p> <p>Like the name suggests, <strong>the Vision Transformer (ViT) architecture was designed to adapt the original Transformer architecture to vision problem(s)</strong> (classification being the first and since many others have followed).</p> <p>The original Vision Transformer has been through several iterations over the past couple of years, however, we're going to focus on replicating the original, otherwise known as the "vanilla Vision Transformer". Because if you can recreate the original, you can adapt to the others.</p> <p>We're going to be focusing on building the ViT architecture as per the original ViT paper and applying it to FoodVision Mini.</p> <table> <thead> <tr> <th><strong>Topic</strong></th> <th><strong>Contents</strong></th> </tr> </thead> <tbody> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#0-getting-setup>0. Getting setup</a></strong></td> <td>We've written a fair bit of useful code over the past few sections, let's download it and make sure we can use it again.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#1-get-data>1. Get data</a></strong></td> <td>Let's get the pizza, steak and sushi image classification dataset we've been using and build a Vision Transformer to try and improve FoodVision Mini model's results.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#2-create-datasets-and-dataloaders>2. Create Datasets and DataLoaders</a></strong></td> <td>We'll use the <code>data_setup.py</code> script we wrote in chapter 05. PyTorch Going Modular to setup our DataLoaders.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#3-replicating-the-vit-paper-an-overview>3. Replicating the ViT paper: an overview</a></strong></td> <td>Replicating a machine learning research paper can be bit a fair challenge, so before we jump in, let's break the ViT paper down into smaller chunks, so we can replicate the paper chunk by chunk.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#4-equation-1-split-data-into-patches-and-creating-the-class-position-and-patch-embedding>4. Equation 1: The Patch Embedding</a></strong></td> <td>The ViT architecture is comprised of four main equations, the first being the patch and position embedding. Or turning an image into a sequence of learnable patches.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#5-equation-2-multi-head-attention-msa>5. Equation 2: Multi-Head Attention (MSA)</a></strong></td> <td>The self-attention/multi-head self-attention (MSA) mechanism is at the heart of every Transformer architecture, including the ViT architecture, let's create an MSA block using PyTorch's in-built layers.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#6-equation-3-multilayer-perceptron-mlp>6. Equation 3: Multilayer Perceptron (MLP)</a></strong></td> <td>The ViT architecture uses a multilayer perceptron as part of its Transformer Encoder and for its output layer. Let's start by creating an MLP for the Transformer Encoder.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#7-create-the-transformer-encoder>7. Creating the Transformer Encoder</a></strong></td> <td>A Transformer Encoder is typically comprised of alternating layers of MSA (equation 2) and MLP (equation 3) joined together via residual connections. Let's create one by stacking the layers we created in sections 5 &amp; 6 on top of each other.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#8-putting-it-all-together-to-create-vit>8. Putting it all together to create ViT</a></strong></td> <td>We've got all the pieces of the puzzle to create the ViT architecture, let's put them all together into a single class we can call as our model.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#9-setting-up-training-code-for-our-vit-model>9. Setting up training code for our ViT model</a></strong></td> <td>Training our custom ViT implementation is similar to all of the other model's we've trained previously. And thanks to our <code>train()</code> function in <code>engine.py</code> we can start training with a few lines of code.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#10-using-a-pretrained-vit-from-torchvisionmodels-on-the-same-dataset>10. Using a pretrained ViT from <code>torchvision.models</code></a></strong></td> <td>Training a large model like ViT usually takes a fair amount of data. Since we're only working with a small amount of pizza, steak and sushi images, let's see if we can leverage the power of transfer learning to improve our performance.</td> </tr> <tr> <td><strong><a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#11-make-predictions-on-a-custom-image>11. Make predictions on a custom image</a></strong></td> <td>The magic of machine learning is seeing it work on your own data, so let's take our best performing model and put FoodVision Mini to the test on the infamous <em>pizza-dad</em> image (a photo of my dad eating pizza).</td> </tr> </tbody> </table> <blockquote> <p><strong>Note:</strong> Despite the fact we're going to be focused on replicating the ViT paper, avoid getting too bogged down on a particular paper as newer better methods will often come along, quickly, so the skill should be to remain curious whilst building the fundamental skills of turning math and words on a page into working code.</p> </blockquote> <h2 id=terminology>Terminology</h2> <p>There are going to be a fair few acronyms throughout this notebook.</p> <p>In light of this, here are some definitions: * <strong>ViT</strong> - Stands for Vision Transformer (the main neural network architecture we're going to be focused on replicating). * <strong>ViT paper</strong> - Short hand for the original machine learning research paper that introduced the ViT architecture, <a href=https://arxiv.org/abs/2010.11929><em>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</em></a>, anytime <em>ViT paper</em> is mentioned, you can be assured it is referencing this paper.</p> <h2 id=where-can-you-get-help>Where can you get help?</h2> <p>All of the materials for this course <a href=https://github.com/mrdbourke/pytorch-deep-learning>are available on GitHub</a>.</p> <p>If you run into trouble, you can ask a question on the course <a href=https://github.com/mrdbourke/pytorch-deep-learning/discussions>GitHub Discussions page</a>.</p> <p>And of course, there's the <a href=https://pytorch.org/docs/stable/index.html>PyTorch documentation</a> and <a href=https://discuss.pytorch.org/ >PyTorch developer forums</a>, a very helpful place for all things PyTorch.</p> <h2 id=0-getting-setup>0. Getting setup</h2> <p>As we've done previously, let's make sure we've got all of the modules we'll need for this section.</p> <p>We'll import the Python scripts (such as <code>data_setup.py</code> and <code>engine.py</code>) we created in <a href=https://www.learnpytorch.io/05_pytorch_going_modular/ >05. PyTorch Going Modular</a>.</p> <p>To do so, we'll download <a href=https://github.com/mrdbourke/pytorch-deep-learning/tree/main/going_modular><code>going_modular</code></a> directory from the <code>pytorch-deep-learning</code> repository (if we don't already have it).</p> <p>We'll also get the <a href=https://github.com/TylerYep/torchinfo><code>torchinfo</code></a> package if it's not available.</p> <p><code>torchinfo</code> will help later on to give us a visual representation of our model.</p> <p>And since later on we'll be using <code>torchvision</code> v0.13 package (available as of July 2022), we'll make sure we've got the latest versions.</p> <div class=highlight><pre><span></span><code><span class=c1># For this notebook to run with updated APIs, we need torch 1.12+ and torchvision 0.13+</span>
<span class=k>try</span><span class=p>:</span>
    <span class=kn>import</span><span class=w> </span><span class=nn>torch</span>
    <span class=kn>import</span><span class=w> </span><span class=nn>torchvision</span>
    <span class=k>assert</span> <span class=nb>int</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>__version__</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&quot;.&quot;</span><span class=p>)[</span><span class=mi>1</span><span class=p>])</span> <span class=o>&gt;=</span> <span class=mi>12</span> <span class=ow>or</span> <span class=nb>int</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>__version__</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&quot;.&quot;</span><span class=p>)[</span><span class=mi>0</span><span class=p>])</span> <span class=o>==</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;torch version should be 1.12+&quot;</span>
    <span class=k>assert</span> <span class=nb>int</span><span class=p>(</span><span class=n>torchvision</span><span class=o>.</span><span class=n>__version__</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&quot;.&quot;</span><span class=p>)[</span><span class=mi>1</span><span class=p>])</span> <span class=o>&gt;=</span> <span class=mi>13</span><span class=p>,</span> <span class=s2>&quot;torchvision version should be 0.13+&quot;</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;torch version: </span><span class=si>{</span><span class=n>torch</span><span class=o>.</span><span class=n>__version__</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;torchvision version: </span><span class=si>{</span><span class=n>torchvision</span><span class=o>.</span><span class=n>__version__</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=k>except</span><span class=p>:</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;[INFO] torch/torchvision versions not as required, installing nightly versions.&quot;</span><span class=p>)</span>
    <span class=err>!</span><span class=n>pip3</span> <span class=n>install</span> <span class=o>-</span><span class=n>U</span> <span class=n>torch</span> <span class=n>torchvision</span> <span class=n>torchaudio</span> <span class=o>--</span><span class=n>index</span><span class=o>-</span><span class=n>url</span> <span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>download</span><span class=o>.</span><span class=n>pytorch</span><span class=o>.</span><span class=n>org</span><span class=o>/</span><span class=n>whl</span><span class=o>/</span><span class=n>cu118</span>
    <span class=kn>import</span><span class=w> </span><span class=nn>torch</span>
    <span class=kn>import</span><span class=w> </span><span class=nn>torchvision</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;torch version: </span><span class=si>{</span><span class=n>torch</span><span class=o>.</span><span class=n>__version__</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;torchvision version: </span><span class=si>{</span><span class=n>torchvision</span><span class=o>.</span><span class=n>__version__</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>/home/jupyter-trunglph/.conda/envs/Multimodal_RumorDetection/lib/python3.8/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html
  from .autonotebook import tqdm as notebook_tqdm


torch version: 2.2.2
torchvision version: 0.17.2
</code></pre></div> <blockquote> <p><strong>Note:</strong> If you're using Google Colab and the cell above starts to install various software packages, you may have to restart your runtime after running the above cell. After restarting, you can run the cell again and verify you've got the right versions of <code>torch</code> and <code>torchvision</code>.</p> </blockquote> <p>Now we'll continue with the regular imports, setting up device agnostic code and this time we'll also get the <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/helper_functions.py><code>helper_functions.py</code></a> script from GitHub.</p> <p>The <code>helper_functions.py</code> script contains several functions we created in previous sections: * <code>set_seeds()</code> to set the random seeds (created in <a href=https://www.learnpytorch.io/07_pytorch_experiment_tracking/#create-a-helper-function-to-set-seeds>07. PyTorch Experiment Tracking section 0</a>). * <code>download_data()</code> to download a data source given a link (created in <a href=https://www.learnpytorch.io/07_pytorch_experiment_tracking/#1-get-data>07. PyTorch Experiment Tracking section 1</a>). * <code>plot_loss_curves()</code> to inspect our model's training results (created in <a href=https://www.learnpytorch.io/04_pytorch_custom_datasets/#78-plot-the-loss-curves-of-model-0>04. PyTorch Custom Datasets section 7.8</a>)</p> <blockquote> <p><strong>Note:</strong> It may be a better idea for many of the functions in the <code>helper_functions.py</code> script to be merged into <code>going_modular/going_modular/utils.py</code>, perhaps that's an extension you'd like to try.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># Continue with regular imports</span>
<span class=kn>import</span><span class=w> </span><span class=nn>matplotlib.pyplot</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>plt</span>
<span class=kn>import</span><span class=w> </span><span class=nn>torch</span>
<span class=kn>import</span><span class=w> </span><span class=nn>torchvision</span>

<span class=kn>from</span><span class=w> </span><span class=nn>torch</span><span class=w> </span><span class=kn>import</span> <span class=n>nn</span>
<span class=kn>from</span><span class=w> </span><span class=nn>torchvision</span><span class=w> </span><span class=kn>import</span> <span class=n>transforms</span>

<span class=c1># Try to get torchinfo, install it if it doesn&#39;t work</span>
<span class=k>try</span><span class=p>:</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>torchinfo</span><span class=w> </span><span class=kn>import</span> <span class=n>summary</span>
<span class=k>except</span><span class=p>:</span>
    <span class=nb>print</span><span class=p>(</span><span class=s2>&quot;[INFO] Couldn&#39;t find torchinfo... installing it.&quot;</span><span class=p>)</span>
    <span class=err>!</span><span class=n>pip</span> <span class=n>install</span> <span class=o>-</span><span class=n>q</span> <span class=n>torchinfo</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>torchinfo</span><span class=w> </span><span class=kn>import</span> <span class=n>summary</span>

<span class=c1># Try to import the going_modular directory, download it from GitHub if it doesn&#39;t work</span>
<span class=k>try</span><span class=p>:</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>going_modular.going_modular</span><span class=w> </span><span class=kn>import</span> <span class=n>data_setup</span><span class=p>,</span> <span class=n>engine</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>helper_functions</span><span class=w> </span><span class=kn>import</span> <span class=n>download_data</span><span class=p>,</span> <span class=n>set_seeds</span><span class=p>,</span> <span class=n>plot_loss_curves</span>
<span class=k>except</span><span class=p>:</span>
    <span class=c1># Get the going_modular scripts</span>
    <span class=nb>print</span><span class=p>(</span><span class=s2>&quot;[INFO] Couldn&#39;t find going_modular or helper_functions scripts... downloading them from GitHub.&quot;</span><span class=p>)</span>
    <span class=err>!</span><span class=n>git</span> <span class=n>clone</span> <span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>github</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>mrdbourke</span><span class=o>/</span><span class=n>pytorch</span><span class=o>-</span><span class=n>deep</span><span class=o>-</span><span class=n>learning</span>
    <span class=err>!</span><span class=n>mv</span> <span class=n>pytorch</span><span class=o>-</span><span class=n>deep</span><span class=o>-</span><span class=n>learning</span><span class=o>/</span><span class=n>going_modular</span> <span class=o>.</span>
    <span class=err>!</span><span class=n>mv</span> <span class=n>pytorch</span><span class=o>-</span><span class=n>deep</span><span class=o>-</span><span class=n>learning</span><span class=o>/</span><span class=n>helper_functions</span><span class=o>.</span><span class=n>py</span> <span class=o>.</span> <span class=c1># get the helper_functions.py script</span>
    <span class=err>!</span><span class=n>rm</span> <span class=o>-</span><span class=n>rf</span> <span class=n>pytorch</span><span class=o>-</span><span class=n>deep</span><span class=o>-</span><span class=n>learning</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>going_modular.going_modular</span><span class=w> </span><span class=kn>import</span> <span class=n>data_setup</span><span class=p>,</span> <span class=n>engine</span>
    <span class=kn>from</span><span class=w> </span><span class=nn>helper_functions</span><span class=w> </span><span class=kn>import</span> <span class=n>download_data</span><span class=p>,</span> <span class=n>set_seeds</span><span class=p>,</span> <span class=n>plot_loss_curves</span>
</code></pre></div> <div class=highlight><pre><span></span><code>[INFO] Couldn&#39;t find going_modular or helper_functions scripts... downloading them from GitHub.
Cloning into &#39;pytorch-deep-learning&#39;...
remote: Enumerating objects: 4356, done.[K
remote: Counting objects: 100% (321/321), done.[K
remote: Compressing objects: 100% (144/144), done.[K
remote: Total 4356 (delta 213), reused 252 (delta 176), pack-reused 4035 (from 1)[K
Receiving objects: 100% (4356/4356), 654.51 MiB | 6.45 MiB/s, done.
Resolving deltas: 100% (2584/2584), done.
Updating files: 100% (248/248), done.
</code></pre></div> <blockquote> <p><strong>Note:</strong> If you're using Google Colab, and you don't have a GPU turned on yet, it's now time to turn one on via <code>Runtime -&gt; Change runtime type -&gt; Hardware accelerator -&gt; GPU</code>.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=n>device</span> <span class=o>=</span> <span class=s2>&quot;cuda&quot;</span> <span class=k>if</span> <span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>is_available</span><span class=p>()</span> <span class=k>else</span> <span class=s2>&quot;cpu&quot;</span>
<span class=n>device</span>
</code></pre></div> <div class=highlight><pre><span></span><code>&#39;cuda&#39;
</code></pre></div> <h2 id=1-get-data>1. Get Data</h2> <p>Since we're continuing on with FoodVision Mini, let's download the pizza, steak and sushi image dataset we've been using.</p> <p>To do so we can use the <code>download_data()</code> function from <code>helper_functions.py</code> that we created in <a href=https://www.learnpytorch.io/07_pytorch_experiment_tracking/#1-get-data>07. PyTorch Experiment Tracking section 1</a>.</p> <p>We'll <code>source</code> to the raw GitHub link of the <a href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/data/pizza_steak_sushi.zip><code>pizza_steak_sushi.zip</code> data</a> and the <code>destination</code> to <code>pizza_steak_sushi</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># Download pizza, steak, sushi images from GitHub</span>
<span class=n>image_path</span> <span class=o>=</span> <span class=n>download_data</span><span class=p>(</span><span class=n>source</span><span class=o>=</span><span class=s2>&quot;https://github.com/mrdbourke/pytorch-deep-learning/raw/main/data/pizza_steak_sushi.zip&quot;</span><span class=p>,</span>
                           <span class=n>destination</span><span class=o>=</span><span class=s2>&quot;pizza_steak_sushi&quot;</span><span class=p>)</span>
<span class=n>image_path</span>
</code></pre></div> <div class=highlight><pre><span></span><code>[INFO] data/pizza_steak_sushi directory exists, skipping download.





PosixPath(&#39;data/pizza_steak_sushi&#39;)
</code></pre></div> <p>Beautiful! Data downloaded, let's setup the training and test directories.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup directory paths to train and test images</span>
<span class=n>train_dir</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;train&quot;</span>
<span class=n>test_dir</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;test&quot;</span>
</code></pre></div> <h2 id=2-create-datasets-and-dataloaders>2. Create Datasets and DataLoaders</h2> <p>Now we've got some data, let's now turn it into <code>DataLoader</code>'s.</p> <p>To do so we can use the <code>create_dataloaders()</code> function in <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/going_modular/going_modular/data_setup.py><code>data_setup.py</code></a>.</p> <p>First, we'll create a transform to prepare our images.</p> <p>This where one of the first references to the ViT paper will come in.</p> <p>In Table 3, the training resolution is mentioned as being 224 (height=224, width=224).</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-image-size-and-batch-size.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-image-size-and-batch-size.png width=900 alt="Table 3 from the Vision Transformer paper showing the image size and batch size"></a></p> <p><em>You can often find various hyperparameter settings listed in a table. In this case we're still preparing our data, so we're mainly concerned with things like image size and batch size. Source: Table 3 in <a href=https://arxiv.org/abs/2010.11929>ViT paper</a>.</em></p> <p>So we'll make sure our transform resizes our images appropriately.</p> <p>And since we'll be training our model from scratch (no transfer learning to begin with), we won't provide a <code>normalize</code> transform like we did in <a href=https://www.learnpytorch.io/06_pytorch_transfer_learning/#21-creating-a-transform-for-torchvisionmodels-manual-creation>06. PyTorch Transfer Learning section 2.1</a>.</p> <h3 id=21-prepare-transforms-for-images>2.1 Prepare transforms for images</h3> <div class=highlight><pre><span></span><code><span class=c1># Create image size (from Table 3 in the ViT paper)</span>
<span class=n>IMG_SIZE</span> <span class=o>=</span> <span class=mi>224</span>

<span class=c1># Create transform pipeline manually</span>
<span class=n>manual_transforms</span> <span class=o>=</span> <span class=n>transforms</span><span class=o>.</span><span class=n>Compose</span><span class=p>([</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>Resize</span><span class=p>((</span><span class=n>IMG_SIZE</span><span class=p>,</span> <span class=n>IMG_SIZE</span><span class=p>)),</span>
    <span class=n>transforms</span><span class=o>.</span><span class=n>ToTensor</span><span class=p>(),</span>
<span class=p>])</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Manually created transforms: </span><span class=si>{</span><span class=n>manual_transforms</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Manually created transforms: Compose(
    Resize(size=(224, 224), interpolation=bilinear, max_size=None, antialias=True)
    ToTensor()
)
</code></pre></div> <h3 id=22-turn-images-into-dataloaders>2.2 Turn images into <code>DataLoader</code>'s</h3> <p>Transforms created!</p> <p>Let's now create our <code>DataLoader</code>'s.</p> <p>The ViT paper states the use of a batch size of 4096 which is 128x the size of the batch size we've been using (32).</p> <p>However, we're going to stick with a batch size of 32.</p> <p>Why?</p> <p>Because some hardware (including the free tier of Google Colab) may not be able to handle a batch size of 4096.</p> <p>Having a batch size of 4096 means that 4096 images need to fit into the GPU memory at a time.</p> <p>This works when you've got the hardware to handle it like a research team from Google often does but when you're running on a single GPU (such as using Google Colab), making sure things work with smaller batch size first is a good idea.</p> <p>An extension of this project could be to try a higher batch size value and see what happens.</p> <blockquote> <p><strong>Note:</strong> We're using the <code>pin_memory=True</code> parameter in the <code>create_dataloaders()</code> function to speed up computation. <code>pin_memory=True</code> avoids unnecessary copying of memory between the CPU and GPU memory by "pinning" examples that have been seen before. Though the benefits of this will likely be seen with larger dataset sizes (our FoodVision Mini dataset is quite small). However, setting <code>pin_memory=True</code> doesn't <em>always</em> improve performance (this is another one of those we're scenarios in machine learning where some things work sometimes and don't other times), so best to <em>experiment, experiment, experiment</em>. See the PyTorch <a href=https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader><code>torch.utils.data.DataLoader</code> documentation</a> or <a href=https://horace.io/brrr_intro.html>Making Deep Learning Go Brrrr from First Principles</a> by Horace He for more.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># Set the batch size</span>
<span class=n>BATCH_SIZE</span> <span class=o>=</span> <span class=mi>32</span> <span class=c1># this is lower than the ViT paper but it&#39;s because we&#39;re starting small</span>

<span class=c1># Create data loaders</span>
<span class=n>train_dataloader</span><span class=p>,</span> <span class=n>test_dataloader</span><span class=p>,</span> <span class=n>class_names</span> <span class=o>=</span> <span class=n>data_setup</span><span class=o>.</span><span class=n>create_dataloaders</span><span class=p>(</span>
    <span class=n>train_dir</span><span class=o>=</span><span class=n>train_dir</span><span class=p>,</span>
    <span class=n>test_dir</span><span class=o>=</span><span class=n>test_dir</span><span class=p>,</span>
    <span class=n>transform</span><span class=o>=</span><span class=n>manual_transforms</span><span class=p>,</span> <span class=c1># use manually created transforms</span>
    <span class=n>batch_size</span><span class=o>=</span><span class=n>BATCH_SIZE</span>
<span class=p>)</span>

<span class=n>train_dataloader</span><span class=p>,</span> <span class=n>test_dataloader</span><span class=p>,</span> <span class=n>class_names</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(&lt;torch.utils.data.dataloader.DataLoader at 0x7f91885b94f0&gt;,
 &lt;torch.utils.data.dataloader.DataLoader at 0x7f92663850a0&gt;,
 [&#39;pizza&#39;, &#39;steak&#39;, &#39;sushi&#39;])
</code></pre></div> <h3 id=23-visualize-a-single-image>2.3 Visualize a single image</h3> <p>Now we've loaded our data, let's <em>visualize, visualize, visualize!</em></p> <p>An important step in the ViT paper is preparing the images into patches.</p> <p>We'll get to what this means in <a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#4-equation-1-split-data-into-patches-and-creating-the-class-position-and-patch-embedding>section 4</a> but for now, let's view a single image and its label.</p> <p>To do so, let's get a single image and label from a batch of data and inspect their shapes.</p> <div class=highlight><pre><span></span><code><span class=c1># Get a batch of images</span>
<span class=n>image_batch</span><span class=p>,</span> <span class=n>label_batch</span> <span class=o>=</span> <span class=nb>next</span><span class=p>(</span><span class=nb>iter</span><span class=p>(</span><span class=n>train_dataloader</span><span class=p>))</span>

<span class=c1># Get a single image from the batch</span>
<span class=n>image</span><span class=p>,</span> <span class=n>label</span> <span class=o>=</span> <span class=n>image_batch</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>label_batch</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>

<span class=c1># View the batch shapes</span>
<span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=p>,</span> <span class=n>label</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(torch.Size([3, 224, 224]), tensor(2))
</code></pre></div> <p>Wonderful!</p> <p>Now let's plot the image and its label with <code>matplotlib</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># Plot image with matplotlib</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># rearrange image dimensions to suit matplotlib [color_channels, height, width] -&gt; [height, width, color_channels]</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>class_names</span><span class=p>[</span><span class=n>label</span><span class=p>])</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_26_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_26_0.png></a></p> <p>Nice!</p> <p>Looks like our images are importing correctly, let's continue with the paper replication.</p> <h2 id=3-replicating-the-vit-paper-an-overview>3. Replicating the ViT paper: an overview</h2> <p>Before we write any more code, let's discuss what we're doing.</p> <p>We'd like to replicate the ViT paper for our own problem, FoodVision Mini.</p> <p>So our <strong>model inputs</strong> are: images of pizza, steak and sushi.</p> <p>And our ideal <strong>model outputs</strong> are: predicted labels of pizza, steak or sushi.</p> <p>No different to what we've been doing throughout the previous sections.</p> <p>The question is: how do we go from our inputs to the desired outputs?</p> <h3 id=31-inputs-and-outputs-layers-and-blocks>3.1 Inputs and outputs, layers and blocks</h3> <p>ViT is a deep learning neural network architecture.</p> <p>And any neural network architecture is generally comprised of <strong>layers</strong>.</p> <p>And a collection of layers is often referred to as a <strong>block</strong>.</p> <p>And stacking many blocks together is what gives us the whole architecture.</p> <p>A <strong>layer</strong> takes an input (say an image tensor), performs some kind of function on it (for example what's in the layer's <code>forward()</code> method) and then returns an output.</p> <p>So if a <strong>single layer</strong> takes an input and gives an output, then a collection of layers or a <strong>block</strong> also takes an input and gives an output.</p> <p>Let's make this concrete: * <strong>Layer</strong> - takes an input, performs a function on it, returns an output. * <strong>Block</strong> - a collection of layers, takes an input, performs a series of functions on it, returns an output. * <strong>Architecture (or model)</strong> - a collection of blocks, takes an input, performs a series of functions on it, returns an output.</p> <p>This ideology is what we're going to be using to replicate the ViT paper.</p> <p>We're going to take it layer by layer, block by block, function by function putting the pieces of the puzzle together like Lego to get our desired overall architecture.</p> <p>The reason we do this is because looking at a whole research paper can be intimidating.</p> <p>So for a better understanding, we'll break it down, starting with the inputs and outputs of single layer and working up to the inputs and outputs of the whole model.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-intputs-outputs-layers-and-blocks.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-intputs-outputs-layers-and-blocks.png width=900/ alt="inputs and outputs, layers and blocks of a model"></a></p> <p><em>A modern deep learning architecture is usually collection of layers and blocks. Where layers take an input (data as a numerical representation) and manipulate it using some kind of function (for example, the self-attention formula pictured above, however, this function could be almost anything) and then output it. Blocks are generally stacks of layers on top of each other doing a similar thing to a single layer but multiple times.</em></p> <h3 id=32-getting-specific-whats-vit-made-of>3.2 Getting specific: What's ViT made of?</h3> <p>There are many little details about the ViT model sprinkled throughout the paper.</p> <p>Finding them all is like one big treasure hunt!</p> <p>Remember, a research paper is often months of work compressed into a few pages so it's understandable for it to take of practice to replicate.</p> <p>However, the main three resources we'll be looking at for the architecture design are: 1. <strong>Figure 1</strong> - This gives an overview of the model in a graphical sense, you could <em>almost</em> recreate the architecture with this figure alone. 2. <strong>Four equations in section 3.1</strong> - These equations give a little bit more of a mathematical grounding to the coloured blocks in Figure 1. 3. <strong>Table 1</strong> - This table shows the various hyperparameter settings (such as number of layers and number of hidden units) for different ViT model variants. We'll be focused on the smallest version, ViT-Base.</p> <h4 id=321-exploring-figure-1>3.2.1 Exploring Figure 1</h4> <p>Let's start by going through Figure 1 of the ViT Paper.</p> <p>The main things we'll be paying attention to are: 1. <strong>Layers</strong> - takes an <strong>input</strong>, performs an operation or function on the input, produces an <strong>output</strong>. 2. <strong>Blocks</strong> - a collection of layers, which in turn also takes an <strong>input</strong> and produces an <strong>output</strong>.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-figure-1-inputs-and-outputs.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-figure-1-inputs-and-outputs.png width=900 alt="figure 1 from the original vision transformer paper"></a></p> <p><em>Figure 1 from the ViT Paper showcasing the different inputs, outputs, layers and blocks that create the architecture. Our goal will be to replicate each of these using PyTorch code.</em></p> <p>The ViT architecture is comprised of several stages: * <strong>Patch + Position Embedding (inputs)</strong> - Turns the input image into a sequence of image patches and adds a position number to specify in what order the patch comes in. * <strong>Linear projection of flattened patches (Embedded Patches)</strong> - The image patches get turned into an <strong>embedding</strong>, the benefit of using an embedding rather than just the image values is that an embedding is a <em>learnable</em> representation (typically in the form of a vector) of the image that can improve with training. * <strong>Norm</strong> - This is short for "<a href=https://paperswithcode.com/method/layer-normalization>Layer Normalization</a>" or "LayerNorm", a technique for regularizing (reducing overfitting) a neural network, you can use LayerNorm via the PyTorch layer <a href=https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html><code>torch.nn.LayerNorm()</code></a>. * <strong>Multi-Head Attention</strong> - This is a <a href=https://paperswithcode.com/method/multi-head-attention>Multi-Headed Self-Attention layer</a> or "MSA" for short. You can create an MSA layer via the PyTorch layer <a href=https://pytorch.org/docs/stable/generated/torch.nn.MultiheadAttention.html><code>torch.nn.MultiheadAttention()</code></a>. * <strong>MLP (or <a href=https://en.wikipedia.org/wiki/Multilayer_perceptron>Multilayer perceptron</a>)</strong> - A MLP can often refer to any collection of feedforward layers (or in PyTorch's case, a collection of layers with a <code>forward()</code> method). In the ViT Paper, the authors refer to the MLP as "MLP block" and it contains two <a href=https://pytorch.org/docs/stable/generated/torch.nn.Linear.html><code>torch.nn.Linear()</code></a> layers with a <a href=https://pytorch.org/docs/stable/generated/torch.nn.GELU.html><code>torch.nn.GELU()</code></a> non-linearity activation in between them (section 3.1) and a <a href=https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html><code>torch.nn.Dropout()</code></a> layer after each (Appendex B.1). * <strong>Transformer Encoder</strong> - The Transformer Encoder, is a collection of the layers listed above. There are two skip connections inside the Transformer encoder (the "+" symbols) meaning the layer's inputs are fed directly to immediate layers as well as subsequent layers. The overall ViT architecture is comprised of a number of Transformer encoders stacked on top of eachother. * <strong>MLP Head</strong> - This is the output layer of the architecture, it converts the learned features of an input to a class output. Since we're working on image classification, you could also call this the "classifier head". The structure of the MLP Head is similar to the MLP block.</p> <p>You might notice that many of the pieces of the ViT architecture can be created with existing PyTorch layers.</p> <p>This is because of how PyTorch is designed, it's one of the main purposes of PyTorch to create reusable neural network layers for both researchers and machine learning practitioners.</p> <blockquote> <p><strong>Question:</strong> Why not code everything from scratch?</p> <p>You could definitely do that by reproducing all of the math equations from the paper with custom PyTorch layers and that would certainly be an educative exercise, however, using pre-existing PyTorch layers is usually favoured as pre-existing layers have often been extensively tested and performance checked to make sure they run correctly and fast.</p> <p><strong>Note:</strong> We're going to be focused on writing PyTorch code to create these layers. For the background on what each of these layers does, I'd suggest reading the ViT Paper in full or reading the linked resources for each layer.</p> </blockquote> <p>Let's take Figure 1 and adapt it to our FoodVision Mini problem of classifying images of food into pizza, steak or sushi.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-figure-1-inputs-and-outputs-food-mini.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-figure-1-inputs-and-outputs-food-mini.png width=900 alt="figure 1 from the original vision transformer paper adapted to work with food images, an image of pizza goes in and gets classified as 'pizza'"></a></p> <p><em>Figure 1 from the ViT Paper adapted for use with FoodVision Mini. An image of food goes in (pizza), the image gets turned into patches and then projected to an embedding. The embedding then travels through the various layers and blocks and (hopefully) the class "pizza" is returned.</em></p> <h4 id=322-exploring-the-four-equations>3.2.2 Exploring the Four Equations</h4> <p>The next main part(s) of the ViT paper we're going to look at are the four equations in section 3.1.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-four-equations.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-four-equations.png width=650 alt="four mathematical equations from the vision transformer machine learning paper"></a></p> <p><em>These four equations represent the math behind the four major parts of the ViT architecture.</em></p> <p>Section 3.1 describes each of these (some of the text has been omitted for brevity, bolded text is mine):</p> <table> <thead> <tr> <th><strong>Equation number</strong></th> <th><strong>Description from ViT paper section 3.1</strong></th> </tr> </thead> <tbody> <tr> <td>1</td> <td>...The Transformer uses constant latent vector size <span class=arithmatex>\(D\)</span> through all of its layers, so we flatten the patches and map to <span class=arithmatex>\(D\)</span> dimensions with a <strong>trainable linear projection</strong> (Eq. 1). We refer to the output of this projection as the <strong>patch embeddings</strong>... <strong>Position embeddings</strong> are added to the patch embeddings to retain positional information. We use standard <strong>learnable 1D position embeddings</strong>...</td> </tr> <tr> <td>2</td> <td>The Transformer encoder (Vaswani et al., 2017) consists of alternating layers of multiheaded selfattention (MSA, see Appendix A) and MLP blocks (Eq. 2, 3). <strong>Layernorm (LN) is applied before every block</strong>, and <strong>residual connections after every block</strong> (Wang et al., 2019; Baevski &amp; Auli, 2019).</td> </tr> <tr> <td>3</td> <td>Same as equation 2.</td> </tr> <tr> <td>4</td> <td>Similar to BERT's [ class ] token, we <strong>prepend a learnable embedding to the sequence of embedded patches</strong> <span class=arithmatex>\(\left(\mathbf{z}_{0}^{0}=\mathbf{x}_{\text {class }}\right)\)</span>, whose state at the output of the Transformer encoder <span class=arithmatex>\(\left(\mathbf{z}_{L}^{0}\right)\)</span> serves as the image representation <span class=arithmatex>\(\mathbf{y}\)</span> (Eq. 4)...</td> </tr> </tbody> </table> <p>Let's map these descriptions to the ViT architecture in Figure 1.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-mapping-the-four-equations-to-figure-1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-mapping-the-four-equations-to-figure-1.png width=1000 alt="mapping the vision transformer paper figure 1 to the four equations listed in the paper"></a></p> <p><em>Connecting Figure 1 from the ViT paper to the four equations from section 3.1 describing the math behind each of the layers/blocks.</em></p> <p>There's a lot happening in the image above but following the coloured lines and arrows reveals the main concepts of the ViT architecture.</p> <p>How about we break down each equation further (it will be our goal to recreate these with code)?</p> <p>In all equations (except equation 4), "<span class=arithmatex>\(\mathbf{z}\)</span>" is the raw output of a particular layer:</p> <ol> <li><span class=arithmatex>\(\mathbf{z}_{0}\)</span> is "z zero" (this is the output of the initial patch embedding layer).</li> <li><span class=arithmatex>\(\mathbf{z}_{\ell}^{\prime}\)</span> is "z of a particular layer <em>prime</em>" (or an intermediary value of z).</li> <li><span class=arithmatex>\(\mathbf{z}_{\ell}\)</span> is "z of a particular layer".</li> </ol> <p>And <span class=arithmatex>\(\mathbf{y}\)</span> is the overall output of the architecture.</p> <h4 id=323-equation-1-overview>3.2.3 Equation 1 overview</h4> <div class=arithmatex>\[ \begin{aligned} \mathbf{z}_{0} &amp;=\left[\mathbf{x}_{\text {class }} ; \mathbf{x}_{p}^{1} \mathbf{E} ; \mathbf{x}_{p}^{2} \mathbf{E} ; \cdots ; \mathbf{x}_{p}^{N} \mathbf{E}\right]+\mathbf{E}_{\text {pos }}, &amp; &amp; \mathbf{E} \in \mathbb{R}^{\left(P^{2} \cdot C\right) \times D}, \mathbf{E}_{\text {pos }} \in \mathbb{R}^{(N+1) \times D} \end{aligned} \]</div> <p>This equation deals with the class token, patch embedding and position embedding (<span class=arithmatex>\(\mathbf{E}\)</span> is for embedding) of the input image.</p> <p>In vector form, the embedding might look something like:</p> <div class=highlight><pre><span></span><code><span class=n>x_input</span> <span class=o>=</span> <span class=p>[</span><span class=n>class_token</span><span class=p>,</span> <span class=n>image_patch_1</span><span class=p>,</span> <span class=n>image_patch_2</span><span class=p>,</span> <span class=n>image_patch_3</span><span class=o>...</span><span class=p>]</span> <span class=o>+</span> <span class=p>[</span><span class=n>class_token_position</span><span class=p>,</span> <span class=n>image_patch_1_position</span><span class=p>,</span> <span class=n>image_patch_2_position</span><span class=p>,</span> <span class=n>image_patch_3_position</span><span class=o>...</span><span class=p>]</span>
</code></pre></div> <p>Where each of the elements in the vector is learnable (their <code>requires_grad=True</code>).</p> <h4 id=324-equation-2-overview>3.2.4 Equation 2 overview</h4> <div class=arithmatex>\[ \begin{aligned} \mathbf{z}_{\ell}^{\prime} &amp;=\operatorname{MSA}\left(\operatorname{LN}\left(\mathbf{z}_{\ell-1}\right)\right)+\mathbf{z}_{\ell-1}, &amp; &amp; \ell=1 \ldots L \end{aligned} \]</div> <p>This says that for every layer from <span class=arithmatex>\(1\)</span> through to <span class=arithmatex>\(L\)</span> (the total number of layers), there's a Multi-Head Attention layer (MSA) wrapping a LayerNorm layer (LN).</p> <p>The addition on the end is the equivalent of adding the input to the output and forming a <a href=https://paperswithcode.com/method/residual-connection>skip/residual connection</a>.</p> <p>We'll call this layer the "MSA block".</p> <p>In pseudocode, this might look like:</p> <div class=highlight><pre><span></span><code><span class=n>x_output_MSA_block</span> <span class=o>=</span> <span class=n>MSA_layer</span><span class=p>(</span><span class=n>LN_layer</span><span class=p>(</span><span class=n>x_input</span><span class=p>))</span> <span class=o>+</span> <span class=n>x_input</span>
</code></pre></div> <p>Notice the skip connection on the end (adding the input of the layers to the output of the layers).</p> <h4 id=325-equation-3-overview>3.2.5 Equation 3 overview</h4> <div class=arithmatex>\[ \begin{aligned} \mathbf{z}_{\ell} &amp;=\operatorname{MLP}\left(\operatorname{LN}\left(\mathbf{z}_{\ell}^{\prime}\right)\right)+\mathbf{z}_{\ell}^{\prime}, &amp; &amp; \ell=1 \ldots L \\ \end{aligned} \]</div> <p>This says that for every layer from <span class=arithmatex>\(1\)</span> through to <span class=arithmatex>\(L\)</span> (the total number of layers), there's also a Multilayer Perceptron layer (MLP) wrapping a LayerNorm layer (LN).</p> <p>The addition on the end is showing the presence of a skip/residual connection.</p> <p>We'll call this layer the "MLP block".</p> <p>In pseudocode, this might look like:</p> <div class=highlight><pre><span></span><code><span class=n>x_output_MLP_block</span> <span class=o>=</span> <span class=n>MLP_layer</span><span class=p>(</span><span class=n>LN_layer</span><span class=p>(</span><span class=n>x_output_MSA_block</span><span class=p>))</span> <span class=o>+</span> <span class=n>x_output_MSA_block</span>
</code></pre></div> <p>Notice the skip connection on the end (adding the input of the layers to the output of the layers).</p> <h4 id=326-equation-4-overview>3.2.6 Equation 4 overview</h4> <div class=arithmatex>\[ \begin{aligned} \mathbf{y} &amp;=\operatorname{LN}\left(\mathbf{z}_{L}^{0}\right) &amp; &amp; \end{aligned} \]</div> <p>This says for the last layer <span class=arithmatex>\(L\)</span>, the output <span class=arithmatex>\(y\)</span> is the 0 index token of <span class=arithmatex>\(z\)</span> wrapped in a LayerNorm layer (LN).</p> <p>Or in our case, the 0 index of <code>x_output_MLP_block</code>:</p> <div class=highlight><pre><span></span><code><span class=n>y</span> <span class=o>=</span> <span class=n>Linear_layer</span><span class=p>(</span><span class=n>LN_layer</span><span class=p>(</span><span class=n>x_output_MLP_block</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</code></pre></div> <p>Of course there are some simplifications above but we'll take care of those when we start to write PyTorch code for each section.</p> <blockquote> <p><strong>Note:</strong> The above section covers alot of information. But don't forget if something doesn't make sense, you can always research it further. By asking questions like "what is a residual connection?".</p> </blockquote> <h4 id=327-exploring-table-1>3.2.7 Exploring Table 1</h4> <p>The final piece of the ViT architecture puzzle we'll focus on (for now) is Table 1.</p> <table> <thead> <tr> <th style="text-align: left;">Model</th> <th style="text-align: center;">Layers</th> <th style="text-align: center;">Hidden size <span class=arithmatex>\(D\)</span></th> <th style="text-align: center;">MLP size</th> <th style="text-align: center;">Heads</th> <th style="text-align: center;">Params</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;">ViT-Base</td> <td style="text-align: center;">12</td> <td style="text-align: center;">768</td> <td style="text-align: center;">3072</td> <td style="text-align: center;">12</td> <td style="text-align: center;"><span class=arithmatex>\(86M\)</span></td> </tr> <tr> <td style="text-align: left;">ViT-Large</td> <td style="text-align: center;">24</td> <td style="text-align: center;">1024</td> <td style="text-align: center;">4096</td> <td style="text-align: center;">16</td> <td style="text-align: center;"><span class=arithmatex>\(307M\)</span></td> </tr> <tr> <td style="text-align: left;">ViT-Huge</td> <td style="text-align: center;">32</td> <td style="text-align: center;">1280</td> <td style="text-align: center;">5120</td> <td style="text-align: center;">16</td> <td style="text-align: center;"><span class=arithmatex>\(632M\)</span></td> </tr> </tbody> </table> <div align=center> <i>Table 1: Details of Vision Transformer model variants. Source: <a href=https://arxiv.org/abs/2010.11929>ViT paper</a>.</i> </div> <p><br></p> <p>This table showcasing the various hyperparameters of each of the ViT architectures.</p> <p>You can see the numbers gradually increase from ViT-Base to ViT-Huge.</p> <p>We're going to focus on replicating ViT-Base (start small and scale up when necessary) but we'll be writing code that could easily scale up to the larger variants.</p> <p>Breaking the hyperparameters down: * <strong>Layers</strong> - How many Transformer Encoder blocks are there? (each of these will contain a MSA block and MLP block) * <strong>Hidden size <span class=arithmatex>\(D\)</span></strong> - This is the embedding dimension throughout the architecture, this will be the size of the vector that our image gets turned into when it gets patched and embedded. Generally, the larger the embedding dimension, the more information can be captured, the better results. However, a larger embedding comes at the cost of more compute. * <strong>MLP size</strong> - What are the number of hidden units in the MLP layers? * <strong>Heads</strong> - How many heads are there in the Multi-Head Attention layers? * <strong>Params</strong> - What are the total number of parameters of the model? Generally, more parameters leads to better performance but at the cost of more compute. You'll notice even ViT-Base has far more parameters than any other model we've used so far.</p> <p>We'll use these values as the hyperparameter settings for our ViT architecture.</p> <h3 id=33-my-workflow-for-replicating-papers>3.3 My workflow for replicating papers</h3> <p>When I start working on replicating a paper, I go through the following steps:</p> <ol> <li>Read the whole paper end-to-end once (to get an idea of the main concepts).</li> <li>Go back through each section and see how they line up with each other and start thinking about how they might be turned into code (just like above).</li> <li>Repeat step 2 until I've got a fairly good outline.</li> <li>Use <a href=https://mathpix.com/ >mathpix.com</a> (a very handy tool) to turn any sections of the paper into markdown/LaTeX to put into notebooks.</li> <li>Replicate the simplest version of the model possible.</li> <li>If I get stuck, look up other examples.</li> </ol> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-mathpix-demo.gif data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-mathpix-demo.gif width=900 alt="using mathpix.com to turn text from a machine learning research paper (PDF) into editable LaTeX"></a></p> <p><em>Turning the four equations from the ViT paper into editable LaTeX/markdown using <a href=https://mathpix.com/ >mathpix.com</a>.</em></p> <p>We've already gone through the first few steps above (and if you haven't read the full paper yet, I'd encourage you to give it a go) but what we'll be focusing on next is step 5: replicating the simplest version of the model possible.</p> <p>This is why we're starting with ViT-Base.</p> <p>Replicating the smallest version of the architecture possible, get it working and then we can scale up if we wanted to.</p> <blockquote> <p><strong>Note:</strong> If you've never read a research paper before, many of the above steps can be intimidating. But don't worry, like anything, your skills at reading <em>and</em> replicating papers will improve with practice. Don't forget, a research paper is often <em>months</em> of work by many people compressed into a few pages. So trying to replicate it on your own is no small feat.</p> </blockquote> <h2 id=4-equation-1-split-data-into-patches-and-creating-the-class-position-and-patch-embedding>4. Equation 1: Split data into patches and creating the class, position and patch embedding</h2> <p>I remember one of my machine learning engineer friends used to say "it's all about the embedding."</p> <p>As in, if you can represent your data in a good, learnable way (as <strong>embeddings are learnable representations</strong>), chances are, a learning algorithm will be able to perform well on them.</p> <p>With that being said, let's start by creating the class, position and patch embeddings for the ViT architecture.</p> <p>We'll start with the <strong>patch embedding</strong>.</p> <p>This means we'll be turning our input images in a sequence of patches and then embedding those patches.</p> <p>Recall that an <strong>embedding</strong> is a learnable representation of some form and is often a vector.</p> <p>The term learnable is important because this means the numerical representation of an input image (that the model sees) can be improved over time.</p> <p>We'll begin by following the opening paragraph of section 3.1 of the ViT paper (bold mine):</p> <blockquote> <p>The standard Transformer receives as input a 1D sequence of token embeddings. To handle 2D images, we reshape the image <span class=arithmatex>\(\mathbf{x} \in \mathbb{R}^{H \times W \times C}\)</span> into a sequence of flattened 2D patches <span class=arithmatex>\(\mathbf{x}_{p} \in \mathbb{R}^{N \times\left(P^{2} \cdot C\right)}\)</span>, where <span class=arithmatex>\((H, W)\)</span> is the resolution of the original image, <span class=arithmatex>\(C\)</span> is the number of channels, <span class=arithmatex>\((P, P)\)</span> is the resolution of each image patch, and <span class=arithmatex>\(N=H W / P^{2}\)</span> is the resulting number of patches, which also serves as the effective input sequence length for the Transformer. The Transformer uses constant latent vector size <span class=arithmatex>\(D\)</span> through all of its layers, so we flatten the patches and map to <span class=arithmatex>\(D\)</span> dimensions with a trainable linear projection (Eq. 1). We refer to the output of this projection as the <strong>patch embeddings</strong>.</p> </blockquote> <p>And size we're dealing with image shapes, let's keep in mind the line from Table 3 of the ViT paper:</p> <blockquote> <p>Training resolution is <strong>224</strong>.</p> </blockquote> <p>Let's break down the text above.</p> <ul> <li><span class=arithmatex>\(D\)</span> is the size of the <strong>patch embeddings</strong>, different values for <span class=arithmatex>\(D\)</span> for various sized ViT models can be found in Table 1.</li> <li>The image starts as 2D with size <span class=arithmatex>\({H \times W \times C}\)</span>.<ul> <li><span class=arithmatex>\((H, W)\)</span> is the resolution of the original image (height, width).</li> <li><span class=arithmatex>\(C\)</span> is the number of channels.</li> </ul> </li> <li>The image gets converted to a sequence of flattened 2D patches with size <span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span>.<ul> <li><span class=arithmatex>\((P, P)\)</span> is the resolution of each image patch (<strong>patch size</strong>).</li> <li><span class=arithmatex>\(N=H W / P^{2}\)</span> is the resulting number of patches, which also serves as the input sequence length for the Transformer.</li> </ul> </li> </ul> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-annotated.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-annotated.png width=900 alt="mapping the vit architecture diagram positional and patch embeddings portion to the relative mathematical equation describing what's going on"></a></p> <p><em>Mapping the patch and position embedding portion of the ViT architecture from Figure 1 to Equation 1. The opening paragraph of section 3.1 describes the different input and output shapes of the patch embedding layer.</em></p> <h3 id=41-calculating-patch-embedding-input-and-output-shapes-by-hand>4.1 Calculating patch embedding input and output shapes by hand</h3> <p>How about we start by calculating these input and output shape values by hand?</p> <p>To do so, let's create some variables to mimic each of the terms (such as <span class=arithmatex>\(H\)</span>, <span class=arithmatex>\(W\)</span> etc) above.</p> <p>We'll use a patch size (<span class=arithmatex>\(P\)</span>) of 16 since it's the best performing version of ViT-Base uses (see column "ViT-B/16" of Table 5 in the ViT paper for more).</p> <div class=highlight><pre><span></span><code><span class=c1># Create example values</span>
<span class=n>height</span> <span class=o>=</span> <span class=mi>224</span> <span class=c1># H (&quot;The training resolution is 224.&quot;)</span>
<span class=n>width</span> <span class=o>=</span> <span class=mi>224</span> <span class=c1># W</span>
<span class=n>color_channels</span> <span class=o>=</span> <span class=mi>3</span> <span class=c1># C</span>
<span class=n>patch_size</span> <span class=o>=</span> <span class=mi>16</span> <span class=c1># P</span>

<span class=c1># Calculate N (number of patches)</span>
<span class=n>number_of_patches</span> <span class=o>=</span> <span class=nb>int</span><span class=p>((</span><span class=n>height</span> <span class=o>*</span> <span class=n>width</span><span class=p>)</span> <span class=o>/</span> <span class=n>patch_size</span><span class=o>**</span><span class=mi>2</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Number of patches (N) with image height (H=</span><span class=si>{</span><span class=n>height</span><span class=si>}</span><span class=s2>), width (W=</span><span class=si>{</span><span class=n>width</span><span class=si>}</span><span class=s2>) and patch size (P=</span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2>): </span><span class=si>{</span><span class=n>number_of_patches</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Number of patches (N) with image height (H=224), width (W=224) and patch size (P=16): 196
</code></pre></div> <p>We've got the number of patches, how about we create the image output size as well?</p> <p>Better yet, let's replicate the input and output shapes of the patch embedding layer.</p> <p>Recall:</p> <ul> <li><strong>Input:</strong> The image starts as 2D with size <span class=arithmatex>\({H \times W \times C}\)</span>.</li> <li><strong>Output:</strong> The image gets converted to a sequence of flattened 2D patches with size <span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span>.</li> </ul> <div class=highlight><pre><span></span><code><span class=c1># Input shape (this is the size of a single image)</span>
<span class=n>embedding_layer_input_shape</span> <span class=o>=</span> <span class=p>(</span><span class=n>height</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>color_channels</span><span class=p>)</span>

<span class=c1># Output shape</span>
<span class=n>embedding_layer_output_shape</span> <span class=o>=</span> <span class=p>(</span><span class=n>number_of_patches</span><span class=p>,</span> <span class=n>patch_size</span><span class=o>**</span><span class=mi>2</span> <span class=o>*</span> <span class=n>color_channels</span><span class=p>)</span>

<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Input shape (single 2D image): </span><span class=si>{</span><span class=n>embedding_layer_input_shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output shape (single 2D image flattened into patches): </span><span class=si>{</span><span class=n>embedding_layer_output_shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Input shape (single 2D image): (224, 224, 3)
Output shape (single 2D image flattened into patches): (196, 768)
</code></pre></div> <p>Input and output shapes acquired!</p> <h3 id=42-turning-a-single-image-into-patches>4.2 Turning a single image into patches</h3> <p>Now we know the ideal input and output shapes for our <strong>patch embedding</strong> layer, let's move towards making it.</p> <p>What we're doing is breaking down the overall architecture into smaller pieces, focusing on the inputs and outputs of individual layers.</p> <p>So how do we create the patch embedding layer?</p> <p>We'll get to that shortly, first, let's <em>visualize, visualize, visualize!</em> what it looks like to turn an image into patches.</p> <p>Let's start with our single image.</p> <div class=highlight><pre><span></span><code><span class=c1># View single image</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># adjust for matplotlib</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>class_names</span><span class=p>[</span><span class=n>label</span><span class=p>])</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_46_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_46_0.png></a></p> <p>We want to turn this image into patches of itself inline with Figure 1 of the ViT paper.</p> <p>How about we start by just visualizing the top row of patched pixels?</p> <p>We can do this by indexing on the different image dimensions.</p> <div class=highlight><pre><span></span><code><span class=c1># Change image shape to be compatible with matplotlib (color_channels, height, width) -&gt; (height, width, color_channels)</span>
<span class=n>image_permuted</span> <span class=o>=</span> <span class=n>image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>

<span class=c1># Index to plot the top row of patched pixels</span>
<span class=n>patch_size</span> <span class=o>=</span> <span class=mi>16</span>
<span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=n>patch_size</span><span class=p>,</span> <span class=n>patch_size</span><span class=p>))</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image_permuted</span><span class=p>[:</span><span class=n>patch_size</span><span class=p>,</span> <span class=p>:,</span> <span class=p>:]);</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_48_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_48_0.png></a></p> <p>Now we've got the top row, let's turn it into patches.</p> <p>We can do this by iterating through the number of patches there'd be in the top row.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup hyperparameters and make sure img_size and patch_size are compatible</span>
<span class=n>img_size</span> <span class=o>=</span> <span class=mi>224</span>
<span class=n>patch_size</span> <span class=o>=</span> <span class=mi>16</span>
<span class=n>num_patches</span> <span class=o>=</span> <span class=n>img_size</span><span class=o>/</span><span class=n>patch_size</span>
<span class=k>assert</span> <span class=n>img_size</span> <span class=o>%</span> <span class=n>patch_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;Image size must be divisible by patch size&quot;</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Number of patches per row: </span><span class=si>{</span><span class=n>num_patches</span><span class=si>}</span><span class=se>\n</span><span class=s2>Patch size: </span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2> pixels x </span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2> pixels&quot;</span><span class=p>)</span>

<span class=c1># Create a series of subplots</span>
<span class=n>fig</span><span class=p>,</span> <span class=n>axs</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>nrows</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span>
                        <span class=n>ncols</span><span class=o>=</span><span class=n>img_size</span> <span class=o>//</span> <span class=n>patch_size</span><span class=p>,</span> <span class=c1># one column for each patch</span>
                        <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=n>num_patches</span><span class=p>,</span> <span class=n>num_patches</span><span class=p>),</span>
                        <span class=n>sharex</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
                        <span class=n>sharey</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

<span class=c1># Iterate through number of patches in the top row</span>
<span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>patch</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>img_size</span><span class=p>,</span> <span class=n>patch_size</span><span class=p>)):</span>
    <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image_permuted</span><span class=p>[:</span><span class=n>patch_size</span><span class=p>,</span> <span class=n>patch</span><span class=p>:</span><span class=n>patch</span><span class=o>+</span><span class=n>patch_size</span><span class=p>,</span> <span class=p>:]);</span> <span class=c1># keep height index constant, alter the width index</span>
    <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=c1># set the label</span>
    <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_xticks</span><span class=p>([])</span>
    <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_yticks</span><span class=p>([])</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Number of patches per row: 14.0
Patch size: 16 pixels x 16 pixels
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_50_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_50_1.png></a></p> <p>Those are some nice looking patches!</p> <p>How about we do it for the whole image?</p> <p>This time we'll iterate through the indexs for height and width and plot each patch as it's own subplot.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup hyperparameters and make sure img_size and patch_size are compatible</span>
<span class=n>img_size</span> <span class=o>=</span> <span class=mi>224</span>
<span class=n>patch_size</span> <span class=o>=</span> <span class=mi>16</span>
<span class=n>num_patches</span> <span class=o>=</span> <span class=n>img_size</span><span class=o>/</span><span class=n>patch_size</span>
<span class=k>assert</span> <span class=n>img_size</span> <span class=o>%</span> <span class=n>patch_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;Image size must be divisible by patch size&quot;</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Number of patches per row: </span><span class=si>{</span><span class=n>num_patches</span><span class=si>}</span><span class=se>\</span>
<span class=s2>        </span><span class=se>\n</span><span class=s2>Number of patches per column: </span><span class=si>{</span><span class=n>num_patches</span><span class=si>}</span><span class=se>\</span>
<span class=s2>        </span><span class=se>\n</span><span class=s2>Total patches: </span><span class=si>{</span><span class=n>num_patches</span><span class=o>*</span><span class=n>num_patches</span><span class=si>}</span><span class=se>\</span>
<span class=s2>        </span><span class=se>\n</span><span class=s2>Patch size: </span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2> pixels x </span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2> pixels&quot;</span><span class=p>)</span>

<span class=c1># Create a series of subplots</span>
<span class=n>fig</span><span class=p>,</span> <span class=n>axs</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>nrows</span><span class=o>=</span><span class=n>img_size</span> <span class=o>//</span> <span class=n>patch_size</span><span class=p>,</span> <span class=c1># need int not float</span>
                        <span class=n>ncols</span><span class=o>=</span><span class=n>img_size</span> <span class=o>//</span> <span class=n>patch_size</span><span class=p>,</span>
                        <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=n>num_patches</span><span class=p>,</span> <span class=n>num_patches</span><span class=p>),</span>
                        <span class=n>sharex</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
                        <span class=n>sharey</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

<span class=c1># Loop through height and width of image</span>
<span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>patch_height</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>img_size</span><span class=p>,</span> <span class=n>patch_size</span><span class=p>)):</span> <span class=c1># iterate through height</span>
    <span class=k>for</span> <span class=n>j</span><span class=p>,</span> <span class=n>patch_width</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>img_size</span><span class=p>,</span> <span class=n>patch_size</span><span class=p>)):</span> <span class=c1># iterate through width</span>

        <span class=c1># Plot the permuted image patch (image_permuted -&gt; (Height, Width, Color Channels))</span>
        <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image_permuted</span><span class=p>[</span><span class=n>patch_height</span><span class=p>:</span><span class=n>patch_height</span><span class=o>+</span><span class=n>patch_size</span><span class=p>,</span> <span class=c1># iterate through height</span>
                                        <span class=n>patch_width</span><span class=p>:</span><span class=n>patch_width</span><span class=o>+</span><span class=n>patch_size</span><span class=p>,</span> <span class=c1># iterate through width</span>
                                        <span class=p>:])</span> <span class=c1># get all color channels</span>

        <span class=c1># Set up label information, remove the ticks for clarity and set labels to outside</span>
        <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
                             <span class=n>rotation</span><span class=o>=</span><span class=s2>&quot;horizontal&quot;</span><span class=p>,</span>
                             <span class=n>horizontalalignment</span><span class=o>=</span><span class=s2>&quot;right&quot;</span><span class=p>,</span>
                             <span class=n>verticalalignment</span><span class=o>=</span><span class=s2>&quot;center&quot;</span><span class=p>)</span>
        <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>set_xticks</span><span class=p>([])</span>
        <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>set_yticks</span><span class=p>([])</span>
        <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>label_outer</span><span class=p>()</span>

<span class=c1># Set a super title</span>
<span class=n>fig</span><span class=o>.</span><span class=n>suptitle</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;</span><span class=si>{</span><span class=n>class_names</span><span class=p>[</span><span class=n>label</span><span class=p>]</span><span class=si>}</span><span class=s2> -&gt; Patchified&quot;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>16</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Number of patches per row: 14.0        
Number of patches per column: 14.0        
Total patches: 196.0        
Patch size: 16 pixels x 16 pixels
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_52_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_52_1.png></a></p> <p>Image patchified!</p> <p>Woah, that looks cool.</p> <p>Now how do we turn each of these patches into an embedding and convert them into a sequence?</p> <p>Hint: we can use PyTorch layers. Can you guess which?</p> <h3 id=43-creating-image-patches-with-torchnnconv2d>4.3 Creating image patches with <code>torch.nn.Conv2d()</code></h3> <p>We've seen what an image looks like when it gets turned into patches, now let's start moving towards replicating the patch embedding layers with PyTorch.</p> <p>To visualize our single image we wrote code to loop through the different height and width dimensions of a single image and plot individual patches.</p> <p>This operation is very similar to the convolutional operation we saw in <a href=https://www.learnpytorch.io/03_pytorch_computer_vision/#71-stepping-through-nnconv2d>03. PyTorch Computer Vision section 7.1: Stepping through <code>nn.Conv2d()</code></a>.</p> <p>In fact, the authors of the ViT paper mention in section 3.1 that the patch embedding is achievable with a convolutional neural network (CNN): </p> <blockquote> <p><strong>Hybrid Architecture.</strong> As an alternative to raw image patches, the input sequence can be formed from feature maps of a CNN (LeCun et al., 1989). In this hybrid model, the patch embedding projection <span class=arithmatex>\(\mathbf{E}\)</span> (Eq. 1) is applied to patches extracted from a <strong>CNN feature map</strong>. As a special case, the patches can have spatial size <span class=arithmatex>\(1 \times 1\)</span>, which means that the <strong>input sequence is obtained by simply flattening the spatial dimensions of the feature map and projecting to the Transformer dimension</strong>. The classification input embedding and position embeddings are added as described above.</p> </blockquote> <p>The "<strong>feature map</strong>" they're refering to are the weights/activations produced by a convolutional layer passing over a given image.</p> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-patch-embedding-animation.gif data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-patch-embedding-animation.gif width=900 alt="example of creating a patch embedding by passing a convolutional layer over a single image"></a></p> <p><em>By setting the <code>kernel_size</code> and <code>stride</code> parameters of a <a href=https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html><code>torch.nn.Conv2d()</code></a> layer equal to the <code>patch_size</code>, we can effectively get a layer that splits our image into patches and creates a learnable embedding (referred to as a "Linear Projection" in the ViT paper) of each patch.</em></p> <p>Remember our ideal input and output shapes for the patch embedding layer?</p> <ul> <li><strong>Input:</strong> The image starts as 2D with size <span class=arithmatex>\({H \times W \times C}\)</span>.</li> <li><strong>Output:</strong> The image gets converted to a 1D sequence of flattened 2D patches with size <span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span>.</li> </ul> <p>Or for an image size of 224 and patch size of 16:</p> <ul> <li><strong>Input (2D image):</strong> (224, 224, 3) -&gt; (height, width, color channels)</li> <li><strong>Output (flattened 2D patches):</strong> (196, 768) -&gt; (number of patches, embedding dimension)</li> </ul> <p>We can recreate these with: * <a href=https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html><code>torch.nn.Conv2d()</code></a> for turning our image into patches of CNN feature maps. * <a href=https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html><code>torch.nn.Flatten()</code></a> for flattening the spatial dimensions of the feature map.</p> <p>Let's start with the <code>torch.nn.Conv2d()</code> layer.</p> <p>We can replicate the creation of patches by setting the <code>kernel_size</code> and <code>stride</code> equal to <code>patch_size</code>.</p> <p>This means each convolutional kernel will be of size <code>(patch_size x patch_size)</code> or if <code>patch_size=16</code>, <code>(16 x 16)</code> (the equivalent of one whole patch).</p> <p>And each step or <code>stride</code> of the convolutional kernel will be <code>patch_size</code> pixels long or <code>16</code> pixels long (equivalent of stepping to the next patch).</p> <p>We'll set <code>in_channels=3</code> for the number of color channels in our image and we'll set <code>out_channels=768</code>, the same as the <span class=arithmatex>\(D\)</span> value in Table 1 for ViT-Base (this is the embedding dimension, each image will be embedded into a learnable vector of size 768).</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>torch</span><span class=w> </span><span class=kn>import</span> <span class=n>nn</span>

<span class=c1># Set the patch size</span>
<span class=n>patch_size</span><span class=o>=</span><span class=mi>16</span>

<span class=c1># Create the Conv2d layer with hyperparameters from the ViT paper</span>
<span class=n>conv2d</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Conv2d</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=c1># number of color channels</span>
                   <span class=n>out_channels</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># from Table 1: Hidden size D, this is the embedding size</span>
                   <span class=n>kernel_size</span><span class=o>=</span><span class=n>patch_size</span><span class=p>,</span> <span class=c1># could also use (patch_size, patch_size)</span>
                   <span class=n>stride</span><span class=o>=</span><span class=n>patch_size</span><span class=p>,</span>
                   <span class=n>padding</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</code></pre></div> <p>Now we've got a convoluational layer, let's see what happens when we pass a single image through it.</p> <div class=highlight><pre><span></span><code><span class=c1># View single image</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># adjust for matplotlib</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>class_names</span><span class=p>[</span><span class=n>label</span><span class=p>])</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_57_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_57_0.png></a></p> <div class=highlight><pre><span></span><code><span class=c1># Pass the image through the convolutional layer</span>
<span class=n>image_out_of_conv</span> <span class=o>=</span> <span class=n>conv2d</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=c1># add a single batch dimension (height, width, color_channels) -&gt; (batch, height, width, color_channels)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>image_out_of_conv</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>torch.Size([1, 768, 14, 14])
</code></pre></div> <p>Passing our image through the convolutional layer turns it into a series of 768 (this is the embedding size or <span class=arithmatex>\(D\)</span>) feature/activation maps.</p> <p>So its output shape can be read as:</p> <div class=highlight><pre><span></span><code><span class=n>torch</span><span class=o>.</span><span class=n>Size</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>768</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=mi>14</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=p>[</span><span class=n>batch_size</span><span class=p>,</span> <span class=n>embedding_dim</span><span class=p>,</span> <span class=n>feature_map_height</span><span class=p>,</span> <span class=n>feature_map_width</span><span class=p>]</span>
</code></pre></div> <p>Let's visualize five random feature maps and see what they look like.</p> <div class=highlight><pre><span></span><code><span class=c1># Plot random 5 convolutional feature maps</span>
<span class=kn>import</span><span class=w> </span><span class=nn>random</span>
<span class=n>random_indexes</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>758</span><span class=p>),</span> <span class=n>k</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span> <span class=c1># pick 5 numbers between 0 and the embedding size</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Showing random convolutional feature maps from indexes: </span><span class=si>{</span><span class=n>random_indexes</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># Create plot</span>
<span class=n>fig</span><span class=p>,</span> <span class=n>axs</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>nrows</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>ncols</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>12</span><span class=p>,</span> <span class=mi>12</span><span class=p>))</span>

<span class=c1># Plot random image feature maps</span>
<span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>idx</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>random_indexes</span><span class=p>):</span>
    <span class=n>image_conv_feature_map</span> <span class=o>=</span> <span class=n>image_out_of_conv</span><span class=p>[:,</span> <span class=n>idx</span><span class=p>,</span> <span class=p>:,</span> <span class=p>:]</span> <span class=c1># index on the output tensor of the convolutional layer</span>
    <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image_conv_feature_map</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span><span class=o>.</span><span class=n>detach</span><span class=p>()</span><span class=o>.</span><span class=n>numpy</span><span class=p>())</span>
    <span class=n>axs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>xticklabels</span><span class=o>=</span><span class=p>[],</span> <span class=n>yticklabels</span><span class=o>=</span><span class=p>[],</span> <span class=n>xticks</span><span class=o>=</span><span class=p>[],</span> <span class=n>yticks</span><span class=o>=</span><span class=p>[]);</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Showing random convolutional feature maps from indexes: [674, 631, 496, 118, 161]
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_60_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_60_1.png></a></p> <p>Notice how the feature maps all kind of represent the original image, after visualizing a few more you can start to see the different major outlines and some major features.</p> <p>The important thing to note is that these features may change over time as the neural network learns.</p> <p>And because of these, these feature maps can be considered a <strong>learnable embedding</strong> of our image.</p> <p>Let's check one out in numerical form.</p> <div class=highlight><pre><span></span><code><span class=c1># Get a single feature map in tensor form</span>
<span class=n>single_feature_map</span> <span class=o>=</span> <span class=n>image_out_of_conv</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>:,</span> <span class=p>:]</span>
<span class=n>single_feature_map</span><span class=p>,</span> <span class=n>single_feature_map</span><span class=o>.</span><span class=n>requires_grad</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(tensor([[[-0.4969, -0.5042, -0.3972, -0.4130, -0.3962, -0.3981, -0.3880,
           -0.3763, -0.3764, -0.3615, -0.3352, -0.3145, -0.3044, -0.2902],
          [-0.4909, -0.3708, -0.2844, -0.2801, -0.3556, -0.4164, -0.3867,
           -0.3487, -0.3447, -0.3526, -0.3410, -0.3187, -0.2963, -0.2764],
          [-0.1972, -0.1913, -0.1672, -0.2462, -0.1263, -0.4333, -0.4545,
           -0.2683, -0.2262, -0.3561, -0.3767, -0.4285, -0.4269, -0.4051],
          [-0.2234, -0.1573, -0.1751, -0.3561, -0.3060, -0.1518, -0.2663,
           -0.2502, -0.1224, -0.1306, -0.1323, -0.2491, -0.2363, -0.2521],
          [-0.1682, -0.1161, -0.1290, -0.3115, -0.2833, -0.1815, -0.2370,
           -0.1411, -0.1128, -0.1486, -0.2010, -0.2417, -0.1820, -0.2156],
          [-0.0982, -0.1053, -0.1531, -0.1384, -0.1593, -0.1974, -0.1333,
           -0.1280, -0.1576, -0.1891, -0.1161, -0.1662, -0.2544, -0.2740],
          [-0.2348, -0.1427, -0.1145, -0.1608, -0.1771, -0.1199, -0.1313,
           -0.1276, -0.1736, -0.1082, -0.1434, -0.2854, -0.1056, -0.1518],
          [-0.2009, -0.1707, -0.3431, -0.6486, -0.5940, -0.4131, -0.2521,
           -0.1849, -0.1630, -0.1082, -0.1600, -0.2933, -0.2543, -0.2077],
          [-0.1320, -0.1585, -0.3377, -0.6092, -0.5409, -0.2658, -0.3988,
           -0.4087, -0.1068, -0.1686, -0.1685, -0.1450, -0.2747, -0.3932],
          [-0.1529, -0.1958, -0.2093, -0.7470, -0.4375, -0.3852, -0.2338,
           -0.4072, -0.2000, -0.1176, -0.3359, -0.1182, -0.2355, -0.4446],
          [-0.1901, -0.3891, -0.5073, -0.6136, -0.4269, -0.3604, -0.3356,
           -0.4258, -0.2694, -0.0864, -0.0942, -0.1309, -0.3707, -0.3089],
          [-0.6471, -0.4759, -0.4846, -0.4851, -0.5892, -0.3724, -0.3602,
           -0.3281, -0.2334, -0.0873, -0.0968, -0.2450, -0.1206, -0.2354],
          [-0.0993, -0.6716, -0.5356, -0.4815, -0.4414, -0.4094, -0.2823,
           -0.1802, -0.0802, -0.0993, -0.2263, -0.1503, -0.1455, -0.5511],
          [-0.1376, -0.3307, -0.5020, -0.1709, -0.1229, -0.0842, -0.0759,
           -0.0758, -0.0871, -0.0948, -0.0985, -0.0926, -0.2630, -0.0857]]],
        grad_fn=&lt;SliceBackward0&gt;),
 True)
</code></pre></div> <p>The <code>grad_fn</code> output of the <code>single_feature_map</code> and the <code>requires_grad=True</code> attribute means PyTorch is tracking the gradients of this feature map and it will be updated by gradient descent during training.</p> <h3 id=44-flattening-the-patch-embedding-with-torchnnflatten>4.4 Flattening the patch embedding with <code>torch.nn.Flatten()</code></h3> <p>We've turned our image into patch embeddings but they're still in 2D format.</p> <p>How do we get them into the desired output shape of the patch embedding layer of the ViT model?</p> <ul> <li><strong>Desired output (1D sequence of flattened 2D patches):</strong> (196, 768) -&gt; (number of patches, embedding dimension) -&gt; <span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span></li> </ul> <p>Let's check the current shape.</p> <div class=highlight><pre><span></span><code><span class=c1># Current tensor shape</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Current tensor shape: </span><span class=si>{</span><span class=n>image_out_of_conv</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch, embedding_dim, feature_map_height, feature_map_width]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Current tensor shape: torch.Size([1, 768, 14, 14]) -&gt; [batch, embedding_dim, feature_map_height, feature_map_width]
</code></pre></div> <p>Well we've got the 768 part ( <span class=arithmatex>\((P^{2} \cdot C)\)</span> ) but we still need the number of patches (<span class=arithmatex>\(N\)</span>).</p> <p>Reading back through section 3.1 of the ViT paper it says (bold mine):</p> <blockquote> <p>As a special case, the patches can have spatial size <span class=arithmatex>\(1 \times 1\)</span>, which means that the <strong>input sequence is obtained by simply <em>flattening</em> the spatial dimensions of the feature map and projecting to the Transformer dimension</strong>.</p> </blockquote> <p>Flattening the spatial dimensions of the feature map hey?</p> <p>What layer do we have in PyTorch that can flatten?</p> <p>How about <a href=https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html><code>torch.nn.Flatten()</code></a>?</p> <p>But we don't want to flatten the whole tensor, we only want to flatten the "spatial dimensions of the feature map".</p> <p>Which in our case is the <code>feature_map_height</code> and <code>feature_map_width</code> dimensions of <code>image_out_of_conv</code>.</p> <p>So how about we create a <code>torch.nn.Flatten()</code> layer to only flatten those dimensions, we can use the <code>start_dim</code> and <code>end_dim</code> parameters to set that up?</p> <div class=highlight><pre><span></span><code><span class=c1># Create flatten layer</span>
<span class=n>flatten</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Flatten</span><span class=p>(</span><span class=n>start_dim</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=c1># flatten feature_map_height (dimension 2)</span>
                     <span class=n>end_dim</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span> <span class=c1># flatten feature_map_width (dimension 3)</span>
</code></pre></div> <p>Nice! Now let's put it all together!</p> <p>We'll: 1. Take a single image. 2. Put in through the convolutional layer (<code>conv2d</code>) to turn the image into 2D feature maps (patch embeddings). 3. Flatten the 2D feature map into a single sequence.</p> <div class=highlight><pre><span></span><code><span class=c1># 1. View single image</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># adjust for matplotlib</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=n>class_names</span><span class=p>[</span><span class=n>label</span><span class=p>])</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Original image shape: </span><span class=si>{</span><span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 2. Turn image into feature maps</span>
<span class=n>image_out_of_conv</span> <span class=o>=</span> <span class=n>conv2d</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=c1># add batch dimension to avoid shape errors</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image feature map shape: </span><span class=si>{</span><span class=n>image_out_of_conv</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 3. Flatten the feature maps</span>
<span class=n>image_out_of_conv_flattened</span> <span class=o>=</span> <span class=n>flatten</span><span class=p>(</span><span class=n>image_out_of_conv</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Flattened image feature map shape: </span><span class=si>{</span><span class=n>image_out_of_conv_flattened</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Original image shape: torch.Size([3, 224, 224])
Image feature map shape: torch.Size([1, 768, 14, 14])
Flattened image feature map shape: torch.Size([1, 768, 196])
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_69_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_69_1.png></a></p> <p>Woohoo! It looks like our <code>image_out_of_conv_flattened</code> shape is very close to our desired output shape:</p> <ul> <li><strong>Desired output (flattened 2D patches):</strong> (196, 768) -&gt; <span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span></li> <li><strong>Current shape:</strong> (1, 768, 196)</li> </ul> <p>The only difference is our current shape has a batch size and the dimensions are in a different order to the desired output.</p> <p>How could we fix this?</p> <p>Well, how about we rearrange the dimensions?</p> <p>We can do so with <code>torch.Tensor.permute()</code> just like we do when rearranging image tensors to plot them with matplotlib.</p> <p>Let's try.</p> <div class=highlight><pre><span></span><code><span class=c1># Get flattened image patch embeddings in right shape</span>
<span class=n>image_out_of_conv_flattened_reshaped</span> <span class=o>=</span> <span class=n>image_out_of_conv_flattened</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1># [batch_size, P^2•C, N] -&gt; [batch_size, N, P^2•C]</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Patch embedding sequence shape: </span><span class=si>{</span><span class=n>image_out_of_conv_flattened_reshaped</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, num_patches, embedding_size]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Patch embedding sequence shape: torch.Size([1, 196, 768]) -&gt; [batch_size, num_patches, embedding_size]
</code></pre></div> <p>Yes!!!</p> <p>We've now matched the desired input and output shapes for the patch embedding layer of the ViT architecture using a couple of PyTorch layers.</p> <p>How about we visualize one of the flattened feature maps?</p> <div class=highlight><pre><span></span><code><span class=c1># Get a single flattened feature map</span>
<span class=n>single_flattened_feature_map</span> <span class=o>=</span> <span class=n>image_out_of_conv_flattened_reshaped</span><span class=p>[:,</span> <span class=p>:,</span> <span class=mi>0</span><span class=p>]</span> <span class=c1># index: (batch_size, number_of_patches, embedding_dimension)</span>

<span class=c1># Plot the flattened feature map visually</span>
<span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>22</span><span class=p>,</span> <span class=mi>22</span><span class=p>))</span>
<span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>single_flattened_feature_map</span><span class=o>.</span><span class=n>detach</span><span class=p>()</span><span class=o>.</span><span class=n>numpy</span><span class=p>())</span>
<span class=n>plt</span><span class=o>.</span><span class=n>title</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Flattened feature map shape: </span><span class=si>{</span><span class=n>single_flattened_feature_map</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=kc>False</span><span class=p>);</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_73_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_73_0.png></a></p> <p>Hmm, the flattened feature map doesn't look like much visually, but that's not what we're concerned about, this is what will be the output of the patching embedding layer and the input to the rest of the ViT architecture.</p> <blockquote> <p><strong>Note:</strong> The <a href=https://arxiv.org/abs/1706.03762>original Transformer architecture</a> was designed to work with text. The Vision Transformer architecture (ViT) had the goal of using the original Transformer for images. This is why the input to the ViT architecture is processed in the way it is. We're essentially taking a 2D image and formatting it so it appears as a 1D sequence of text.</p> </blockquote> <p>How about we view the flattened feature map in tensor form?</p> <div class=highlight><pre><span></span><code><span class=c1># See the flattened feature map as a tensor</span>
<span class=n>single_flattened_feature_map</span><span class=p>,</span> <span class=n>single_flattened_feature_map</span><span class=o>.</span><span class=n>requires_grad</span><span class=p>,</span> <span class=n>single_flattened_feature_map</span><span class=o>.</span><span class=n>shape</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(tensor([[-0.4969, -0.5042, -0.3972, -0.4130, -0.3962, -0.3981, -0.3880, -0.3763,
          -0.3764, -0.3615, -0.3352, -0.3145, -0.3044, -0.2902, -0.4909, -0.3708,
          -0.2844, -0.2801, -0.3556, -0.4164, -0.3867, -0.3487, -0.3447, -0.3526,
          -0.3410, -0.3187, -0.2963, -0.2764, -0.1972, -0.1913, -0.1672, -0.2462,
          -0.1263, -0.4333, -0.4545, -0.2683, -0.2262, -0.3561, -0.3767, -0.4285,
          -0.4269, -0.4051, -0.2234, -0.1573, -0.1751, -0.3561, -0.3060, -0.1518,
          -0.2663, -0.2502, -0.1224, -0.1306, -0.1323, -0.2491, -0.2363, -0.2521,
          -0.1682, -0.1161, -0.1290, -0.3115, -0.2833, -0.1815, -0.2370, -0.1411,
          -0.1128, -0.1486, -0.2010, -0.2417, -0.1820, -0.2156, -0.0982, -0.1053,
          -0.1531, -0.1384, -0.1593, -0.1974, -0.1333, -0.1280, -0.1576, -0.1891,
          -0.1161, -0.1662, -0.2544, -0.2740, -0.2348, -0.1427, -0.1145, -0.1608,
          -0.1771, -0.1199, -0.1313, -0.1276, -0.1736, -0.1082, -0.1434, -0.2854,
          -0.1056, -0.1518, -0.2009, -0.1707, -0.3431, -0.6486, -0.5940, -0.4131,
          -0.2521, -0.1849, -0.1630, -0.1082, -0.1600, -0.2933, -0.2543, -0.2077,
          -0.1320, -0.1585, -0.3377, -0.6092, -0.5409, -0.2658, -0.3988, -0.4087,
          -0.1068, -0.1686, -0.1685, -0.1450, -0.2747, -0.3932, -0.1529, -0.1958,
          -0.2093, -0.7470, -0.4375, -0.3852, -0.2338, -0.4072, -0.2000, -0.1176,
          -0.3359, -0.1182, -0.2355, -0.4446, -0.1901, -0.3891, -0.5073, -0.6136,
          -0.4269, -0.3604, -0.3356, -0.4258, -0.2694, -0.0864, -0.0942, -0.1309,
          -0.3707, -0.3089, -0.6471, -0.4759, -0.4846, -0.4851, -0.5892, -0.3724,
          -0.3602, -0.3281, -0.2334, -0.0873, -0.0968, -0.2450, -0.1206, -0.2354,
          -0.0993, -0.6716, -0.5356, -0.4815, -0.4414, -0.4094, -0.2823, -0.1802,
          -0.0802, -0.0993, -0.2263, -0.1503, -0.1455, -0.5511, -0.1376, -0.3307,
          -0.5020, -0.1709, -0.1229, -0.0842, -0.0759, -0.0758, -0.0871, -0.0948,
          -0.0985, -0.0926, -0.2630, -0.0857]], grad_fn=&lt;SelectBackward0&gt;),
 True,
 torch.Size([1, 196]))
</code></pre></div> <p>Beautiful!</p> <p>We've turned our single 2D image into a 1D learnable embedding vector (or "Linear Projection of Flattned Patches" in Figure 1 of the ViT paper).</p> <h3 id=45-turning-the-vit-patch-embedding-layer-into-a-pytorch-module>4.5 Turning the ViT patch embedding layer into a PyTorch module</h3> <p>Time to put everything we've done for creating the patch embedding into a single PyTorch layer.</p> <p>We can do so by subclassing <code>nn.Module</code> and creating a small PyTorch "model" to do all of the steps above.</p> <p>Specifically we'll: 1. Create a class called <code>PatchEmbedding</code> which subclasses <code>nn.Module</code> (so it can be used a PyTorch layer). 2. Initialize the class with the parameters <code>in_channels=3</code>, <code>patch_size=16</code> (for ViT-Base) and <code>embedding_dim=768</code> (this is <span class=arithmatex>\(D\)</span> for ViT-Base from Table 1). 3. Create a layer to turn an image into patches using <code>nn.Conv2d()</code> (just like in 4.3 above). 4. Create a layer to flatten the patch feature maps into a single dimension (just like in 4.4 above). 5. Define a <code>forward()</code> method to take an input and pass it through the layers created in 3 and 4. 6. Make sure the output shape reflects the required output shape of the ViT architecture (<span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span>).</p> <p>Let's do it!</p> <div class=highlight><pre><span></span><code><span class=c1># 1. Create a class which subclasses nn.Module</span>
<span class=k>class</span><span class=w> </span><span class=nc>PatchEmbedding</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Turns a 2D input image into a 1D sequence learnable embedding vector.</span>

<span class=sd>    Args:</span>
<span class=sd>        in_channels (int): Number of color channels for the input images. Defaults to 3.</span>
<span class=sd>        patch_size (int): Size of patches to convert input image into. Defaults to 16.</span>
<span class=sd>        embedding_dim (int): Size of embedding to turn image into. Defaults to 768.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># 2. Initialize the class with appropriate variables</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
                 <span class=n>in_channels</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
                 <span class=n>patch_size</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>16</span><span class=p>,</span>
                 <span class=n>embedding_dim</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>768</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>

        <span class=c1># 3. Create a layer to turn an image into patches</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>patcher</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Conv2d</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=n>in_channels</span><span class=p>,</span>
                                 <span class=n>out_channels</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                                 <span class=n>kernel_size</span><span class=o>=</span><span class=n>patch_size</span><span class=p>,</span>
                                 <span class=n>stride</span><span class=o>=</span><span class=n>patch_size</span><span class=p>,</span>
                                 <span class=n>padding</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>

        <span class=c1># 4. Create a layer to flatten the patch feature maps into a single dimension</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>flatten</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Flatten</span><span class=p>(</span><span class=n>start_dim</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=c1># only flatten the feature map dimensions into a single vector</span>
                                  <span class=n>end_dim</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>

    <span class=c1># 5. Define the forward method</span>
    <span class=k>def</span><span class=w> </span><span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=c1># Create assertion to check that inputs are the correct shape</span>
        <span class=n>image_resolution</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
        <span class=k>assert</span> <span class=n>image_resolution</span> <span class=o>%</span> <span class=n>patch_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&quot;Input image size must be divisble by patch size, image shape: </span><span class=si>{</span><span class=n>image_resolution</span><span class=si>}</span><span class=s2>, patch size: </span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2>&quot;</span>

        <span class=c1># Perform the forward pass</span>
        <span class=n>x_patched</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patcher</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=n>x_flattened</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>flatten</span><span class=p>(</span><span class=n>x_patched</span><span class=p>)</span>
        <span class=c1># 6. Make sure the output shape has the right order</span>
        <span class=k>return</span> <span class=n>x_flattened</span><span class=o>.</span><span class=n>permute</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1># adjust so the embedding is on the final dimension [batch_size, P^2•C, N] -&gt; [batch_size, N, P^2•C]</span>
</code></pre></div> <p><code>PatchEmbedding</code> layer created!</p> <p>Let's try it out on a single image.</p> <div class=highlight><pre><span></span><code><span class=n>set_seeds</span><span class=p>()</span>

<span class=c1># Create an instance of patch embedding layer</span>
<span class=n>patchify</span> <span class=o>=</span> <span class=n>PatchEmbedding</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
                          <span class=n>patch_size</span><span class=o>=</span><span class=mi>16</span><span class=p>,</span>
                          <span class=n>embedding_dim</span><span class=o>=</span><span class=mi>768</span><span class=p>)</span>

<span class=c1># Pass a single image through</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Input image shape: </span><span class=si>{</span><span class=n>image</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=n>patch_embedded_image</span> <span class=o>=</span> <span class=n>patchify</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=c1># add an extra batch dimension on the 0th index, otherwise will error</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output patch embedding shape: </span><span class=si>{</span><span class=n>patch_embedded_image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Input image shape: torch.Size([1, 3, 224, 224])
Output patch embedding shape: torch.Size([1, 196, 768])
</code></pre></div> <p>Beautiful!</p> <p>The output shape matches the ideal input and output shapes we'd like to see from the patch embedding layer:</p> <ul> <li><strong>Input:</strong> The image starts as 2D with size <span class=arithmatex>\({H \times W \times C}\)</span>.</li> <li><strong>Output:</strong> The image gets converted to a 1D sequence of flattened 2D patches with size <span class=arithmatex>\({N \times\left(P^{2} \cdot C\right)}\)</span>.</li> </ul> <p>Where: * <span class=arithmatex>\((H, W)\)</span> is the resolution of the original image. * <span class=arithmatex>\(C\)</span> is the number of channels. * <span class=arithmatex>\((P, P)\)</span> is the resolution of each image patch (<strong>patch size</strong>). * <span class=arithmatex>\(N=H W / P^{2}\)</span> is the resulting number of patches, which also serves as the effective input sequence length for the Transformer.</p> <p>We've now replicated the patch embedding for equation 1 but not the class token/position embedding.</p> <p>We'll get to these later on.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-replicating-the-patch-embedding-layer.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-replicating-the-patch-embedding-layer.png width=900 alt="replicating the vision transformer architecture patch embedding layer"></a></p> <p><em>Our <code>PatchEmbedding</code> class (right) replicates the patch embedding of the ViT architecture from Figure 1 and Equation 1 from the ViT paper (left). However, the learnable class embedding and position embeddings haven't been created yet. These will come soon.</em></p> <p>Let's now get a summary of our <code>PatchEmbedding</code> layer.</p> <div class=highlight><pre><span></span><code><span class=c1># Create random input sizes</span>
<span class=n>random_input_image</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>224</span><span class=p>,</span> <span class=mi>224</span><span class=p>)</span>
<span class=n>random_input_image_error</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>250</span><span class=p>,</span> <span class=mi>250</span><span class=p>)</span> <span class=c1># will error because image size is incompatible with patch_size</span>

<span class=c1># # Get a summary of the input and outputs of PatchEmbedding (uncomment for full output)</span>
<span class=c1># summary(PatchEmbedding(),</span>
<span class=c1>#         input_size=random_input_image, # try swapping this for &quot;random_input_image_error&quot;</span>
<span class=c1>#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class=c1>#         col_width=20,</span>
<span class=c1>#         row_settings=[&quot;var_names&quot;])</span>
</code></pre></div> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-summary-output-patchembedding.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-summary-output-patchembedding.png width=900/ alt="summary output of patchembedding layer for vision transformer with input and output shapes"></a></p> <h3 id=46-creating-the-class-token-embedding>4.6 Creating the class token embedding</h3> <p>Okay we've made the image patch embedding, time to get to work on the class token embedding.</p> <p>Or <span class=arithmatex>\(\mathbf{x}_\text {class }\)</span> from equation 1.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-the-class-token.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-the-class-token.png width=900 alt="class token embedding highlight from the vision transformer paper figure 1 and section 3.1"></a></p> <p><em>Left: Figure 1 from the ViT paper with the "classification token" or <code>[class]</code> embedding token we're going to recreate highlighted. Right: Equation 1 and section 3.1 of the ViT paper that relate to the learnable class embedding token.</em></p> <p>Reading the second paragraph of section 3.1 from the ViT paper, we see the following description:</p> <blockquote> <p>Similar to BERT's <code>[ class ]</code> token, we prepend a learnable embedding to the sequence of embedded patches <span class=arithmatex>\(\left(\mathbf{z}_{0}^{0}=\mathbf{x}_{\text {class }}\right)\)</span>, whose state at the output of the Transformer encoder <span class=arithmatex>\(\left(\mathbf{z}_{L}^{0}\right)\)</span> serves as the image representation <span class=arithmatex>\(\mathbf{y}\)</span> (Eq. 4).</p> <p><strong>Note:</strong> <a href=https://arxiv.org/abs/1810.04805>BERT</a> (Bidirectional Encoder Representations from Transformers) is one of the original machine learning research papers to use the Transformer architecture to achieve outstanding results on natural language processing (NLP) tasks and is where the idea of having a <code>[ class ]</code> token at the start of a sequence originated, class being a description for the "classification" class the sequence belonged to.</p> </blockquote> <p>So we need to "preprend a learnable embedding to the sequence of embedded patches".</p> <p>Let's start by viewing our sequence of embedded patches tensor (created in section 4.5) and its shape.</p> <div class=highlight><pre><span></span><code><span class=c1># View the patch embedding and patch embedding shape</span>
<span class=nb>print</span><span class=p>(</span><span class=n>patch_embedded_image</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Patch embedding shape: </span><span class=si>{</span><span class=n>patch_embedded_image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, number_of_patches, embedding_dimension]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[[-0.8509,  0.1935, -0.0733,  ...,  0.4927, -0.4795,  0.3345],
         [-0.7782, -0.0290, -0.0858,  ...,  0.5058, -0.4762,  0.3578],
         [-0.7469,  0.0840, -0.0677,  ...,  0.4260, -0.4161,  0.2774],
         ...,
         [-0.1418,  0.0333, -0.0511,  ...,  0.0897, -0.0767,  0.0492],
         [-0.5927,  0.0719,  0.0266,  ...,  0.2245, -0.1302, -0.2618],
         [-0.1805,  0.0180, -0.0556,  ...,  0.0914, -0.1476,  0.0110]]],
       grad_fn=&lt;PermuteBackward0&gt;)
Patch embedding shape: torch.Size([1, 196, 768]) -&gt; [batch_size, number_of_patches, embedding_dimension]
</code></pre></div> <p>To "prepend a learnable embedding to the sequence of embedded patches" we need to create a learnable embedding in the shape of the <code>embedding_dimension</code> (<span class=arithmatex>\(D\)</span>) and then add it to the <code>number_of_patches</code> dimension.</p> <p>Or in pseudocode:</p> <div class=highlight><pre><span></span><code><span class=n>patch_embedding</span> <span class=o>=</span> <span class=p>[</span><span class=n>image_patch_1</span><span class=p>,</span> <span class=n>image_patch_2</span><span class=p>,</span> <span class=n>image_patch_3</span><span class=o>...</span><span class=p>]</span>
<span class=n>class_token</span> <span class=o>=</span> <span class=n>learnable_embedding</span>
<span class=n>patch_embedding_with_class_token</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>cat</span><span class=p>((</span><span class=n>class_token</span><span class=p>,</span> <span class=n>patch_embedding</span><span class=p>),</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</code></pre></div> <p>Notice the concatenation (<code>torch.cat()</code>) happens on <code>dim=1</code> (the <code>number_of_patches</code> dimension).</p> <p>Let's create a learnable embedding for the class token.</p> <p>To do so, we'll get the batch size and embedding dimension shape and then we'll create a <code>torch.ones()</code> tensor in the shape <code>[batch_size, 1, embedding_dimension]</code>.</p> <p>And we'll make the tensor learnable by passing it to <code>nn.Parameter()</code> with <code>requires_grad=True</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># Get the batch size and embedding dimension</span>
<span class=n>batch_size</span> <span class=o>=</span> <span class=n>patch_embedded_image</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=n>embedding_dimension</span> <span class=o>=</span> <span class=n>patch_embedded_image</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>

<span class=c1># Create the class token embedding as a learnable parameter that shares the same size as the embedding dimension (D)</span>
<span class=n>class_token</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=n>batch_size</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>embedding_dimension</span><span class=p>),</span> <span class=c1># [batch_size, number_of_tokens, embedding_dimension]</span>
                           <span class=n>requires_grad</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># make sure the embedding is learnable</span>

<span class=c1># Show the first 10 examples of the class_token</span>
<span class=nb>print</span><span class=p>(</span><span class=n>class_token</span><span class=p>[:,</span> <span class=p>:,</span> <span class=p>:</span><span class=mi>10</span><span class=p>])</span>

<span class=c1># Print the class_token shape</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Class token shape: </span><span class=si>{</span><span class=n>class_token</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, number_of_tokens, embedding_dimension]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]], grad_fn=&lt;SliceBackward0&gt;)
Class token shape: torch.Size([1, 1, 768]) -&gt; [batch_size, number_of_tokens, embedding_dimension]
</code></pre></div> <blockquote> <p><strong>Note:</strong> Here we're only creating the class token embedding as <a href=https://pytorch.org/docs/stable/generated/torch.ones.html><code>torch.ones()</code></a> for demonstration purposes, in reality, you'd likely create the class token embedding with <a href=https://pytorch.org/docs/stable/generated/torch.randn.html><code>torch.randn()</code></a> (since machine learning is all about harnessing the power of controlled randomness, you generally start with a random number and improve it over time).</p> </blockquote> <p>See how the <code>number_of_tokens</code> dimension of <code>class_token</code> is <code>1</code> since we only want to prepend one class token value to the start of the patch embedding sequence.</p> <p>Now we've got the class token embedding, let's prepend it to our sequence of image patches, <code>patch_embedded_image</code>.</p> <p>We can do so using <a href=https://pytorch.org/docs/stable/generated/torch.cat.html><code>torch.cat()</code></a> and set <code>dim=1</code> (so <code>class_token</code>'s <code>number_of_tokens</code> dimension is preprended to <code>patch_embedded_image</code>'s <code>number_of_patches</code> dimension).</p> <div class=highlight><pre><span></span><code><span class=c1># Add the class token embedding to the front of the patch embedding</span>
<span class=n>patch_embedded_image_with_class_embedding</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>cat</span><span class=p>((</span><span class=n>class_token</span><span class=p>,</span> <span class=n>patch_embedded_image</span><span class=p>),</span>
                                                      <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=c1># concat on first dimension</span>

<span class=c1># Print the sequence of patch embeddings with the prepended class token embedding</span>
<span class=nb>print</span><span class=p>(</span><span class=n>patch_embedded_image_with_class_embedding</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Sequence of patch embeddings with class token prepended shape: </span><span class=si>{</span><span class=n>patch_embedded_image_with_class_embedding</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, number_of_patches, embedding_dimension]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[[ 1.0000,  1.0000,  1.0000,  ...,  1.0000,  1.0000,  1.0000],
         [-0.8509,  0.1935, -0.0733,  ...,  0.4927, -0.4795,  0.3345],
         [-0.7782, -0.0290, -0.0858,  ...,  0.5058, -0.4762,  0.3578],
         ...,
         [-0.1418,  0.0333, -0.0511,  ...,  0.0897, -0.0767,  0.0492],
         [-0.5927,  0.0719,  0.0266,  ...,  0.2245, -0.1302, -0.2618],
         [-0.1805,  0.0180, -0.0556,  ...,  0.0914, -0.1476,  0.0110]]],
       grad_fn=&lt;CatBackward0&gt;)
Sequence of patch embeddings with class token prepended shape: torch.Size([1, 197, 768]) -&gt; [batch_size, number_of_patches, embedding_dimension]
</code></pre></div> <p>Nice! Learnable class token prepended!</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-prepending-the-learnable-class-token.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-prepending-the-learnable-class-token.png width=900 alt="going from a sequence of patch embeddings, creating a learnable class token and then prepending it to the patch embeddings"></a></p> <p><em>Reviewing what we've done to create the learnable class token, we start with a sequence of image patch embeddings created by <code>PatchEmbedding()</code> on single image, we then created a learnable class token with one value for each of the embedding dimensions and then prepended it to the original sequence of patch embeddings. </em><em>Note:</em><em> Using <code>torch.ones()</code> to create the learnable class token is mostly for demonstration purposes only, in practice, you'd likely create it with <code>torch.randn()</code>.</em></p> <h3 id=47-creating-the-position-embedding>4.7 Creating the position embedding</h3> <p>Well, we've got the class token embedding and the patch embedding, now how might we create the position embedding?</p> <p>Or <span class=arithmatex>\(\mathbf{E}_{\text {pos }}\)</span> from equation 1 where <span class=arithmatex>\(E\)</span> stands for "embedding".</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-the-position-embeddings.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-the-position-embeddings.png width=900 alt="extracting the position embeddings from the vision transformer architecture and comparing them to other sections of the vision transformer paper"></a></p> <p><em>Left: Figure 1 from the ViT paper with the position embedding we're going to recreate highlighted. Right: Equation 1 and section 3.1 of the ViT paper that relate to the position embedding.</em></p> <p>Let's find out more by reading section 3.1 of the ViT paper (bold mine):</p> <blockquote> <p>Position embeddings are added to the patch embeddings to retain positional information. We use <strong>standard learnable 1D position embeddings</strong>, since we have not observed significant performance gains from using more advanced 2D-aware position embeddings (Appendix D.4). The resulting sequence of embedding vectors serves as input to the encoder.</p> </blockquote> <p>By "retain positional information" the authors mean they want the architecture to know what "order" the patches come in. As in, patch two comes after patch one and patch three comes after patch two and on and on.</p> <p>This positional information can be important when considering what's in an image (without positional information an a flattened sequence could be seen as having no order and thus no patch relates to any other patch).</p> <p>To start creating the position embeddings, let's view our current embeddings.</p> <div class=highlight><pre><span></span><code><span class=c1># View the sequence of patch embeddings with the prepended class embedding</span>
<span class=n>patch_embedded_image_with_class_embedding</span><span class=p>,</span> <span class=n>patch_embedded_image_with_class_embedding</span><span class=o>.</span><span class=n>shape</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(tensor([[[ 1.0000,  1.0000,  1.0000,  ...,  1.0000,  1.0000,  1.0000],
          [-0.8509,  0.1935, -0.0733,  ...,  0.4927, -0.4795,  0.3345],
          [-0.7782, -0.0290, -0.0858,  ...,  0.5058, -0.4762,  0.3578],
          ...,
          [-0.1418,  0.0333, -0.0511,  ...,  0.0897, -0.0767,  0.0492],
          [-0.5927,  0.0719,  0.0266,  ...,  0.2245, -0.1302, -0.2618],
          [-0.1805,  0.0180, -0.0556,  ...,  0.0914, -0.1476,  0.0110]]],
        grad_fn=&lt;CatBackward0&gt;),
 torch.Size([1, 197, 768]))
</code></pre></div> <p>Equation 1 states that the position embeddings (<span class=arithmatex>\(\mathbf{E}_{\text {pos }}\)</span>) should have the shape <span class=arithmatex>\((N + 1) \times D\)</span>:</p> <div class=arithmatex>\[\mathbf{E}_{\text {pos }} \in \mathbb{R}^{(N+1) \times D}\]</div> <p>Where: * <span class=arithmatex>\(N=H W / P^{2}\)</span> is the resulting number of patches, which also serves as the effective input sequence length for the Transformer (number of patches). * <span class=arithmatex>\(D\)</span> is the size of the <strong>patch embeddings</strong>, different values for <span class=arithmatex>\(D\)</span> can be found in Table 1 (embedding dimension).</p> <p>Luckily we've got both of these values already.</p> <p>So let's make a learnable 1D embedding with <code>torch.ones()</code> to create <span class=arithmatex>\(\mathbf{E}_{\text {pos }}\)</span>.</p> <div class=highlight><pre><span></span><code><span class=c1># Calculate N (number of patches)</span>
<span class=n>number_of_patches</span> <span class=o>=</span> <span class=nb>int</span><span class=p>((</span><span class=n>height</span> <span class=o>*</span> <span class=n>width</span><span class=p>)</span> <span class=o>/</span> <span class=n>patch_size</span><span class=o>**</span><span class=mi>2</span><span class=p>)</span>

<span class=c1># Get embedding dimension</span>
<span class=n>embedding_dimension</span> <span class=o>=</span> <span class=n>patch_embedded_image_with_class_embedding</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>

<span class=c1># Create the learnable 1D position embedding</span>
<span class=n>position_embedding</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span>
                                             <span class=n>number_of_patches</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
                                             <span class=n>embedding_dimension</span><span class=p>),</span>
                                  <span class=n>requires_grad</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># make sure it&#39;s learnable</span>

<span class=c1># Show the first 10 sequences and 10 position embedding values and check the shape of the position embedding</span>
<span class=nb>print</span><span class=p>(</span><span class=n>position_embedding</span><span class=p>[:,</span> <span class=p>:</span><span class=mi>10</span><span class=p>,</span> <span class=p>:</span><span class=mi>10</span><span class=p>])</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Position embeddding shape: </span><span class=si>{</span><span class=n>position_embedding</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, number_of_patches, embedding_dimension]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]], grad_fn=&lt;SliceBackward0&gt;)
Position embeddding shape: torch.Size([1, 197, 768]) -&gt; [batch_size, number_of_patches, embedding_dimension]
</code></pre></div> <blockquote> <p><strong>Note:</strong> Only creating the position embedding as <code>torch.ones()</code> for demonstration purposes, in reality, you'd likely create the position embedding with <code>torch.randn()</code> (start with a random number and improve via gradient descent).</p> </blockquote> <p>Position embeddings created!</p> <p>Let's add them to our sequence of patch embeddings with a prepended class token.</p> <div class=highlight><pre><span></span><code><span class=c1># Add the position embedding to the patch and class token embedding</span>
<span class=n>patch_and_position_embedding</span> <span class=o>=</span> <span class=n>patch_embedded_image_with_class_embedding</span> <span class=o>+</span> <span class=n>position_embedding</span>
<span class=nb>print</span><span class=p>(</span><span class=n>patch_and_position_embedding</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Patch embeddings, class token prepended and positional embeddings added shape: </span><span class=si>{</span><span class=n>patch_and_position_embedding</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2> -&gt; [batch_size, number_of_patches, embedding_dimension]&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[[2.0000, 2.0000, 2.0000,  ..., 2.0000, 2.0000, 2.0000],
         [0.1491, 1.1935, 0.9267,  ..., 1.4927, 0.5205, 1.3345],
         [0.2218, 0.9710, 0.9142,  ..., 1.5058, 0.5238, 1.3578],
         ...,
         [0.8582, 1.0333, 0.9489,  ..., 1.0897, 0.9233, 1.0492],
         [0.4073, 1.0719, 1.0266,  ..., 1.2245, 0.8698, 0.7382],
         [0.8195, 1.0180, 0.9444,  ..., 1.0914, 0.8524, 1.0110]]],
       grad_fn=&lt;AddBackward0&gt;)
Patch embeddings, class token prepended and positional embeddings added shape: torch.Size([1, 197, 768]) -&gt; [batch_size, number_of_patches, embedding_dimension]
</code></pre></div> <p>Notice how the values of each of the elements in the embedding tensor increases by 1 (this is because of the position embeddings being created with <code>torch.ones()</code>).</p> <blockquote> <p><strong>Note:</strong> We could put both the class token embedding and position embedding into their own layer if we wanted to. But we'll see later on in section 8 how they can be incorporated into the overall ViT architecture's <code>forward()</code> method.</p> </blockquote> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-patch-embeddings-with-learnable-class-token-and-position-embeddings.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-patch-embeddings-with-learnable-class-token-and-position-embeddings.png width=900 alt="patch embeddings with learnable class token and position embeddings"></a></p> <p><em>The workflow we've used for adding the position embeddings to the sequence of patch embeddings and class token. </em><em>Note:</em><em> <code>torch.ones()</code> only used to create embeddings for illustration purposes, in practice, you'd likely use <code>torch.randn()</code> to start with a random number.</em></p> <h3 id=48-putting-it-all-together-from-image-to-embedding>4.8 Putting it all together: from image to embedding</h3> <p>Alright, we've come a long way in terms of turning our input images into an embedding and replicating equation 1 from section 3.1 of the ViT paper:</p> <div class=arithmatex>\[ \begin{aligned} \mathbf{z}_{0} &amp;=\left[\mathbf{x}_{\text {class }} ; \mathbf{x}_{p}^{1} \mathbf{E} ; \mathbf{x}_{p}^{2} \mathbf{E} ; \cdots ; \mathbf{x}_{p}^{N} \mathbf{E}\right]+\mathbf{E}_{\text {pos }}, &amp; &amp; \mathbf{E} \in \mathbb{R}^{\left(P^{2} \cdot C\right) \times D}, \mathbf{E}_{\text {pos }} \in \mathbb{R}^{(N+1) \times D} \end{aligned} \]</div> <p>Let's now put everything together in a single code cell and go from input image (<span class=arithmatex>\(\mathbf{x}\)</span>) to output embedding (<span class=arithmatex>\(\mathbf{z}_0\)</span>).</p> <p>We can do so by: 1. Setting the patch size (we'll use <code>16</code> as it's widely used throughout the paper and for ViT-Base). 2. Getting a single image, printing its shape and storing its height and width. 3. Adding a batch dimension to the single image so it's compatible with our <code>PatchEmbedding</code> layer. 4. Creating a <code>PatchEmbedding</code> layer (the one we made in section 4.5) with a <code>patch_size=16</code> and <code>embedding_dim=768</code> (from Table 1 for ViT-Base). 5. Passing the single image through the <code>PatchEmbedding</code> layer in 4 to create a sequence of patch embeddings. 6. Creating a class token embedding like in section 4.6. 7. Prepending the class token embedding to the patch embeddings created in step 5. 8. Creating a position embedding like in section 4.7. 9. Adding the position embedding to the class token and patch embeddings created in step 7.</p> <p>We'll also make sure to set the random seeds with <code>set_seeds()</code> and print out the shapes of different tensors along the way.</p> <div class=highlight><pre><span></span><code><span class=n>set_seeds</span><span class=p>()</span>

<span class=c1># 1. Set patch size</span>
<span class=n>patch_size</span> <span class=o>=</span> <span class=mi>16</span>

<span class=c1># 2. Print shape of original image tensor and get the image dimensions</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Image tensor shape: </span><span class=si>{</span><span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=n>height</span><span class=p>,</span> <span class=n>width</span> <span class=o>=</span> <span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>

<span class=c1># 3. Get image tensor and add batch dimension</span>
<span class=n>x</span> <span class=o>=</span> <span class=n>image</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Input image with batch dimension shape: </span><span class=si>{</span><span class=n>x</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 4. Create patch embedding layer</span>
<span class=n>patch_embedding_layer</span> <span class=o>=</span> <span class=n>PatchEmbedding</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
                                       <span class=n>patch_size</span><span class=o>=</span><span class=n>patch_size</span><span class=p>,</span>
                                       <span class=n>embedding_dim</span><span class=o>=</span><span class=mi>768</span><span class=p>)</span>

<span class=c1># 5. Pass image through patch embedding layer</span>
<span class=n>patch_embedding</span> <span class=o>=</span> <span class=n>patch_embedding_layer</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Patching embedding shape: </span><span class=si>{</span><span class=n>patch_embedding</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 6. Create class token embedding</span>
<span class=n>batch_size</span> <span class=o>=</span> <span class=n>patch_embedding</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=n>embedding_dimension</span> <span class=o>=</span> <span class=n>patch_embedding</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
<span class=n>class_token</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=n>batch_size</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>embedding_dimension</span><span class=p>),</span>
                           <span class=n>requires_grad</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># make sure it&#39;s learnable</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Class token embedding shape: </span><span class=si>{</span><span class=n>class_token</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 7. Prepend class token embedding to patch embedding</span>
<span class=n>patch_embedding_class_token</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>cat</span><span class=p>((</span><span class=n>class_token</span><span class=p>,</span> <span class=n>patch_embedding</span><span class=p>),</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Patch embedding with class token shape: </span><span class=si>{</span><span class=n>patch_embedding_class_token</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>

<span class=c1># 8. Create position embedding</span>
<span class=n>number_of_patches</span> <span class=o>=</span> <span class=nb>int</span><span class=p>((</span><span class=n>height</span> <span class=o>*</span> <span class=n>width</span><span class=p>)</span> <span class=o>/</span> <span class=n>patch_size</span><span class=o>**</span><span class=mi>2</span><span class=p>)</span>
<span class=n>position_embedding</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>number_of_patches</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>embedding_dimension</span><span class=p>),</span>
                                  <span class=n>requires_grad</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># make sure it&#39;s learnable</span>

<span class=c1># 9. Add position embedding to patch embedding with class token</span>
<span class=n>patch_and_position_embedding</span> <span class=o>=</span> <span class=n>patch_embedding_class_token</span> <span class=o>+</span> <span class=n>position_embedding</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Patch and position embedding shape: </span><span class=si>{</span><span class=n>patch_and_position_embedding</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Image tensor shape: torch.Size([3, 224, 224])
Input image with batch dimension shape: torch.Size([1, 3, 224, 224])
Patching embedding shape: torch.Size([1, 196, 768])
Class token embedding shape: torch.Size([1, 1, 768])
Patch embedding with class token shape: torch.Size([1, 197, 768])
Patch and position embedding shape: torch.Size([1, 197, 768])
</code></pre></div> <p>Woohoo!</p> <p>From a single image to patch and position embeddings in a single cell of code.</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-putting-it-all-together.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-1-putting-it-all-together.png width=900 alt="mapping equation 1 from the vision transformer paper to pytorch code"></a></p> <p><em>Mapping equation 1 from the ViT paper to our PyTorch code. This is the essence of paper replicating, taking a research paper and turning it into usable code.</em></p> <p>Now we've got a way to encode our images and pass them to the Transformer Encoder in Figure 1 of the ViT paper.</p> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-architecture-animation-full-architecture.gif data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-architecture-animation-full-architecture.gif width=900/ alt="Vision transformer architecture animation, going from a single image and passing it through a patch embedidng layer and then passing it through the transformer encoder."></a></p> <p><em>Animating the entire ViT workflow: from patch embeddings to transformer encoder to MLP head.</em></p> <p>From a code perspective, creating the patch embedding is probably the largest section of replicating the ViT paper.</p> <p>Many of the other parts of the ViT paper such as the Multi-Head Attention and Norm layers can be created using existing PyTorch layers.</p> <p>Onwards!</p> <h2 id=5-equation-2-multi-head-attention-msa>5. Equation 2: Multi-Head Attention (MSA)</h2> <p>We've got our input data patchified and embedded, now let's move onto the next part of the ViT architecture.</p> <p>To start, we'll break down the Transformer Encoder section into two parts (start small and increase when necessary).</p> <p>The first being equation 2 and the second being equation 3.</p> <p>Recall equation 2 states:</p> <div class=arithmatex>\[ \begin{aligned} \mathbf{z}_{\ell}^{\prime} &amp;=\operatorname{MSA}\left(\operatorname{LN}\left(\mathbf{z}_{\ell-1}\right)\right)+\mathbf{z}_{\ell-1}, &amp; &amp; \ell=1 \ldots L \end{aligned} \]</div> <p>This indicates a Multi-Head Attention (MSA) layer wrapped in a LayerNorm (LN) layer with a residual connection (the input to the layer gets added to the output of the layer).</p> <p>We'll refer to equation 2 as the "MSA block".</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-2-msa-block-mapped-to-equation.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-2-msa-block-mapped-to-equation.png width=900/ alt="mapping equation 2 from the ViT paper to the ViT architecture diagram in figure 1"></a></p> <p><strong><em>Left:</em>* Figure 1 from the ViT paper with Multi-Head Attention and Norm layers as well as the residual connection (+) highlighted within the Transformer Encoder block. </strong>Right:*<em> Mapping the Multi-Head Self Attention (MSA) layer, Norm layer and residual connection to their respective parts of equation 2 in the ViT paper.</em></p> <p>Many layers you find in research papers are already implemented in modern deep learning frameworks such as PyTorch.</p> <p>In saying this, to replicate these layers and residual connection with PyTorch code we can use: * <strong>Multi-Head Self Attention (MSA)</strong> - <a href=https://pytorch.org/docs/stable/generated/torch.nn.MultiheadAttention.html><code>torch.nn.MultiheadAttention()</code></a>. * <strong>Norm (LN or LayerNorm)</strong> - <a href=https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html><code>torch.nn.LayerNorm()</code></a>. * <strong>Residual connection</strong> - add the input to output (we'll see this later on when we create the full Transformer Encoder block in section 7.1).</p> <h3 id=51-the-layernorm-ln-layer>5.1 The LayerNorm (LN) layer</h3> <p><a href=https://paperswithcode.com/method/layer-normalization>Layer Normalization</a> (<code>torch.nn.LayerNorm()</code> or Norm or LayerNorm or LN) normalizes an input over the last dimension.</p> <p>You can find the formal definition of <code>torch.nn.LayerNorm()</code> in the <a href=https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html>PyTorch documentation</a>.</p> <p>PyTorch's <code>torch.nn.LayerNorm()</code>'s main parameter is <code>normalized_shape</code> which we can set to be equal to the dimension size we'd like to noramlize over (in our case it'll be <span class=arithmatex>\(D\)</span> or <code>768</code> for ViT-Base).</p> <p>What does it do?</p> <p>Layer Normalization helps improve training time and model generalization (ability to adapt to unseen data).</p> <p>I like to think of any kind of normalization as "getting the data into a similar format" or "getting data samples into a similar distribution".</p> <p>Imagine trying to walk up (or down) a set of stairs all with differing heights and lengths.</p> <p>It'd take some adjustment on each step right?</p> <p>And what you learn for each step wouldn't necessary help with the next one since they all differ, increasing the time it takes you to navigate the stairs.</p> <p>Normalization (including Layer Normalization) is the equivalent of making all the stairs the same height and length except the stairs are your data samples.</p> <p>So just like you can walk up (or down) stairs with similar heights and lengths much easier than those with unequal heights and widths, neural networks can optimize over data samples with similar distributions (similar mean and standard-deviations) easier than those with varying distributions.</p> <h3 id=52-the-multi-head-self-attention-msa-layer>5.2 The Multi-Head Self Attention (MSA) layer</h3> <p>The power of the self-attention and multi-head attention (self-attention applied multiple times) were revealed in the form of the original Transformer architecture introduced in the <a href=https://arxiv.org/abs/1706.03762><em>Attention is all you need</em></a> research paper.</p> <p>Originally designed for text inputs, the original self-attention mechanism takes a sequence of words and then calculates which word should pay more "attention" to another word.</p> <p>In other words, in the sentence "the dog jumped over the fence", perhaps the word "dog" relates strongly to "jumped" and "fence".</p> <p>This is simplified but the premise remains for images.</p> <p>Since our input is a sequence of image patches rather than words, self-attention and in turn multi-head attention will calculate which patch of an image is most related to another patch, eventually forming a learned representation of an image.</p> <p>But what's most important is that the layer does this on it's own given the data (we don't tell it what patterns to learn).</p> <p>And if the learned representation the layers form using MSA are good, we'll see the results in our model's performance.</p> <p>There are many resources online to learn more about the Transformer architeture and attention mechanism online such as Jay Alammar's wonderful <a href=https://jalammar.github.io/illustrated-transformer/ >Illustrated Transformer post</a> and <a href=https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/ >Illustrated Attention post</a>.</p> <p>We're going to focus more on coding an existing PyTorch MSA implementation than creating our own.</p> <p>However, you can find the formal defintion of the ViT paper's MSA implementation is defined in Appendix A:</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-2-appendix-A.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-2-appendix-A.png width=900/ alt="vision transformer paper figure 1 highlighted with equation 2 and appendix A"></a></p> <p><strong><em>Left:</em>* Vision Transformer architecture overview from Figure 1 of the ViT paper. </strong>Right:*<em> Definitions of equation 2, section 3.1 and Appendix A of the ViT paper highlighted to reflect their respective parts in Figure 1.</em></p> <p>The image above highlights the triple embedding input to the MSA layer.</p> <p>This is known as <strong>query, key, value</strong> input or <strong>qkv</strong> for short which is fundamental to the self-attention mechanism.</p> <p>In our case, the triple embedding input will be three versions of the output of the Norm layer, one for query, key and value.</p> <p>Or three versions of our layer-normalized image patch and position embeddings created in section 4.8.</p> <p>We can implement the MSA layer in PyTorch with <code>torch.nn.MultiheadAttention()</code> with the parameters: * <code>embed_dim</code> - the embedding dimension from Table 1 (Hidden size <span class=arithmatex>\(D\)</span>). * <code>num_heads</code> - how many attention heads to use (this is where the term "multihead" comes from), this value is also in Table 1 (Heads). * <code>dropout</code> - whether or not to apply dropout to the attention layer (according to Appendix B.1, dropout isn't used after the qkv-projections). * <code>batch_first</code> - does our batch dimension come first? (yes it does)</p> <h3 id=53-replicating-equation-2-with-pytorch-layers>5.3 Replicating Equation 2 with PyTorch layers</h3> <p>Let's put everything we've discussed about the LayerNorm (LN) and Multi-Head Attention (MSA) layers in equation 2 into practice.</p> <p>To do so, we'll: </p> <ol> <li>Create a class called <code>MultiheadSelfAttentionBlock</code> that inherits from <code>torch.nn.Module</code>.</li> <li>Initialize the class with hyperparameters from Table 1 of the ViT paper for the ViT-Base model.</li> <li>Create a layer normalization (LN) layer with <code>torch.nn.LayerNorm()</code> with the <code>normalized_shape</code> parameter the same as our embedding dimension (<span class=arithmatex>\(D\)</span> from Table 1).</li> <li>Create a multi-head attention (MSA) layer with the appropriate <code>embed_dim</code>, <code>num_heads</code>, <code>dropout</code> and <code>batch_first</code> parameters.</li> <li>Create a <code>forward()</code> method for our class passing the in the inputs through the LN layer and MSA layer.</li> </ol> <div class=highlight><pre><span></span><code><span class=c1># 1. Create a class that inherits from nn.Module</span>
<span class=k>class</span><span class=w> </span><span class=nc>MultiheadSelfAttentionBlock</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Creates a multi-head self-attention block (&quot;MSA block&quot; for short).</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># 2. Initialize the class with hyperparameters from Table 1</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
                 <span class=n>embedding_dim</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># Hidden size D from Table 1 for ViT-Base</span>
                 <span class=n>num_heads</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>12</span><span class=p>,</span> <span class=c1># Heads from Table 1 for ViT-Base</span>
                 <span class=n>attn_dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span> <span class=c1># doesn&#39;t look like the paper uses any dropout in MSABlocks</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>

        <span class=c1># 3. Create the Norm layer (LN)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>layer_norm</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>LayerNorm</span><span class=p>(</span><span class=n>normalized_shape</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>)</span>

        <span class=c1># 4. Create the Multi-Head Attention (MSA) layer</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>multihead_attn</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>MultiheadAttention</span><span class=p>(</span><span class=n>embed_dim</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                                                    <span class=n>num_heads</span><span class=o>=</span><span class=n>num_heads</span><span class=p>,</span>
                                                    <span class=n>dropout</span><span class=o>=</span><span class=n>attn_dropout</span><span class=p>,</span>
                                                    <span class=n>batch_first</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># does our batch dimension come first?</span>

    <span class=c1># 5. Create a forward() method to pass the data throguh the layers</span>
    <span class=k>def</span><span class=w> </span><span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>layer_norm</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=n>attn_output</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>multihead_attn</span><span class=p>(</span><span class=n>query</span><span class=o>=</span><span class=n>x</span><span class=p>,</span> <span class=c1># query embeddings</span>
                                             <span class=n>key</span><span class=o>=</span><span class=n>x</span><span class=p>,</span> <span class=c1># key embeddings</span>
                                             <span class=n>value</span><span class=o>=</span><span class=n>x</span><span class=p>,</span> <span class=c1># value embeddings</span>
                                             <span class=n>need_weights</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=c1># do we need the weights or just the layer outputs?</span>
        <span class=k>return</span> <span class=n>attn_output</span>
</code></pre></div> <blockquote> <p><strong>Note:</strong> Unlike Figure 1, our <code>MultiheadSelfAttentionBlock</code> doesn't include a skip or residual connection ("<span class=arithmatex>\(+\mathbf{z}_{\ell-1}\)</span>" in equation 2), we'll include this when we create the entire Transformer Encoder later on in section 7.1.</p> </blockquote> <p>MSABlock created!</p> <p>Let's try it out by create an instance of our <code>MultiheadSelfAttentionBlock</code> and passing through the <code>patch_and_position_embedding</code> variable we created in section 4.8.</p> <div class=highlight><pre><span></span><code><span class=c1># Create an instance of MSABlock</span>
<span class=n>multihead_self_attention_block</span> <span class=o>=</span> <span class=n>MultiheadSelfAttentionBlock</span><span class=p>(</span><span class=n>embedding_dim</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># from Table 1</span>
                                                             <span class=n>num_heads</span><span class=o>=</span><span class=mi>12</span><span class=p>)</span> <span class=c1># from Table 1</span>

<span class=c1># Pass patch and position image embedding through MSABlock</span>
<span class=n>patched_image_through_msa_block</span> <span class=o>=</span> <span class=n>multihead_self_attention_block</span><span class=p>(</span><span class=n>patch_and_position_embedding</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Input shape of MSA block: </span><span class=si>{</span><span class=n>patch_and_position_embedding</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output shape MSA block: </span><span class=si>{</span><span class=n>patched_image_through_msa_block</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Input shape of MSA block: torch.Size([1, 197, 768])
Output shape MSA block: torch.Size([1, 197, 768])
</code></pre></div> <p>Notice how the input and output shape of our data stays the same when it goes through the MSA block.</p> <p>This doesn't mean the data doesn't change as it goes through.</p> <p>You could try printing the input and output tensor to see how it changes (though this change will be across <code>1 * 197 * 768</code> values and could be hard to visualize).</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-2-in-code.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-2-in-code.png width=900 alt="vision transformer paper with equation 2 of figure 1 highlighted and equation 2 turned into code"></a></p> <p><strong><em>Left:</em>* Vision Transformer architecture from Figure 1 with Multi-Head Attention and LayerNorm layers highlighted, these layers make up equation 2 from section 3.1 of the paper. </strong>Right:*<em> Replicating equation 2 (without the skip connection on the end) using PyTorch layers.</em></p> <p>We've now officially replicated equation 2 (except for the residual connection on the end but we'll get to this in section 7.1)!</p> <p>Onto the next!</p> <h2 id=6-equation-3-multilayer-perceptron-mlp>6. Equation 3: Multilayer Perceptron (MLP)</h2> <p>We're on a roll here!</p> <p>Let's keep it going and replicate equation 3:</p> <div class=arithmatex>\[ \begin{aligned} \mathbf{z}_{\ell} &amp;=\operatorname{MLP}\left(\operatorname{LN}\left(\mathbf{z}_{\ell}^{\prime}\right)\right)+\mathbf{z}_{\ell}^{\prime}, &amp; &amp; \ell=1 \ldots L \end{aligned} \]</div> <p>Here MLP stands for "multilayer perceptron" and LN stands for "layer normalization" (as discussed above).</p> <p>And the addition on the end is the skip/residual connection.</p> <p>We'll refer to equation 3 as the "MLP block" of the Transformer encoder (notice how we're continuing the trend of breaking down the architecture into smaller chunks).</p> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-equation-3-annotated.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-equation-3-annotated.png width=900/ alt="mapping equation 3 from the ViT paper to the ViT architecture diagram in figure 1"></a></p> <p><strong><em>Left:</em>* Figure 1 from the ViT paper with MLP and Norm layers as well as the residual connection (+) highlighted within the Transformer Encoder block. </strong>Right:*<em> Mapping the multilayer perceptron (MLP) layer, Norm layer (LN) and residual connection to their respective parts of equation 3 in the ViT paper.</em></p> <h3 id=61-the-mlp-layers>6.1 The MLP layer(s)</h3> <p>The term <a href=https://en.wikipedia.org/wiki/Multilayer_perceptron>MLP</a> is quite broad as it can refer to almost any combination of <em>multiple</em> layers (hence the "multi" in multilayer perceptron).</p> <p>But it generally follows the pattern of:</p> <p><code>linear layer -&gt; non-linear layer -&gt; linear layer -&gt; non-linear layer</code></p> <p>In the the case of the ViT paper, the MLP structure is defined in section 3.1:</p> <blockquote> <p>The MLP contains two layers with a GELU non-linearity.</p> </blockquote> <p>Where "two layers" refers to linear layers (<a href=https://pytorch.org/docs/stable/generated/torch.nn.Linear.html><code>torch.nn.Linear()</code></a> in PyTorch) and "GELU non-linearity" is the GELU (Gaussian Error Linear Units) non-linear activation function (<a href=https://pytorch.org/docs/stable/generated/torch.nn.GELU.html><code>torch.nn.GELU()</code></a> in PyTorch).</p> <blockquote> <p><strong>Note:</strong> A linear layer (<code>torch.nn.Linear()</code>) can sometimes also be referred to as a "dense layer" or "feedforward layer". Some papers even use all three terms to describe the same thing (as in the ViT paper).</p> </blockquote> <p>Another sneaky detail about the MLP block doesn't appear until Appendix B.1 (Training):</p> <blockquote> <p>Table 3 summarizes our training setups for our different models. ...Dropout, when used, is applied <strong>after every dense layer except for the the qkv-projections and directly after adding positional- to patch embeddings.</strong></p> </blockquote> <p>This means that every linear layer (or dense layer) in the MLP block has a dropout layer (<a href=https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html><code>torch.nn.Dropout()</code></a> in PyTorch).</p> <p>The value of which can be found in Table 3 of the ViT paper (for ViT-Base, <code>dropout=0.1</code>).</p> <p>Knowing this, the structure of our MLP block will be:</p> <p><code>layer norm -&gt; linear layer -&gt; non-linear layer -&gt; dropout -&gt; linear layer -&gt; dropout</code></p> <p>With hyperparameter values for the linear layers available from Table 1 (MLP size is the number of hidden units between the linear layers and hidden size <span class=arithmatex>\(D\)</span> is the output size of the MLP block).</p> <h3 id=62-replicating-equation-3-with-pytorch-layers>6.2 Replicating Equation 3 with PyTorch layers</h3> <p>Let's put everything we've discussed about the LayerNorm (LN) and MLP (MSA) layers in equation 3 into practice.</p> <p>To do so, we'll: </p> <ol> <li>Create a class called <code>MLPBlock</code> that inherits from <code>torch.nn.Module</code>.</li> <li>Initialize the class with hyperparameters from Table 1 and Table 3 of the ViT paper for the ViT-Base model.</li> <li>Create a layer normalization (LN) layer with <code>torch.nn.LayerNorm()</code> with the <code>normalized_shape</code> parameter the same as our embedding dimension (<span class=arithmatex>\(D\)</span> from Table 1).</li> <li>Create a sequential series of MLP layers(s) using <code>torch.nn.Linear()</code>, <code>torch.nn.Dropout()</code> and <code>torch.nn.GELU()</code> with appropriate hyperparameter values from Table 1 and Table 3.</li> <li>Create a <code>forward()</code> method for our class passing the in the inputs through the LN layer and MLP layer(s).</li> </ol> <div class=highlight><pre><span></span><code><span class=c1># 1. Create a class that inherits from nn.Module</span>
<span class=k>class</span><span class=w> </span><span class=nc>MLPBlock</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Creates a layer normalized multilayer perceptron block (&quot;MLP block&quot; for short).&quot;&quot;&quot;</span>
    <span class=c1># 2. Initialize the class with hyperparameters from Table 1 and Table 3</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
                 <span class=n>embedding_dim</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># Hidden Size D from Table 1 for ViT-Base</span>
                 <span class=n>mlp_size</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>3072</span><span class=p>,</span> <span class=c1># MLP size from Table 1 for ViT-Base</span>
                 <span class=n>dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mf>0.1</span><span class=p>):</span> <span class=c1># Dropout from Table 3 for ViT-Base</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>

        <span class=c1># 3. Create the Norm layer (LN)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>layer_norm</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>LayerNorm</span><span class=p>(</span><span class=n>normalized_shape</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>)</span>

        <span class=c1># 4. Create the Multilayer perceptron (MLP) layer(s)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>mlp</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>in_features</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                      <span class=n>out_features</span><span class=o>=</span><span class=n>mlp_size</span><span class=p>),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>GELU</span><span class=p>(),</span> <span class=c1># &quot;The MLP contains two layers with a GELU non-linearity (section 3.1).&quot;</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Dropout</span><span class=p>(</span><span class=n>p</span><span class=o>=</span><span class=n>dropout</span><span class=p>),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>in_features</span><span class=o>=</span><span class=n>mlp_size</span><span class=p>,</span> <span class=c1># needs to take same in_features as out_features of layer above</span>
                      <span class=n>out_features</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>),</span> <span class=c1># take back to embedding_dim</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Dropout</span><span class=p>(</span><span class=n>p</span><span class=o>=</span><span class=n>dropout</span><span class=p>)</span> <span class=c1># &quot;Dropout, when used, is applied after every dense layer..&quot;</span>
        <span class=p>)</span>

    <span class=c1># 5. Create a forward() method to pass the data throguh the layers</span>
    <span class=k>def</span><span class=w> </span><span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>layer_norm</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>mlp</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>x</span>
</code></pre></div> <blockquote> <p><strong>Note:</strong> Unlike Figure 1, our <code>MLPBlock()</code> doesn't include a skip or residual connection ("<span class=arithmatex>\(+\mathbf{z}_{\ell}^{\prime}\)</span>" in equation 3), we'll include this when we create the entire Transformer encoder later on.</p> </blockquote> <p>MLPBlock class created!</p> <p>Let's try it out by create an instance of our <code>MLPBlock</code> and passing through the <code>patched_image_through_msa_block</code> variable we created in section 5.3.</p> <div class=highlight><pre><span></span><code><span class=c1># Create an instance of MLPBlock</span>
<span class=n>mlp_block</span> <span class=o>=</span> <span class=n>MLPBlock</span><span class=p>(</span><span class=n>embedding_dim</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># from Table 1</span>
                     <span class=n>mlp_size</span><span class=o>=</span><span class=mi>3072</span><span class=p>,</span> <span class=c1># from Table 1</span>
                     <span class=n>dropout</span><span class=o>=</span><span class=mf>0.1</span><span class=p>)</span> <span class=c1># from Table 3</span>

<span class=c1># Pass output of MSABlock through MLPBlock</span>
<span class=n>patched_image_through_mlp_block</span> <span class=o>=</span> <span class=n>mlp_block</span><span class=p>(</span><span class=n>patched_image_through_msa_block</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Input shape of MLP block: </span><span class=si>{</span><span class=n>patched_image_through_msa_block</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Output shape MLP block: </span><span class=si>{</span><span class=n>patched_image_through_mlp_block</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Input shape of MLP block: torch.Size([1, 197, 768])
Output shape MLP block: torch.Size([1, 197, 768])
</code></pre></div> <p>Notice how the input and output shape of our data again stays the same when it goes in and out of the MLP block.</p> <p>However, the shape does change when the data gets passed through the <code>nn.Linear()</code> layers within the MLP block (expanded to MLP size from Table 1 and then compressed back to Hidden size <span class=arithmatex>\(D\)</span> from Table 1).</p> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-3-mapped-to-code.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-equation-3-mapped-to-code.png width=900 alt="vision transformer paper with equation 3 of figure 1 highlighted and equation 3 turned into code"></a></p> <p><em>Left: Vision Transformer architecture from Figure 1 with MLP and Norm layers highlighted, these layers make up equation 3 from section 3.1 of the paper. Right: Replicating equation 3 (without the skip connection on the end) using PyTorch layers.</em></p> <p>Ho ho!</p> <p>Equation 3 replicated (except for the residual connection on the end but we'll get to this in section 7.1)!</p> <p>Now we've got equation's 2 and 3 in PyTorch code, let's now put them together to create the Transformer Encoder.</p> <h2 id=7-create-the-transformer-encoder>7. Create the Transformer Encoder</h2> <p>Time to stack together our <code>MultiheadSelfAttentionBlock</code> (equation 2) and <code>MLPBlock</code> (equation 3) and create the Transformer Encoder of the ViT architecture.</p> <p>In deep learning, an <a href=https://paperswithcode.com/method/autoencoder>"encoder" or "auto encoder"</a> generally refers to a stack of layers that "encodes" an input (turns it into some form of numerical representation).</p> <p>In our case, the Transformer Encoder will encode our patched image embedding into a learned representation using a series of alternating layers of MSA blocks and MLP blocks, as per section 3.1 of the ViT Paper:</p> <blockquote> <p>The Transformer encoder (Vaswani et al., 2017) consists of alternating layers of multiheaded selfattention (MSA, see Appendix A) and MLP blocks (Eq. 2, 3). <strong>Layernorm (LN) is applied before every block</strong>, and <strong>residual connections after every block</strong> (Wang et al., 2019; Baevski &amp; Auli, 2019).</p> </blockquote> <p>We've created MSA and MLP blocks but what about the residual connections?</p> <p><a href=https://paperswithcode.com/method/residual-connection>Residual connections</a> (also called skip connections), were first introduced in the paper <a href=https://arxiv.org/abs/1512.03385v1><em>Deep Residual Learning for Image Recognition</em></a> and are achieved by adding a layer(s) input to its subsequent output.</p> <p>Where the subsequence output might be one or more layers later.</p> <p>In the case of the ViT architecture, the residual connection means the input of the MSA block is added back to the output of the MSA block before it passes to the MLP block.</p> <p>And the same thing happens with the MLP block before it goes onto the next Transformer Encoder block.</p> <p>Or in pseudocode:</p> <p><code>x_input -&gt; MSA_block -&gt; [MSA_block_output + x_input] -&gt; MLP_block -&gt; [MLP_block_output + MSA_block_output + x_input] -&gt; ...</code></p> <p>What does this do?</p> <p>One of the main ideas behind residual connections is that they prevent weight values and gradient updates from getting too small and thus allow deeper networks and in turn allow deeper representations to be learned.</p> <blockquote> <p><strong>Note:</strong> The iconic computer vision architecture "ResNet" is named so because of the introduction of <em>res</em>idual connections. You can find many pretrained versions of ResNet architectures in <a href=https://pytorch.org/vision/stable/models.html><code>torchvision.models</code></a>.</p> </blockquote> <h3 id=71-creating-a-transformer-encoder-by-combining-our-custom-made-layers>7.1 Creating a Transformer Encoder by combining our custom made layers</h3> <p>Enough talk, let's see this in action and make a ViT Transformer Encoder with PyTorch by combining our previously created layers.</p> <p>To do so, we'll: </p> <ol> <li>Create a class called <code>TransformerEncoderBlock</code> that inherits from <code>torch.nn.Module</code>.</li> <li>Initialize the class with hyperparameters from Table 1 and Table 3 of the ViT paper for the ViT-Base model.</li> <li>Instantiate a MSA block for equation 2 using our <code>MultiheadSelfAttentionBlock</code> from section 5.2 with the appropriate parameters.</li> <li>Instantiate a MLP block for equation 3 using our <code>MLPBlock</code> from section 6.2 with the appropriate parameters.</li> <li>Create a <code>forward()</code> method for our <code>TransformerEncoderBlock</code> class.</li> <li>Create a residual connection for the MSA block (for equation 2).</li> <li>Create a residual connection for the MLP block (for equation 3).</li> </ol> <div class=highlight><pre><span></span><code><span class=c1># 1. Create a class that inherits from nn.Module</span>
<span class=k>class</span><span class=w> </span><span class=nc>TransformerEncoderBlock</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Creates a Transformer Encoder block.&quot;&quot;&quot;</span>
    <span class=c1># 2. Initialize the class with hyperparameters from Table 1 and Table 3</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
                 <span class=n>embedding_dim</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># Hidden size D from Table 1 for ViT-Base</span>
                 <span class=n>num_heads</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>12</span><span class=p>,</span> <span class=c1># Heads from Table 1 for ViT-Base</span>
                 <span class=n>mlp_size</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>3072</span><span class=p>,</span> <span class=c1># MLP size from Table 1 for ViT-Base</span>
                 <span class=n>mlp_dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=c1># Amount of dropout for dense layers from Table 3 for ViT-Base</span>
                 <span class=n>attn_dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span> <span class=c1># Amount of dropout for attention layers</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>

        <span class=c1># 3. Create MSA block (equation 2)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>msa_block</span> <span class=o>=</span> <span class=n>MultiheadSelfAttentionBlock</span><span class=p>(</span><span class=n>embedding_dim</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                                                     <span class=n>num_heads</span><span class=o>=</span><span class=n>num_heads</span><span class=p>,</span>
                                                     <span class=n>attn_dropout</span><span class=o>=</span><span class=n>attn_dropout</span><span class=p>)</span>

        <span class=c1># 4. Create MLP block (equation 3)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>mlp_block</span> <span class=o>=</span>  <span class=n>MLPBlock</span><span class=p>(</span><span class=n>embedding_dim</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                                   <span class=n>mlp_size</span><span class=o>=</span><span class=n>mlp_size</span><span class=p>,</span>
                                   <span class=n>dropout</span><span class=o>=</span><span class=n>mlp_dropout</span><span class=p>)</span>

    <span class=c1># 5. Create a forward() method</span>
    <span class=k>def</span><span class=w> </span><span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>

        <span class=c1># 6. Create residual connection for MSA block (add the input to the output)</span>
        <span class=n>x</span> <span class=o>=</span>  <span class=bp>self</span><span class=o>.</span><span class=n>msa_block</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=n>x</span>

        <span class=c1># 7. Create residual connection for MLP block (add the input to the output)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>mlp_block</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=n>x</span>

        <span class=k>return</span> <span class=n>x</span>
</code></pre></div> <p>Beautiful!</p> <p>Transformer Encoder block created!</p> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-transformer-encoder-highlighted.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-transformer-encoder-highlighted.png width=900 alt="vision transformer architecture with transformer encoder blocks highlighted"></a></p> <p><strong><em>Left:</em>* Figure 1 from the ViT paper with the Transformer Encoder of the ViT architecture highlighted. </strong>Right:*<em> Transformer Encoder mapped to equation 2 and 3 of the ViT paper, the Transformer Encoder is comprised of alternating blocks of equation 2 (Multi-Head Attention) and equation 3 (Multilayer perceptron).</em></p> <p>See how we're starting to piece together the overall architecture like legos, coding one brick (or equation) at a time.</p> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-transformer-encoder-mapped-to-code.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-transformer-encoder-mapped-to-code.png width=900 alt="vision transformer architecture transformer encoder block mapped to code"></a></p> <p><em>Mapping the ViT Transformer Encoder to code.</em></p> <p>You might've noticed that Table 1 from the ViT paper has a Layers column. This refers to the number of Transformer Encoder blocks in the specific ViT architecure.</p> <p>In our case, for ViT-Base, we'll be stacking together 12 of these Transformer Encoder blocks to form the backbone of our architecture (we'll get to this in section 8).</p> <p>Let's get a <code>torchinfo.summary()</code> of passing an input of shape <code>(1, 197, 768) -&gt; (batch_size, num_patches, embedding_dimension)</code> to our Transformer Encoder block.</p> <div class=highlight><pre><span></span><code><span class=c1># Create an instance of TransformerEncoderBlock</span>
<span class=n>transformer_encoder_block</span> <span class=o>=</span> <span class=n>TransformerEncoderBlock</span><span class=p>()</span>

<span class=c1># # Print an input and output summary of our Transformer Encoder (uncomment for full output)</span>
<span class=c1># summary(model=transformer_encoder_block,</span>
<span class=c1>#         input_size=(1, 197, 768), # (batch_size, num_patches, embedding_dimension)</span>
<span class=c1>#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class=c1>#         col_width=20,</span>
<span class=c1>#         row_settings=[&quot;var_names&quot;])</span>
</code></pre></div> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-summary-output-transformer-encoder.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-summary-output-transformer-encoder.png width=900/ alt="summary output of a Transformer Encoder layer in PyTorch"></a></p> <p>Woah! Check out all those parameters!</p> <p>You can see our input changing shape as it moves through all of the various layers in the MSA block and MLP block of the Transformer Encoder block before finally returning to its original shape at the very end.</p> <blockquote> <p><strong>Note:</strong> Just because our input to the Transformer Encoder block has the same shape at the output of the block doesn't mean the values weren't manipulated, the whole goal of the Transformer Encoder block (and stacking them together) is to learn a deep representation of the input using the various layers in between.</p> </blockquote> <h3 id=72-creating-a-transformer-encoder-with-pytorchs-transformer-layers>7.2 Creating a Transformer Encoder with PyTorch's Transformer layers</h3> <p>So far we've built the components of and the Transformer Encoder layer itself ourselves.</p> <p>But because of their rise in popularity and effectiveness, PyTorch now has in-built <a href=https://pytorch.org/docs/stable/nn.html#transformer-layers>Transformer layers as part of <code>torch.nn</code></a>.</p> <p>For example, we can recreate the <code>TransformerEncoderBlock</code> we just created using <a href=https://pytorch.org/docs/stable/generated/torch.nn.TransformerEncoderLayer.html#torch.nn.TransformerEncoderLayer><code>torch.nn.TransformerEncoderLayer()</code></a> and setting the same hyperparameters as above.</p> <div class=highlight><pre><span></span><code><span class=c1># Create the same as above with torch.nn.TransformerEncoderLayer()</span>
<span class=n>torch_transformer_encoder_layer</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>TransformerEncoderLayer</span><span class=p>(</span><span class=n>d_model</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># Hidden size D from Table 1 for ViT-Base</span>
                                                             <span class=n>nhead</span><span class=o>=</span><span class=mi>12</span><span class=p>,</span> <span class=c1># Heads from Table 1 for ViT-Base</span>
                                                             <span class=n>dim_feedforward</span><span class=o>=</span><span class=mi>3072</span><span class=p>,</span> <span class=c1># MLP size from Table 1 for ViT-Base</span>
                                                             <span class=n>dropout</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=c1># Amount of dropout for dense layers from Table 3 for ViT-Base</span>
                                                             <span class=n>activation</span><span class=o>=</span><span class=s2>&quot;gelu&quot;</span><span class=p>,</span> <span class=c1># GELU non-linear activation</span>
                                                             <span class=n>batch_first</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=c1># Do our batches come first?</span>
                                                             <span class=n>norm_first</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># Normalize first or after MSA/MLP layers?</span>

<span class=n>torch_transformer_encoder_layer</span>
</code></pre></div> <div class=highlight><pre><span></span><code>TransformerEncoderLayer(
  (self_attn): MultiheadAttention(
    (out_proj): NonDynamicallyQuantizableLinear(in_features=768, out_features=768, bias=True)
  )
  (linear1): Linear(in_features=768, out_features=3072, bias=True)
  (dropout): Dropout(p=0.1, inplace=False)
  (linear2): Linear(in_features=3072, out_features=768, bias=True)
  (norm1): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
  (norm2): LayerNorm((768,), eps=1e-05, elementwise_affine=True)
  (dropout1): Dropout(p=0.1, inplace=False)
  (dropout2): Dropout(p=0.1, inplace=False)
)
</code></pre></div> <p>To inspect it further, let's get a summary with <code>torchinfo.summary()</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># # Get the output of PyTorch&#39;s version of the Transformer Encoder (uncomment for full output)</span>
<span class=c1># summary(model=torch_transformer_encoder_layer,</span>
<span class=c1>#         input_size=(1, 197, 768), # (batch_size, num_patches, embedding_dimension)</span>
<span class=c1>#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class=c1>#         col_width=20,</span>
<span class=c1>#         row_settings=[&quot;var_names&quot;])</span>
</code></pre></div> <p><a class=glightbox href=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-summary-output-pytorch-transformer-encoder.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://github.com/mrdbourke/pytorch-deep-learning/raw/main/images/08-vit-paper-summary-output-pytorch-transformer-encoder.png width=900/ alt="output summary of PyTorch's implementation of the Transformer Encoder layer"></a></p> <p>The output of the summary is slightly different to ours due to how <code>torch.nn.TransformerEncoderLayer()</code> constructs its layer.</p> <p>But the layers it uses, number of parameters and input and output shapes are the same.</p> <p>You might be thinking, "if we could create the Transformer Encoder so quickly with PyTorch layers, why did we bother reproducing equation 2 and 3?"</p> <p>The answer is: practice.</p> <p>Now we've replicated a series of equations and layers from a paper, if you need to change the layers and try something different you can.</p> <p>But there are benefits of using the PyTorch pre-built layers, such as: * <strong>Less prone to errors</strong> - Generally, if a layer makes it into the PyTorch standard library, its been tested and tried to work. * <strong>Potentially better performance</strong> - As of July 2022 and PyTorch 1.12, the PyTorch implemented version of <code>torch.nn.TransformerEncoderLayer()</code> can see <a href=https://pytorch.org/blog/a-better-transformer-for-fast-transformer-encoder-inference/ >a speedup of more than 2x on many common workloads</a>.</p> <p>Finally, since the ViT architecture uses several Transformer Layers stacked on top of each for the full architecture (Table 1 shows 12 Layers in the case of ViT-Base), you can do this with <a href=https://pytorch.org/docs/stable/generated/torch.nn.TransformerEncoder.html#torch.nn.TransformerEncoder><code>torch.nn.TransformerEncoder(encoder_layer, num_layers)</code></a> where: * <code>encoder_layer</code> - The target Transformer Encoder layer created with <code>torch.nn.TransformerEncoderLayer()</code>. * <code>num_layers</code> - The number of Transformer Encoder layers to stack together.</p> <h2 id=8-putting-it-all-together-to-create-vit>8. Putting it all together to create ViT</h2> <p>Alright, alright, alright, we've come a long way!</p> <p>But now it's time to do the exciting thing of putting together all of the pieces of the puzzle.</p> <p>We're going to combine all of the blocks we've created to replicate the full ViT architecture.</p> <p>From the patch and positional embedding to the Transformer Encoder(s) to the MLP Head.</p> <p>But wait, we haven't created equation 4 yet...</p> <div class=arithmatex>\[ \begin{aligned} \mathbf{y} &amp;=\operatorname{LN}\left(\mathbf{z}_{L}^{0}\right) &amp; &amp; \end{aligned} \]</div> <p>Don't worry, we can put equation 4 into our overall ViT architecture class.</p> <p>All we need is a <code>torch.nn.LayerNorm()</code> layer and a <code>torch.nn.Linear()</code> layer to convert the 0th index (<span class=arithmatex>\(\mathbf{z}_{L}^{0}\)</span>) of the Transformer Encoder logit outputs to the target number of classes we have.</p> <p>To create the full architecture, we'll also need to stack a number of our <code>TransformerEncoderBlock</code>s on top of each other, we can do this by passing a list of them to <code>torch.nn.Sequential()</code> (this will make a sequential range of <code>TransformerEncoderBlock</code>s).</p> <p>We'll focus on the ViT-Base hyperparameters from Table 1 but our code should be adaptable to other ViT variants.</p> <p>Creating ViT will be our biggest code block yet but we can do it!</p> <p>Finally, to bring our own implementation of ViT to life, let's:</p> <ol> <li>Create a class called <code>ViT</code> that inherits from <code>torch.nn.Module</code>.</li> <li>Initialize the class with hyperparameters from Table 1 and Table 3 of the ViT paper for the ViT-Base model.</li> <li>Make sure the image size is divisible by the patch size (the image should be split into even patches).</li> <li>Calculate the number of patches using the formula <span class=arithmatex>\(N=H W / P^{2}\)</span>, where <span class=arithmatex>\(H\)</span> is the image height, <span class=arithmatex>\(W\)</span> is the image width and <span class=arithmatex>\(P\)</span> is the patch size.</li> <li>Create a learnable class embedding token (equation 1) as done above in section 4.6.</li> <li>Create a learnable position embedding vector (equation 1) as done above in section 4.7.</li> <li>Setup the embedding dropout layer as discussed in Appendix B.1 of the ViT paper.</li> <li>Create the patch embedding layer using the <code>PatchEmbedding</code> class as above in section 4.5.</li> <li>Create a series of Transformer Encoder blocks by passing a list of <code>TransformerEncoderBlock</code>s created in section 7.1 to <code>torch.nn.Sequential()</code> (equations 2 &amp; 3).</li> <li>Create the MLP head (also called classifier head or equation 4) by passing a <code>torch.nn.LayerNorm()</code> (LN) layer and a <code>torch.nn.Linear(out_features=num_classes)</code> layer (where <code>num_classes</code> is the target number of classes) linear layer to <code>torch.nn.Sequential()</code>.</li> <li>Create a <code>forward()</code> method that accepts an input.</li> <li>Get the batch size of the input (the first dimension of the shape).</li> <li>Create the patching embedding using the layer created in step 8 (equation 1).</li> <li>Create the class token embedding using the layer created in step 5 and expand it across the number of batches found in step 11 using <a href=https://pytorch.org/docs/stable/generated/torch.Tensor.expand.html><code>torch.Tensor.expand()</code></a> (equation 1).</li> <li>Concatenate the class token embedding created in step 13 to the first dimension of the patch embedding created in step 12 using <a href=https://pytorch.org/docs/stable/generated/torch.cat.html><code>torch.cat()</code></a> (equation 1).</li> <li>Add the position embedding created in step 6 to the patch and class token embedding created in step 14 (equation 1).</li> <li>Pass the patch and position embedding through the dropout layer created in step 7.</li> <li>Pass the patch and position embedding from step 16 through the stack of Transformer Encoder layers created in step 9 (equations 2 &amp; 3).</li> <li>Pass index 0 of the output of the stack of Transformer Encoder layers from step 17 through the classifier head created in step 10 (equation 4).</li> <li>Dance and shout woohoo!!! We just built a Vision Transformer!</li> </ol> <p>You ready?</p> <p>Let's go.</p> <div class=highlight><pre><span></span><code><span class=c1># 1. Create a ViT class that inherits from nn.Module</span>
<span class=k>class</span><span class=w> </span><span class=nc>ViT</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Creates a Vision Transformer architecture with ViT-Base hyperparameters by default.&quot;&quot;&quot;</span>
    <span class=c1># 2. Initialize the class with hyperparameters from Table 1 and Table 3</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span>
                 <span class=n>img_size</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>224</span><span class=p>,</span> <span class=c1># Training resolution from Table 3 in ViT paper</span>
                 <span class=n>in_channels</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=c1># Number of channels in input image</span>
                 <span class=n>patch_size</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>16</span><span class=p>,</span> <span class=c1># Patch size</span>
                 <span class=n>num_transformer_layers</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>12</span><span class=p>,</span> <span class=c1># Layers from Table 1 for ViT-Base</span>
                 <span class=n>embedding_dim</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=c1># Hidden size D from Table 1 for ViT-Base</span>
                 <span class=n>mlp_size</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>3072</span><span class=p>,</span> <span class=c1># MLP size from Table 1 for ViT-Base</span>
                 <span class=n>num_heads</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>12</span><span class=p>,</span> <span class=c1># Heads from Table 1 for ViT-Base</span>
                 <span class=n>attn_dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=c1># Dropout for attention projection</span>
                 <span class=n>mlp_dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=c1># Dropout for dense/MLP layers</span>
                 <span class=n>embedding_dropout</span><span class=p>:</span><span class=nb>float</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=c1># Dropout for patch and position embeddings</span>
                 <span class=n>num_classes</span><span class=p>:</span><span class=nb>int</span><span class=o>=</span><span class=mi>1000</span><span class=p>):</span> <span class=c1># Default for ImageNet but can customize this</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span> <span class=c1># don&#39;t forget the super().__init__()!</span>

        <span class=c1># 3. Make the image size is divisble by the patch size</span>
        <span class=k>assert</span> <span class=n>img_size</span> <span class=o>%</span> <span class=n>patch_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&quot;Image size must be divisible by patch size, image size: </span><span class=si>{</span><span class=n>img_size</span><span class=si>}</span><span class=s2>, patch size: </span><span class=si>{</span><span class=n>patch_size</span><span class=si>}</span><span class=s2>.&quot;</span>

        <span class=c1># 4. Calculate number of patches (height * width/patch^2)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>num_patches</span> <span class=o>=</span> <span class=p>(</span><span class=n>img_size</span> <span class=o>*</span> <span class=n>img_size</span><span class=p>)</span> <span class=o>//</span> <span class=n>patch_size</span><span class=o>**</span><span class=mi>2</span>

        <span class=c1># 5. Create learnable class embedding (needs to go at front of sequence of patch embeddings)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>class_embedding</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=n>torch</span><span class=o>.</span><span class=n>randn</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>embedding_dim</span><span class=p>),</span>
                                            <span class=n>requires_grad</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

        <span class=c1># 6. Create learnable position embedding</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>position_embedding</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=n>torch</span><span class=o>.</span><span class=n>randn</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>num_patches</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>embedding_dim</span><span class=p>),</span>
                                               <span class=n>requires_grad</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

        <span class=c1># 7. Create embedding dropout value</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>embedding_dropout</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Dropout</span><span class=p>(</span><span class=n>p</span><span class=o>=</span><span class=n>embedding_dropout</span><span class=p>)</span>

        <span class=c1># 8. Create patch embedding layer</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>patch_embedding</span> <span class=o>=</span> <span class=n>PatchEmbedding</span><span class=p>(</span><span class=n>in_channels</span><span class=o>=</span><span class=n>in_channels</span><span class=p>,</span>
                                              <span class=n>patch_size</span><span class=o>=</span><span class=n>patch_size</span><span class=p>,</span>
                                              <span class=n>embedding_dim</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>)</span>

        <span class=c1># 9. Create Transformer Encoder blocks (we can stack Transformer Encoder blocks using nn.Sequential())</span>
        <span class=c1># Note: The &quot;*&quot; means &quot;all&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>transformer_encoder</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span><span class=o>*</span><span class=p>[</span><span class=n>TransformerEncoderBlock</span><span class=p>(</span><span class=n>embedding_dim</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                                                                            <span class=n>num_heads</span><span class=o>=</span><span class=n>num_heads</span><span class=p>,</span>
                                                                            <span class=n>mlp_size</span><span class=o>=</span><span class=n>mlp_size</span><span class=p>,</span>
                                                                            <span class=n>mlp_dropout</span><span class=o>=</span><span class=n>mlp_dropout</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_transformer_layers</span><span class=p>)])</span>

        <span class=c1># 10. Create classifier head</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>classifier</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>LayerNorm</span><span class=p>(</span><span class=n>normalized_shape</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>),</span>
            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>in_features</span><span class=o>=</span><span class=n>embedding_dim</span><span class=p>,</span>
                      <span class=n>out_features</span><span class=o>=</span><span class=n>num_classes</span><span class=p>)</span>
        <span class=p>)</span>

    <span class=c1># 11. Create a forward() method</span>
    <span class=k>def</span><span class=w> </span><span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>

        <span class=c1># 12. Get batch size</span>
        <span class=n>batch_size</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>

        <span class=c1># 13. Create class token embedding and expand it to match the batch size (equation 1)</span>
        <span class=n>class_token</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>class_embedding</span><span class=o>.</span><span class=n>expand</span><span class=p>(</span><span class=n>batch_size</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># &quot;-1&quot; means to infer the dimension (try this line on its own)</span>

        <span class=c1># 14. Create patch embedding (equation 1)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patch_embedding</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>

        <span class=c1># 15. Concat class embedding and patch embedding (equation 1)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>cat</span><span class=p>((</span><span class=n>class_token</span><span class=p>,</span> <span class=n>x</span><span class=p>),</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>

        <span class=c1># 16. Add position embedding to patch embedding (equation 1)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>position_embedding</span> <span class=o>+</span> <span class=n>x</span>

        <span class=c1># 17. Run embedding dropout (Appendix B.1)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>embedding_dropout</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>

        <span class=c1># 18. Pass patch, position and class embedding through transformer encoder layers (equations 2 &amp; 3)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>transformer_encoder</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>

        <span class=c1># 19. Put 0 index logit through classifier (equation 4)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>classifier</span><span class=p>(</span><span class=n>x</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>])</span> <span class=c1># run on each sample in a batch at 0 index</span>

        <span class=k>return</span> <span class=n>x</span>
</code></pre></div> <ol> <li>🕺💃🥳 Woohoo!!! We just built a vision transformer!</li> </ol> <p>What an effort!</p> <p>Slowly but surely we created layers and blocks, inputs and outputs and put them all together to build our own ViT!</p> <p>Let's create a quick demo to showcase what's happening with the class token embedding being expanded over the batch dimensions.</p> <div class=highlight><pre><span></span><code><span class=c1># Example of creating the class embedding and expanding over a batch dimension</span>
<span class=n>batch_size</span> <span class=o>=</span> <span class=mi>32</span>
<span class=n>class_token_embedding_single</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Parameter</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=n>torch</span><span class=o>.</span><span class=n>randn</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>768</span><span class=p>))</span> <span class=c1># create a single learnable class token</span>
<span class=n>class_token_embedding_expanded</span> <span class=o>=</span> <span class=n>class_token_embedding_single</span><span class=o>.</span><span class=n>expand</span><span class=p>(</span><span class=n>batch_size</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># expand the single learnable class token across the batch dimension, &quot;-1&quot; means to &quot;infer the dimension&quot;</span>

<span class=c1># Print out the change in shapes</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Shape of class token embedding single: </span><span class=si>{</span><span class=n>class_token_embedding_single</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Shape of class token embedding expanded: </span><span class=si>{</span><span class=n>class_token_embedding_expanded</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Shape of class token embedding single: torch.Size([1, 1, 768])
Shape of class token embedding expanded: torch.Size([32, 1, 768])
</code></pre></div> <p>Notice how the first dimension gets expanded to the batch size and the other dimensions stay the same (because they're inferred by the "<code>-1</code>" dimensions in <code>.expand(batch_size, -1, -1)</code>).</p> <p>Alright time to test out <code>ViT()</code> class.</p> <p>Let's create a random tensor in the same shape as a single image, pass to an instance of <code>ViT</code> and see what happens.</p> <div class=highlight><pre><span></span><code><span class=n>set_seeds</span><span class=p>()</span>

<span class=c1># Create a random tensor with same shape as a single image</span>
<span class=n>random_image_tensor</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>randn</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>224</span><span class=p>,</span> <span class=mi>224</span><span class=p>)</span> <span class=c1># (batch_size, color_channels, height, width)</span>

<span class=c1># Create an instance of ViT with the number of classes we&#39;re working with (pizza, steak, sushi)</span>
<span class=n>vit</span> <span class=o>=</span> <span class=n>ViT</span><span class=p>(</span><span class=n>num_classes</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>class_names</span><span class=p>))</span>

<span class=c1># Pass the random image tensor to our ViT instance</span>
<span class=n>vit</span><span class=p>(</span><span class=n>random_image_tensor</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>tensor([[-0.2377,  0.7360,  1.2137]], grad_fn=&lt;AddmmBackward0&gt;)
</code></pre></div> <p>Outstanding!</p> <p>It looks like our random image tensor made it all the way through our ViT architecture and it's outputting three logit values (one for each class).</p> <p>And because our <code>ViT</code> class has plenty of parameters we could customize the <code>img_size</code>, <code>patch_size</code> or <code>num_classes</code> if we wanted to.</p> <h3 id=81-getting-a-visual-summary-of-our-vit-model>8.1 Getting a visual summary of our ViT model</h3> <p>We handcrafted our own version of the ViT architecture and seen that a random image tensor can flow all the way through it.</p> <p>How about we use <code>torchinfo.summary()</code> to get a visual overview of the input and output shapes of all the layers in our model?</p> <blockquote> <p><strong>Note:</strong> The ViT paper states the use of a batch size of 4096 for training, however, this requires a far bit of CPU/GPU compute memory to handle (the larger the batch size the more memory required). So to make sure we don't get memory errors, we'll stick with a batch size of 32. You could always increase this later if you have access to hardware with more memory.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>torchinfo</span><span class=w> </span><span class=kn>import</span> <span class=n>summary</span>

<span class=c1># # Print a summary of our custom ViT model using torchinfo (uncomment for actual output)</span>
<span class=c1># summary(model=vit,</span>
<span class=c1>#         input_size=(32, 3, 224, 224), # (batch_size, color_channels, height, width)</span>
<span class=c1>#         # col_names=[&quot;input_size&quot;], # uncomment for smaller output</span>
<span class=c1>#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class=c1>#         col_width=20,</span>
<span class=c1>#         row_settings=[&quot;var_names&quot;]</span>
<span class=c1># )</span>
</code></pre></div> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-summary-output-custom-vit-model.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-summary-output-custom-vit-model.png width=900/ alt="input and output summary of our custom made ViT model"></a></p> <p>Now those are some nice looking layers!</p> <p>Checkout the total number of parameters too, 85,800,963, our biggest model yet!</p> <p>The number is very close to PyTorch's pretrained ViT-Base with patch size 16 at <a href=https://pytorch.org/vision/main/models/generated/torchvision.models.vit_b_16.html#torchvision.models.vit_b_16><code>torch.vision.models.vit_b_16()</code></a> with 86,567,656 total parameters (though this number of parameters is for the 1000 classes in ImageNet).</p> <blockquote> <p><strong>Exercise:</strong> Try changing the <code>num_classes</code> parameter of our <code>ViT()</code> model to 1000 and then creating another summary with <code>torchinfo.summary()</code> and see if the number of parameters lines up between our code and <code>torchvision.models.vit_b_16()</code>.</p> </blockquote> <h2 id=9-setting-up-training-code-for-our-vit-model>9. Setting up training code for our ViT model</h2> <p>Ok time for the easy part.</p> <p>Training!</p> <p>Why easy?</p> <p>Because we've got most of what we need ready to go, from our model (<code>vit</code>) to our DataLoaders (<code>train_dataloader</code>, <code>test_dataloader</code>) to the training functions we created in <a href=https://www.learnpytorch.io/05_pytorch_going_modular/#4-creating-train_step-and-test_step-functions-and-train-to-combine-them>05. PyTorch Going Modular section 4</a>.</p> <p>To train our model we can import the <code>train()</code> function from <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/going_modular/going_modular/train.py><code>going_modular.going_modular.engine</code></a>.</p> <p>All we need is a loss function and an optimizer.</p> <h3 id=91-creating-an-optimizer>9.1 Creating an optimizer</h3> <p>Searching the ViT paper for "optimizer", section 4.1 on Training &amp; Fine-tuning states:</p> <blockquote> <p><strong>Training &amp; Fine-tuning.</strong> We train all models, including ResNets, using Adam (Kingma &amp; Ba, 2015 ) with <span class=arithmatex>\(\beta_{1}=0.9, \beta_{2}=0.999\)</span>, a batch size of 4096 and apply a high weight decay of <span class=arithmatex>\(0.1\)</span>, which we found to be useful for transfer of all models (Appendix D.1 shows that, in contrast to common practices, Adam works slightly better than SGD for ResNets in our setting).</p> </blockquote> <p>So we can see they chose to use the "Adam" optimizer (<a href=https://pytorch.org/docs/stable/generated/torch.optim.Adam.html#torch.optim.Adam><code>torch.optim.Adam()</code></a>) rather than SGD (stochastic gradient descent, <a href=https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD><code>torch.optim.SGD()</code></a>).</p> <p>The authors set Adam's <span class=arithmatex>\(\beta\)</span> (beta) values to <span class=arithmatex>\(\beta_{1}=0.9, \beta_{2}=0.999\)</span>, these are the default values for the <code>betas</code> parameter in <code>torch.optim.Adam(betas=(0.9, 0.999))</code>.</p> <p>They also state the use of <a href=https://paperswithcode.com/method/weight-decay>weight decay</a> (slowly reducing the values of the weights during optimization to prevent overfitting), we can set this with the <code>weight_decay</code> parameter in <code>torch.optim.Adam(weight_decay=0.3)</code> (according to the setting of ViT-* trained on ImageNet-1k).</p> <p>We'll set the learning rate of the optimizer to 0.003 as per Table 3 (according to the setting of ViT-* trained on ImageNet-1k).</p> <p>And as discussed previously, we're going to use a lower batch size than 4096 due to hardware limitations (if you have a large GPU, feel free to increase this).</p> <h3 id=92-creating-a-loss-function>9.2 Creating a loss function</h3> <p>Strangely, searching the ViT paper for "loss" or "loss function" or "criterion" returns no results.</p> <p>However, since the target problem we're working with is multi-class classification (the same for the ViT paper), we'll use <a href=https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html><code>torch.nn.CrossEntropyLoss()</code></a>.</p> <h3 id=93-training-our-vit-model>9.3 Training our ViT model</h3> <p>Okay, now we know what optimizer and loss function we're going to use, let's setup the training code for training our ViT.</p> <p>We'll start by importing the <code>engine.py</code> script from <code>going_modular.going_modular</code> then we'll setup the optimizer and loss function and finally we'll use the <code>train()</code> function from <code>engine.py</code> to train our ViT model for 10 epochs (we're using a smaller number of epochs than the ViT paper to make sure everything works).</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>going_modular.going_modular</span><span class=w> </span><span class=kn>import</span> <span class=n>engine</span>

<span class=c1># Setup the optimizer to optimize our ViT model parameters using hyperparameters from the ViT paper</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>optim</span><span class=o>.</span><span class=n>Adam</span><span class=p>(</span><span class=n>params</span><span class=o>=</span><span class=n>vit</span><span class=o>.</span><span class=n>parameters</span><span class=p>(),</span>
                             <span class=n>lr</span><span class=o>=</span><span class=mf>3e-3</span><span class=p>,</span> <span class=c1># Base LR from Table 3 for ViT-* ImageNet-1k</span>
                             <span class=n>betas</span><span class=o>=</span><span class=p>(</span><span class=mf>0.9</span><span class=p>,</span> <span class=mf>0.999</span><span class=p>),</span> <span class=c1># default values but also mentioned in ViT paper section 4.1 (Training &amp; Fine-tuning)</span>
                             <span class=n>weight_decay</span><span class=o>=</span><span class=mf>0.3</span><span class=p>)</span> <span class=c1># from the ViT paper section 4.1 (Training &amp; Fine-tuning) and Table 3 for ViT-* ImageNet-1k</span>

<span class=c1># Setup the loss function for multi-class classification</span>
<span class=n>loss_fn</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>CrossEntropyLoss</span><span class=p>()</span>

<span class=c1># Set the seeds</span>
<span class=n>set_seeds</span><span class=p>()</span>

<span class=c1># Train the model and save the training results to a dictionary</span>
<span class=n>results</span> <span class=o>=</span> <span class=n>engine</span><span class=o>.</span><span class=n>train</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>vit</span><span class=p>,</span>
                       <span class=n>train_dataloader</span><span class=o>=</span><span class=n>train_dataloader</span><span class=p>,</span>
                       <span class=n>test_dataloader</span><span class=o>=</span><span class=n>test_dataloader</span><span class=p>,</span>
                       <span class=n>optimizer</span><span class=o>=</span><span class=n>optimizer</span><span class=p>,</span>
                       <span class=n>loss_fn</span><span class=o>=</span><span class=n>loss_fn</span><span class=p>,</span>
                       <span class=n>epochs</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span>
                       <span class=n>device</span><span class=o>=</span><span class=n>device</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code> 10%|█         | 1/10 [00:03&lt;00:32,  3.56s/it]

Epoch: 1 | train_loss: 5.1782 | train_acc: 0.3633 | test_loss: 4.9653 | test_acc: 0.2604


 20%|██        | 2/10 [00:06&lt;00:26,  3.31s/it]

Epoch: 2 | train_loss: 2.1727 | train_acc: 0.3008 | test_loss: 1.4031 | test_acc: 0.2604


 30%|███       | 3/10 [00:09&lt;00:22,  3.24s/it]

Epoch: 3 | train_loss: 1.1747 | train_acc: 0.4414 | test_loss: 1.8320 | test_acc: 0.2604


 40%|████      | 4/10 [00:13&lt;00:19,  3.21s/it]

Epoch: 4 | train_loss: 1.2742 | train_acc: 0.2773 | test_loss: 1.3042 | test_acc: 0.1979


 50%|█████     | 5/10 [00:16&lt;00:15,  3.20s/it]

Epoch: 5 | train_loss: 1.1426 | train_acc: 0.3047 | test_loss: 1.1761 | test_acc: 0.2604


 60%|██████    | 6/10 [00:19&lt;00:12,  3.18s/it]

Epoch: 6 | train_loss: 1.1823 | train_acc: 0.3086 | test_loss: 1.2052 | test_acc: 0.1979


 70%|███████   | 7/10 [00:22&lt;00:09,  3.09s/it]

Epoch: 7 | train_loss: 1.2615 | train_acc: 0.2852 | test_loss: 1.1434 | test_acc: 0.1979


 80%|████████  | 8/10 [00:25&lt;00:05,  2.99s/it]

Epoch: 8 | train_loss: 1.1012 | train_acc: 0.4062 | test_loss: 1.1849 | test_acc: 0.2604


 90%|█████████ | 9/10 [00:27&lt;00:02,  2.94s/it]

Epoch: 9 | train_loss: 1.1487 | train_acc: 0.3047 | test_loss: 1.0172 | test_acc: 0.5417


100%|██████████| 10/10 [00:31&lt;00:00,  3.11s/it]

Epoch: 10 | train_loss: 1.2539 | train_acc: 0.2617 | test_loss: 1.3794 | test_acc: 0.2604
</code></pre></div> <p>Wonderful!</p> <p>Our ViT model has come to life!</p> <p>Though the results on our pizza, steak and sushi dataset don't look too good.</p> <p>Perhaps it's because we're missing a few things?</p> <h3 id=94-what-our-training-setup-is-missing>9.4 What our training setup is missing</h3> <p>The original ViT architecture achieves good results on several image classification benchmarks (on par or better than many state-of-the-art results when it was released).</p> <p>However, our results (so far) aren't as good.</p> <p>There's a few reasons this could be but the main one is scale.</p> <p>The original ViT paper uses a far larger amount of data than ours (in deep learning, more data is generally always a good thing) and a longer training schedule (see Table 3).</p> <table> <thead> <tr> <th><strong>Hyperparameter value</strong></th> <th><strong>ViT Paper</strong></th> <th><strong>Our implementation</strong></th> </tr> </thead> <tbody> <tr> <td>Number of training images</td> <td>1.3M (ImageNet-1k), 14M (ImageNet-21k), 303M (JFT)</td> <td>225</td> </tr> <tr> <td>Epochs</td> <td>7 (for largest dataset), 90, 300 (for ImageNet)</td> <td>10</td> </tr> <tr> <td>Batch size</td> <td>4096</td> <td>32</td> </tr> <tr> <td><a href=https://paperswithcode.com/method/linear-warmup>Learning rate warmup</a></td> <td>10k steps (Table 3)</td> <td>None</td> </tr> <tr> <td><a href="https://medium.com/analytics-vidhya/learning-rate-decay-and-methods-in-deep-learning-2cee564f910b#:~:text=Learning%20rate%20decay%20is%20a,help%20both%20optimization%20and%20generalization.">Learning rate decay</a></td> <td>Linear/Cosine (Table 3)</td> <td>None</td> </tr> <tr> <td><a href=https://paperswithcode.com/method/gradient-clipping>Gradient clipping</a></td> <td>Global norm 1 (Table 3)</td> <td>None</td> </tr> </tbody> </table> <p>Even though our ViT architecture is the same as the paper, the results from the ViT paper were achieved using far more data and a more elaborate training scheme than ours.</p> <p>Because of the size of the ViT architecture and its high number of parameters (increased learning capabilities), and amount of data it uses (increased learning opportunities), many of the techniques used in the ViT paper training scheme such as learning rate warmup, learning rate decay and gradient clipping are specifically designed to <a href=https://www.learnpytorch.io/04_pytorch_custom_datasets/#81-how-to-deal-with-overfitting>prevent overfitting</a> (regularization).</p> <blockquote> <p><strong>Note:</strong> For any technique you're unsure of, you can often quickly find an example by searching "pytorch TECHNIQUE NAME", for exmaple, say you wanted to learn about learning rate warmup and what it does, you could search "pytorch learning rate warmup".</p> </blockquote> <p>Good news is, there are many pretrained ViT models (using vast amounts of data) available online, we'll see one in action in section 10.</p> <h3 id=95-plot-the-loss-curves-of-our-vit-model>9.5 Plot the loss curves of our ViT model</h3> <p>We've trained our ViT model and seen the results as numbers on a page.</p> <p>But let's now follow the data explorer's motto of <em>visualize, visualize, visualize!</em></p> <p>And one of the best things to visualize for a model is its loss curves.</p> <p>To check out our ViT model's loss curves, we can use the <code>plot_loss_curves</code> function from <code>helper_functions.py</code> we created in <a href=https://www.learnpytorch.io/04_pytorch_custom_datasets/#78-plot-the-loss-curves-of-model-0>04. PyTorch Custom Datasets section 7.8</a>.</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>helper_functions</span><span class=w> </span><span class=kn>import</span> <span class=n>plot_loss_curves</span>

<span class=c1># Plot our ViT model&#39;s loss curves</span>
<span class=n>plot_loss_curves</span><span class=p>(</span><span class=n>results</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_145_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_145_0.png></a></p> <p>Hmm, it looks like our model's loss curves are all over the place.</p> <p>At least the loss looks like it's heading the right direction but the accuracy curves don't really show much promise.</p> <p>These results are likely because of the difference in data resources and training regime of our ViT model versus the ViT paper.</p> <p>It seems our model is <a href=learnpytorch.io/04_pytorch_custom_datasets/#82-how-to-deal-with-underfitting>severly underfitting</a> (not achieving the results we'd like it to).</p> <p>How about we see if we can fix that by bringing in a pretrained ViT model?</p> <h2 id=10-using-a-pretrained-vit-from-torchvisionmodels-on-the-same-dataset>10. Using a pretrained ViT from <code>torchvision.models</code> on the same dataset</h2> <p>We've discussed the benefits of using pretrained models in <a href=https://www.learnpytorch.io/06_pytorch_transfer_learning/ >06. PyTorch Transfer Learning</a>.</p> <p>But since we've now trained our own ViT from scratch and achieved less than optimal results, the benefits of transfer learning (using a pretrained model) really shine.</p> <h3 id=101-why-use-a-pretrained-model>10.1 Why use a pretrained model?</h3> <p>An important note on many modern machine learning research papers is that much of the results are obtained with large datasets and vast compute resources.</p> <p>And in modern day machine learning, the original fully trained ViT would likely not be considered a "super large" training setup (models are continually getting bigger and bigger).</p> <p>Reading the ViT paper section 4.2:</p> <blockquote> <p>Finally, the ViT-L/16 model pre-trained on the public ImageNet-21k dataset performs well on most datasets too, while taking fewer resources to pre-train: it could be trained using a standard cloud TPUv3 with 8 cores in approximately <strong>30 days</strong>.</p> </blockquote> <p>As of July 2022, the <a href=https://cloud.google.com/tpu/pricing>price for renting a TPUv3</a> (Tensor Processing Unit version 3) with 8 cores on Google Cloud is $8 USD per hour.</p> <p>To rent one for 30 straight days would cost <strong>$5,760 USD</strong>.</p> <p>This cost (monetary and time) may be viable for some larger research teams or enterprises but for many people it's not.</p> <p>So having a pretrained model available through resources like <a href=https://pytorch.org/vision/stable/models.html><code>torchvision.models</code></a>, the <a href=https://github.com/rwightman/pytorch-image-models><code>timm</code> (Torch Image Models) library</a>, the <a href=https://huggingface.co/models>HuggingFace Hub</a> or even from the authors of the papers themselves (there's a growing trend for machine learning researchers to release the code and pretrained models from their research papers, I'm a big fan of this trend, many of these resources can be found on <a href=https://paperswithcode.com/ >Paperswithcode.com</a>).</p> <p>If you're focused on leveraging the benefits of a specific model architecture rather than creating your custom architecture, I'd highly recommend using a pretrained model.</p> <h3 id=102-getting-a-pretrained-vit-model-and-creating-a-feature-extractor>10.2 Getting a pretrained ViT model and creating a feature extractor</h3> <p>We can get a pretrained ViT model from <code>torchvision.models</code>.</p> <p>We'll go from the top by first making sure we've got the right versions of <code>torch</code> and <code>torchvision</code>.</p> <blockquote> <p><strong>Note:</strong> The following code requires <code>torch</code> v0.12+ and <code>torchvision</code> v0.13+ to use the latest <code>torchvision</code> model weights API.</p> </blockquote> <div class=highlight><pre><span></span><code><span class=c1># The following requires torch v0.12+ and torchvision v0.13+</span>
<span class=kn>import</span><span class=w> </span><span class=nn>torch</span>
<span class=kn>import</span><span class=w> </span><span class=nn>torchvision</span>
<span class=nb>print</span><span class=p>(</span><span class=n>torch</span><span class=o>.</span><span class=n>__version__</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>torchvision</span><span class=o>.</span><span class=n>__version__</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>2.2.2
0.17.2
</code></pre></div> <p>Then we'll setup device-agonistc code.</p> <div class=highlight><pre><span></span><code><span class=n>device</span> <span class=o>=</span> <span class=s2>&quot;cuda&quot;</span> <span class=k>if</span> <span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>is_available</span><span class=p>()</span> <span class=k>else</span> <span class=s2>&quot;cpu&quot;</span>
<span class=n>device</span>
</code></pre></div> <div class=highlight><pre><span></span><code>&#39;cuda&#39;
</code></pre></div> <p>Finally, we'll get the pretrained ViT-Base with patch size 16 from <code>torchvision.models</code> and prepare it for our FoodVision Mini use case by turning it into a feature extractor transfer learning model.</p> <p>Specifically, we'll: 1. Get the pretrained weights for ViT-Base trained on ImageNet-1k from <a href=https://pytorch.org/vision/stable/models/generated/torchvision.models.vit_b_16.html#torchvision.models.ViT_B_16_Weights><code>torchvision.models.ViT_B_16_Weights.DEFAULT</code></a> (<code>DEFAULT</code> stands for best available). 2. Setup a ViT model instance via <code>torchvision.models.vit_b_16</code>, pass it the pretrained weights step 1 and send it to the target device. 3. Freeze all of the parameters in the base ViT model created in step 2 by setting their <code>requires_grad</code> attribute to <code>False</code>. 4. Update the classifier head of the ViT model created in step 2 to suit our own problem by changing the number of <code>out_features</code> to our number of classes (pizza, steak, sushi).</p> <p>We covered steps like this in 06. PyTorch Transfer Learning <a href=https://www.learnpytorch.io/06_pytorch_transfer_learning/#32-setting-up-a-pretrained-model>section 3.2: Setting up a pretrained model</a> and <a href=https://www.learnpytorch.io/06_pytorch_transfer_learning/#34-freezing-the-base-model-and-changing-the-output-layer-to-suit-our-needs>section 3.4: Freezing the base model and changing the output layer to suit our needs</a>.</p> <div class=highlight><pre><span></span><code><span class=c1># 1. Get pretrained weights for ViT-Base</span>
<span class=n>pretrained_vit_weights</span> <span class=o>=</span> <span class=n>torchvision</span><span class=o>.</span><span class=n>models</span><span class=o>.</span><span class=n>ViT_B_16_Weights</span><span class=o>.</span><span class=n>DEFAULT</span> <span class=c1># requires torchvision &gt;= 0.13, &quot;DEFAULT&quot; means best available</span>

<span class=c1># 2. Setup a ViT model instance with pretrained weights</span>
<span class=n>pretrained_vit</span> <span class=o>=</span> <span class=n>torchvision</span><span class=o>.</span><span class=n>models</span><span class=o>.</span><span class=n>vit_b_16</span><span class=p>(</span><span class=n>weights</span><span class=o>=</span><span class=n>pretrained_vit_weights</span><span class=p>)</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>

<span class=c1># 3. Freeze the base parameters</span>
<span class=k>for</span> <span class=n>parameter</span> <span class=ow>in</span> <span class=n>pretrained_vit</span><span class=o>.</span><span class=n>parameters</span><span class=p>():</span>
    <span class=n>parameter</span><span class=o>.</span><span class=n>requires_grad</span> <span class=o>=</span> <span class=kc>False</span>

<span class=c1># 4. Change the classifier head (set the seeds to ensure same initialization with linear head)</span>
<span class=n>set_seeds</span><span class=p>()</span>
<span class=n>pretrained_vit</span><span class=o>.</span><span class=n>heads</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>in_features</span><span class=o>=</span><span class=mi>768</span><span class=p>,</span> <span class=n>out_features</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>class_names</span><span class=p>))</span><span class=o>.</span><span class=n>to</span><span class=p>(</span><span class=n>device</span><span class=p>)</span>
<span class=c1># pretrained_vit # uncomment for model output</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Downloading: &quot;https://download.pytorch.org/models/vit_b_16-c867db91.pth&quot; to /home/jupyter-trunglph/.cache/torch/hub/checkpoints/vit_b_16-c867db91.pth
100%|██████████| 330M/330M [00:30&lt;00:00, 11.4MB/s]
</code></pre></div> <p>Pretrained ViT feature extractor model created!</p> <p>Let's now check it out by printing a <code>torchinfo.summary()</code>.</p> <div class=highlight><pre><span></span><code><span class=c1># # Print a summary using torchinfo (uncomment for actual output)</span>
<span class=c1># summary(model=pretrained_vit,</span>
<span class=c1>#         input_size=(32, 3, 224, 224), # (batch_size, color_channels, height, width)</span>
<span class=c1>#         # col_names=[&quot;input_size&quot;], # uncomment for smaller output</span>
<span class=c1>#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class=c1>#         col_width=20,</span>
<span class=c1>#         row_settings=[&quot;var_names&quot;]</span>
<span class=c1># )</span>
</code></pre></div> <p><a class=glightbox href=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-summary-output-pytorch-vit.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img src=https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/08-vit-paper-summary-output-pytorch-vit.png alt="output of pytorch pretrained ViT model summary" width=900></a></p> <p>Woohoo!</p> <p>Notice how only the output layer is trainable, where as, all of the rest of the layers are untrainable (frozen).</p> <p>And the total number of parameters, 85,800,963, is the same as our custom made ViT model above.</p> <p>But the number of trainable parameters for <code>pretrained_vit</code> is much, much lower than our custom <code>vit</code> at only 2,307 compared to 85,800,963 (in our custom <code>vit</code>, since we're training from scratch, all parameters are trainable).</p> <p>This means the pretrained model should train a lot faster, we could potentially even use a larger batch size since less parameter updates are going to be taking up memory.</p> <h3 id=103-preparing-data-for-the-pretrained-vit-model>10.3 Preparing data for the pretrained ViT model</h3> <p>We downloaded and created DataLoaders for our own ViT model back in section 2.</p> <p>So we don't necessarily need to do it again.</p> <p>But in the name of practice, let's download some image data (pizza, steak and sushi images for Food Vision Mini), setup train and test directories and then transform the images into tensors and DataLoaders.</p> <p>We can download pizza, steak and sushi images from the course GitHub and the <code>download_data()</code> function we creating in <a href=https://www.learnpytorch.io/07_pytorch_experiment_tracking/#1-get-data>07. PyTorch Experiment Tracking section 1</a>.</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>helper_functions</span><span class=w> </span><span class=kn>import</span> <span class=n>download_data</span>

<span class=c1># Download pizza, steak, sushi images from GitHub</span>
<span class=n>image_path</span> <span class=o>=</span> <span class=n>download_data</span><span class=p>(</span><span class=n>source</span><span class=o>=</span><span class=s2>&quot;https://github.com/mrdbourke/pytorch-deep-learning/raw/main/data/pizza_steak_sushi.zip&quot;</span><span class=p>,</span>
                           <span class=n>destination</span><span class=o>=</span><span class=s2>&quot;pizza_steak_sushi&quot;</span><span class=p>)</span>
<span class=n>image_path</span>
</code></pre></div> <div class=highlight><pre><span></span><code>[INFO] data/pizza_steak_sushi directory exists, skipping download.





PosixPath(&#39;data/pizza_steak_sushi&#39;)
</code></pre></div> <p>And now we'll setup the training and test directory paths.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup train and test directory paths</span>
<span class=n>train_dir</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;train&quot;</span>
<span class=n>test_dir</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;test&quot;</span>
<span class=n>train_dir</span><span class=p>,</span> <span class=n>test_dir</span>
</code></pre></div> <div class=highlight><pre><span></span><code>(PosixPath(&#39;data/pizza_steak_sushi/train&#39;),
 PosixPath(&#39;data/pizza_steak_sushi/test&#39;))
</code></pre></div> <p>Finally, we'll transform our images into tensors and turn the tensors into DataLoaders.</p> <p>Since we're using a pretrained model form <code>torchvision.models</code> we can call the <code>transforms()</code> method on it to get its required transforms.</p> <p>Remember, if you're going to use a pretrained model, it's generally important to <strong>ensure your own custom data is transformed/formatted in the same way the data the original model was trained on</strong>.</p> <p>We covered this method of "automatic" transform creation in <a href=https://www.learnpytorch.io/06_pytorch_transfer_learning/#22-creating-a-transform-for-torchvisionmodels-auto-creation>06. PyTorch Transfer Learning section 2.2</a>.</p> <div class=highlight><pre><span></span><code><span class=c1># Get automatic transforms from pretrained ViT weights</span>
<span class=n>pretrained_vit_transforms</span> <span class=o>=</span> <span class=n>pretrained_vit_weights</span><span class=o>.</span><span class=n>transforms</span><span class=p>()</span>
<span class=nb>print</span><span class=p>(</span><span class=n>pretrained_vit_transforms</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>ImageClassification(
    crop_size=[224]
    resize_size=[256]
    mean=[0.485, 0.456, 0.406]
    std=[0.229, 0.224, 0.225]
    interpolation=InterpolationMode.BILINEAR
)
</code></pre></div> <p>And now we've got transforms ready, we can turn our images into DataLoaders using the <code>data_setup.create_dataloaders()</code> method we created in <a href=https://www.learnpytorch.io/05_pytorch_going_modular/#2-create-datasets-and-dataloaders-data_setuppy>05. PyTorch Going Modular section 2</a>.</p> <p>Since we're using a feature extractor model (less trainable parameters), we could increase the batch size to a higher value (if we set it to 1024, we'd be mimicing an improvement found in <a href=https://arxiv.org/abs/2205.01580><em>Better plain ViT baselines for ImageNet-1k</em></a>, a paper which improves upon the original ViT paper and suggested extra reading). But since we only have ~200 training samples total, we'll stick with 32.</p> <div class=highlight><pre><span></span><code><span class=c1># Setup dataloaders</span>
<span class=n>train_dataloader_pretrained</span><span class=p>,</span> <span class=n>test_dataloader_pretrained</span><span class=p>,</span> <span class=n>class_names</span> <span class=o>=</span> <span class=n>data_setup</span><span class=o>.</span><span class=n>create_dataloaders</span><span class=p>(</span><span class=n>train_dir</span><span class=o>=</span><span class=n>train_dir</span><span class=p>,</span>
                                                                                                     <span class=n>test_dir</span><span class=o>=</span><span class=n>test_dir</span><span class=p>,</span>
                                                                                                     <span class=n>transform</span><span class=o>=</span><span class=n>pretrained_vit_transforms</span><span class=p>,</span>
                                                                                                     <span class=n>batch_size</span><span class=o>=</span><span class=mi>32</span><span class=p>)</span> <span class=c1># Could increase if we had more samples, such as here: https://arxiv.org/abs/2205.01580 (there are other improvements there too...)</span>
</code></pre></div> <h3 id=104-train-feature-extractor-vit-model>10.4 Train feature extractor ViT model</h3> <p>Feature extractor model ready, DataLoaders ready, time to train!</p> <p>As before we'll use the Adam optimizer (<code>torch.optim.Adam()</code>) with a learning rate of <code>1e-3</code> and <code>torch.nn.CrossEntropyLoss()</code> as the loss function.</p> <p>Our <code>engine.train()</code> function we created in <a href=https://www.learnpytorch.io/05_pytorch_going_modular/#4-creating-train_step-and-test_step-functions-and-train-to-combine-them>05. PyTorch Going Modular section 4</a> will take care of the rest.</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>going_modular.going_modular</span><span class=w> </span><span class=kn>import</span> <span class=n>engine</span>

<span class=c1># Create optimizer and loss function</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>optim</span><span class=o>.</span><span class=n>Adam</span><span class=p>(</span><span class=n>params</span><span class=o>=</span><span class=n>pretrained_vit</span><span class=o>.</span><span class=n>parameters</span><span class=p>(),</span>
                             <span class=n>lr</span><span class=o>=</span><span class=mf>1e-3</span><span class=p>)</span>
<span class=n>loss_fn</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>nn</span><span class=o>.</span><span class=n>CrossEntropyLoss</span><span class=p>()</span>

<span class=c1># Train the classifier head of the pretrained ViT feature extractor model</span>
<span class=n>set_seeds</span><span class=p>()</span>
<span class=n>pretrained_vit_results</span> <span class=o>=</span> <span class=n>engine</span><span class=o>.</span><span class=n>train</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>pretrained_vit</span><span class=p>,</span>
                                      <span class=n>train_dataloader</span><span class=o>=</span><span class=n>train_dataloader_pretrained</span><span class=p>,</span>
                                      <span class=n>test_dataloader</span><span class=o>=</span><span class=n>test_dataloader_pretrained</span><span class=p>,</span>
                                      <span class=n>optimizer</span><span class=o>=</span><span class=n>optimizer</span><span class=p>,</span>
                                      <span class=n>loss_fn</span><span class=o>=</span><span class=n>loss_fn</span><span class=p>,</span>
                                      <span class=n>epochs</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span>
                                      <span class=n>device</span><span class=o>=</span><span class=n>device</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code> 10%|█         | 1/10 [00:02&lt;00:23,  2.56s/it]

Epoch: 1 | train_loss: 0.7663 | train_acc: 0.7188 | test_loss: 0.5435 | test_acc: 0.8769


 20%|██        | 2/10 [00:05&lt;00:20,  2.56s/it]

Epoch: 2 | train_loss: 0.3436 | train_acc: 0.9453 | test_loss: 0.3257 | test_acc: 0.8977


 30%|███       | 3/10 [00:07&lt;00:17,  2.56s/it]

Epoch: 3 | train_loss: 0.2068 | train_acc: 0.9492 | test_loss: 0.2698 | test_acc: 0.9186


 40%|████      | 4/10 [00:10&lt;00:15,  2.56s/it]

Epoch: 4 | train_loss: 0.1557 | train_acc: 0.9609 | test_loss: 0.2414 | test_acc: 0.9186


 50%|█████     | 5/10 [00:12&lt;00:12,  2.56s/it]

Epoch: 5 | train_loss: 0.1244 | train_acc: 0.9727 | test_loss: 0.2271 | test_acc: 0.8977


 60%|██████    | 6/10 [00:15&lt;00:10,  2.57s/it]

Epoch: 6 | train_loss: 0.1210 | train_acc: 0.9766 | test_loss: 0.2122 | test_acc: 0.9280


 70%|███████   | 7/10 [00:17&lt;00:07,  2.56s/it]

Epoch: 7 | train_loss: 0.0933 | train_acc: 0.9766 | test_loss: 0.2342 | test_acc: 0.8883


 80%|████████  | 8/10 [00:20&lt;00:05,  2.55s/it]

Epoch: 8 | train_loss: 0.0793 | train_acc: 0.9844 | test_loss: 0.2268 | test_acc: 0.9081


 90%|█████████ | 9/10 [00:23&lt;00:02,  2.57s/it]

Epoch: 9 | train_loss: 0.1084 | train_acc: 0.9883 | test_loss: 0.2064 | test_acc: 0.9384


100%|██████████| 10/10 [00:25&lt;00:00,  2.57s/it]

Epoch: 10 | train_loss: 0.0646 | train_acc: 0.9922 | test_loss: 0.1795 | test_acc: 0.9176
</code></pre></div> <p>Holy cow!</p> <p>Looks like our pretrained ViT feature extractor performed far better than our custom ViT model trained from scratch (in the same amount of time).</p> <p>Let's get visual.</p> <h3 id=105-plot-feature-extractor-vit-model-loss-curves>10.5 Plot feature extractor ViT model loss curves</h3> <p>Our pretrained ViT feature model numbers look good on the training and test sets.</p> <p>How do the loss curves look?</p> <div class=highlight><pre><span></span><code><span class=c1># Plot the loss curves</span>
<span class=kn>from</span><span class=w> </span><span class=nn>helper_functions</span><span class=w> </span><span class=kn>import</span> <span class=n>plot_loss_curves</span>

<span class=n>plot_loss_curves</span><span class=p>(</span><span class=n>pretrained_vit_results</span><span class=p>)</span>
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_169_0.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_169_0.png></a></p> <p>Woah!</p> <p>Those are some close to textbook looking (really good) loss curves (check out <a href=https://www.learnpytorch.io/04_pytorch_custom_datasets/#8-what-should-an-ideal-loss-curve-look-like>04. PyTorch Custom Datasets section 8</a> for what an ideal loss curve should look like).</p> <p>That's the power of transfer learning!</p> <p>We managed to get outstanding results with the <em>same</em> model architecture, except our custom implementation was trained from scratch (worse performance) and this feature extractor model has the power of pretrained weights from ImageNet behind it.</p> <p>What do you think?</p> <p>Would our feature extractor model improve more if you kept training it?</p> <h3 id=106-save-feature-extractor-vit-model-and-check-file-size>10.6 Save feature extractor ViT model and check file size</h3> <p>It looks like our ViT feature extractor model is performing quite well for our Food Vision Mini problem.</p> <p>Perhaps we might want to try deploying it and see how it goes in production (in this case, deploying means putting our trained model in an application someone could use, say taking photos on their smartphone of food and seeing if our model thinks its pizza, steak or sushi).</p> <p>To do so we can first save our model with the <code>utils.save_model()</code> function we created in <a href=https://www.learnpytorch.io/05_pytorch_going_modular/#5-creating-a-function-to-save-the-model-utilspy>05. PyTorch Going Modular section 5</a>.</p> <div class=highlight><pre><span></span><code><span class=c1># Save the model</span>
<span class=kn>from</span><span class=w> </span><span class=nn>going_modular.going_modular</span><span class=w> </span><span class=kn>import</span> <span class=n>utils</span>

<span class=n>utils</span><span class=o>.</span><span class=n>save_model</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>pretrained_vit</span><span class=p>,</span>
                 <span class=n>target_dir</span><span class=o>=</span><span class=s2>&quot;models&quot;</span><span class=p>,</span>
                 <span class=n>model_name</span><span class=o>=</span><span class=s2>&quot;08_pretrained_vit_feature_extractor_pizza_steak_sushi.pth&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>[INFO] Saving model to: models/08_pretrained_vit_feature_extractor_pizza_steak_sushi.pth
</code></pre></div> <p>And since we're thinking about deploying this model, it'd be good to know the size of it (in megabytes or MB).</p> <p>Since we want our Food Vision Mini application to run fast, generally a smaller model with good performance will be better than a larger model with great performance.</p> <p>We can check the size of our model in bytes using the <code>st_size</code> attribute of Python's <a href=https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat><code>pathlib.Path().stat()</code></a> method whilst passing it our model's filepath name.</p> <p>We can then scale the size in bytes to megabytes.</p> <div class=highlight><pre><span></span><code><span class=kn>from</span><span class=w> </span><span class=nn>pathlib</span><span class=w> </span><span class=kn>import</span> <span class=n>Path</span>

<span class=c1># Get the model size in bytes then convert to megabytes</span>
<span class=n>pretrained_vit_model_size</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&quot;models/08_pretrained_vit_feature_extractor_pizza_steak_sushi.pth&quot;</span><span class=p>)</span><span class=o>.</span><span class=n>stat</span><span class=p>()</span><span class=o>.</span><span class=n>st_size</span> <span class=o>//</span> <span class=p>(</span><span class=mi>1024</span><span class=o>*</span><span class=mi>1024</span><span class=p>)</span> <span class=c1># division converts bytes to megabytes (roughly)</span>
<span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Pretrained ViT feature extractor model size: </span><span class=si>{</span><span class=n>pretrained_vit_model_size</span><span class=si>}</span><span class=s2> MB&quot;</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Pretrained ViT feature extractor model size: 327 MB
</code></pre></div> <p>Hmm, looks like our ViT feature extractor model for Food Vision Mini turned out to be about 327 MB in size.</p> <p>How does this compare to the EffNetB2 feature extractor model in <a href=https://www.learnpytorch.io/07_pytorch_experiment_tracking/#9-load-in-the-best-model-and-make-predictions-with-it>07. PyTorch Experiment Tracking section 9</a>?</p> <table> <thead> <tr> <th><strong>Model</strong></th> <th><strong>Model size (MB)</strong></th> <th><strong>Test loss</strong></th> <th><strong>Test accuracy</strong></th> </tr> </thead> <tbody> <tr> <td>EffNetB2 feature extractor^</td> <td>29</td> <td>~0.3906</td> <td>~0.9384</td> </tr> <tr> <td>ViT feature extractor</td> <td>327</td> <td>~0.1084</td> <td>~0.9384</td> </tr> </tbody> </table> <blockquote> <p><strong>Note:</strong> ^ the EffNetB2 model in reference was trained with 20% of pizza, steak and sushi data (double the amount of images) rather than the ViT feature extractor which was trained with 10% of pizza, steak and sushi data. An exercise would be to train the ViT feature extractor model on the same amount of data and see how much the results improve.</p> </blockquote> <p>The EffNetB2 model is ~11x smaller than the ViT model with similiar results for test loss and accuracy.</p> <p>However, the ViT model's results may improve more when trained with the same data (20% pizza, steak and sushi data).</p> <p>But in terms of deployment, if we were comparing these two models, something we'd need to consider is whether the extra accuracy from the ViT model is worth the ~11x increase in model size?</p> <p>Perhaps such a large model would take longer to load/run and wouldn't provide as good an experience as EffNetB2 which performs similarly but at a much reduced size.</p> <h2 id=11-make-predictions-on-a-custom-image>11. Make predictions on a custom image</h2> <p>And finally, we'll finish with the ultimate test, predicting on our own custom data.</p> <p>Let's download the pizza dad image (a photo of my dad eating pizza) and use our ViT feature extractor to predict on it.</p> <p>To do we, let's can use the <code>pred_and_plot()</code> function we created in <a href=https://www.learnpytorch.io/06_pytorch_transfer_learning/#6-make-predictions-on-images-from-the-test-set>06. PyTorch Transfer Learning section 6</a>, for convenience, I saved this function to <a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/going_modular/going_modular/predictions.py><code>going_modular.going_modular.predictions.py</code></a> on the course GitHub.</p> <div class=highlight><pre><span></span><code><span class=kn>import</span><span class=w> </span><span class=nn>requests</span>

<span class=c1># Import function to make predictions on images and plot them</span>
<span class=kn>from</span><span class=w> </span><span class=nn>going_modular.going_modular.predictions</span><span class=w> </span><span class=kn>import</span> <span class=n>pred_and_plot_image</span>

<span class=c1># Setup custom image path</span>
<span class=n>custom_image_path</span> <span class=o>=</span> <span class=n>image_path</span> <span class=o>/</span> <span class=s2>&quot;04-pizza-dad.jpeg&quot;</span>

<span class=c1># Download the image if it doesn&#39;t already exist</span>
<span class=k>if</span> <span class=ow>not</span> <span class=n>custom_image_path</span><span class=o>.</span><span class=n>is_file</span><span class=p>():</span>
    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>custom_image_path</span><span class=p>,</span> <span class=s2>&quot;wb&quot;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
        <span class=c1># When downloading from GitHub, need to use the &quot;raw&quot; file link</span>
        <span class=n>request</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pizza-dad.jpeg&quot;</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Downloading </span><span class=si>{</span><span class=n>custom_image_path</span><span class=si>}</span><span class=s2>...&quot;</span><span class=p>)</span>
        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>request</span><span class=o>.</span><span class=n>content</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;</span><span class=si>{</span><span class=n>custom_image_path</span><span class=si>}</span><span class=s2> already exists, skipping download.&quot;</span><span class=p>)</span>

<span class=c1># Predict on custom image</span>
<span class=n>pred_and_plot_image</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=n>pretrained_vit</span><span class=p>,</span>
                    <span class=n>image_path</span><span class=o>=</span><span class=n>custom_image_path</span><span class=p>,</span>
                    <span class=n>class_names</span><span class=o>=</span><span class=n>class_names</span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code>Downloading data/pizza_steak_sushi/04-pizza-dad.jpeg...
</code></pre></div> <p><a class=glightbox href=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_177_1.png data-type=image data-width=auto data-height=auto data-desc-position=bottom><img alt=png src=../08_pytorch_paper_replicating_files/08_pytorch_paper_replicating_177_1.png></a></p> <p>Two thumbs up!</p> <p>Congratulations!</p> <p>We've gone all the way from research paper to usable model code on our own custom images!</p> <h2 id=main-takeaways>Main takeaways</h2> <ul> <li>With the explosion of machine learning, new research papers detailing advancements come out every day. And it's impossible to keep up with it <em>all</em> but you can narrow things down to your own use case, such as what we did here, replicating a computer vision paper for FoodVision Mini.</li> <li>Machine learning research papers often contain months of research by teams of smart people compressed into a few pages (so teasing out all the details and replicating the paper in full can be a bit of challenge).</li> <li>The goal of paper replicating is to turn machine learning research papers (text and math) into usable code.<ul> <li>With this being said, many machine learning research teams are starting to publish code with their papers and one of the best places to see this is at <a href=https://paperswithcode.com/ >Paperswithcode.com</a></li> </ul> </li> <li>Breaking a machine learning research paper into inputs and outputs (what goes in and out of each layer/block/model?) and layers (how does each layer manipulate the input?) and blocks (a collection of layers) and replicating each part step by step (like we've done in this notebook) can be very helpful for understanding.</li> <li>Pretrained models are available for many state of the art model architectures and with the power of transfer learning, these often perform <em>very</em> well with little data.</li> <li>Larger models generally perform better but have a larger footprint too (they take up more storage space and can take longer to perform inference).<ul> <li>A big question is: deployment wise, is the extra performance of a larger model worth it/aligned with the use case?</li> </ul> </li> </ul> <h2 id=exercises>Exercises</h2> <blockquote> <p><strong>Note:</strong> These exercises expect the use of <code>torchvision</code> v0.13+ (released July 2022), previous versions may work but will likely have errors.</p> </blockquote> <p>All of the exercises are focused on practicing the code above.</p> <p>You should be able to complete them by referencing each section or by following the resource(s) linked.</p> <p>All exercises should be completed using <a href=https://pytorch.org/docs/stable/notes/cuda.html#device-agnostic-code>device-agnostic code</a>.</p> <p><strong>Resources:</strong></p> <ul> <li><a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/exercises/08_pytorch_paper_replicating_exercises.ipynb>Exercise template notebook for 08</a>.</li> <li> <p><a href=https://github.com/mrdbourke/pytorch-deep-learning/blob/main/extras/solutions/08_pytorch_paper_replicating_exercise_solutions.ipynb>Example solutions notebook for 08</a> (try the exercises <em>before</em> looking at this).</p> <ul> <li>See a live <a href=https://youtu.be/tjpW_BY8y3g>video walkthrough of the solutions on YouTube</a> (errors and all).</li> </ul> </li> <li> <p>Replicate the ViT architecture we created with in-built <a href=https://pytorch.org/docs/stable/nn.html#transformer-layers>PyTorch transformer layers</a>.</p> <ul> <li>You'll want to look into replacing our <code>TransformerEncoderBlock()</code> class with <a href=https://pytorch.org/docs/stable/generated/torch.nn.TransformerEncoderLayer.html#torch.nn.TransformerEncoderLayer><code>torch.nn.TransformerEncoderLayer()</code></a> (these contain the same layers as our custom blocks).</li> <li>You can stack <code>torch.nn.TransformerEncoderLayer()</code>'s on top of each other with <a href=https://pytorch.org/docs/stable/generated/torch.nn.TransformerEncoder.html#torch.nn.TransformerEncoder><code>torch.nn.TransformerEncoder()</code></a>.</li> </ul> </li> <li>Turn the custom ViT architecture we created into a Python script, for example, <code>vit.py</code>.<ul> <li>You should be able to import an entire ViT model using something like<code>from vit import ViT</code>.</li> </ul> </li> <li>Train a pretrained ViT feature extractor model (like the one we made in <a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#10-bring-in-pretrained-vit-from-torchvisionmodels-on-same-dataset>08. PyTorch Paper Replicating section 10</a>) on 20% of the pizza, steak and sushi data like the dataset we used in <a href=https://www.learnpytorch.io/07_pytorch_experiment_tracking/#73-download-different-datasets>07. PyTorch Experiment Tracking section 7.3</a>.<ul> <li>See how it performs compared to the EffNetB2 model we compared it to in <a href=https://www.learnpytorch.io/08_pytorch_paper_replicating/#106-save-feature-extractor-vit-model-and-check-file-size>08. PyTorch Paper Replicating section 10.6</a>.</li> </ul> </li> <li>Try repeating the steps from excercise 3 but this time use the "<code>ViT_B_16_Weights.IMAGENET1K_SWAG_E2E_V1</code>" pretrained weights from <a href=https://pytorch.org/vision/stable/models/generated/torchvision.models.vit_b_16.html#torchvision.models.vit_b_16><code>torchvision.models.vit_b_16()</code></a>.<ul> <li><strong>Note:</strong> ViT pretrained with SWAG weights has a minimum input image size of <code>(384, 384)</code> (the pretrained ViT in exercise 3 has a minimum input size of <code>(224, 224)</code>), though this is accessible in the weights <code>.transforms()</code> method.</li> </ul> </li> <li>Our custom ViT model architecture closely mimics that of the ViT paper, however, our training recipe misses a few things. Research some of the following topics from Table 3 in the ViT paper that we miss and write a sentence about each and how it might help with training:<ul> <li>ImageNet-21k pretraining (more data).</li> <li>Learning rate warmup.</li> <li>Learning rate decay.</li> <li>Gradient clipping.</li> </ul> </li> </ul> <h2 id=extra-curriculum>Extra-curriculum</h2> <ul> <li>There have been several iterations and tweaks to the Vision Transformer since its original release and the most concise and best performing (as of July 2022) can be viewed in <a href=https://arxiv.org/abs/2205.01580><em>Better plain ViT baselines for ImageNet-1k</em></a>. Despite of the upgrades, we stuck with replicating a "vanilla Vision Transformer" in this notebook because if you understand the structure of the original, you can bridge to different iterations.</li> <li>The <a href=https://github.com/lucidrains/vit-pytorch><code>vit-pytorch</code> repository on GitHub by lucidrains</a> is one of the most extensive resources of different ViT architectures implemented in PyTorch. It's a phenomenal reference and one I used often to create the materials we've been through in this chapter.</li> <li>PyTorch have their <a href=https://github.com/pytorch/vision/blob/main/torchvision/models/vision_transformer.py>own implementation of the ViT architecture on GitHub</a>, it's used as the basis of the pretrained ViT models in <code>torchvision.models</code>.</li> <li>Jay Alammar has fantastic illustrations and explanations on his blog of the <a href=https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/ >attention mechanism</a> (the foundation of Transformer models) and <a href=https://jalammar.github.io/illustrated-transformer/ >Transformer models</a>.</li> <li>Adrish Dey has a fantastic <a href=https://wandb.ai/wandb_fc/LayerNorm/reports/Layer-Normalization-in-Pytorch-With-Examples---VmlldzoxMjk5MTk1>write up of Layer Normalization</a> (a main component of the ViT architecture) can help neural network training.</li> <li>The self-attention (and multi-head self-attention) mechanism is at the heart of the ViT architecture as well as many other Transformer architectures, it was originally introduced in the <a href=https://arxiv.org/abs/1706.03762><em>Attention is all you need</em></a> paper.</li> <li>Yannic Kilcher's YouTube channel is a sensational resource for visual paper walkthroughs, you can see his videos for the following papers:<ul> <li><a href="https://www.youtube.com/watch?v=iDulhoQ2pro">Attention is all you need</a> (the paper that introduced the Transformer architecture).</li> <li><a href=https://youtu.be/TrdevFK_am4>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</a> (the paper that introduced the ViT architecture).</li> </ul> </li> </ul> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.instant", "navigation.path", "navigation.indexes", "navigation.top", "navigation.tracking"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../../../assets/javascripts/bundle.c8b220af.min.js></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script> <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body> </html>